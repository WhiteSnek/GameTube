// --- template _header.gotpl ---
// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package db

import (
	"context"
	"fmt"
	"os"
	"slices"
	"testing"

	// no-op import for go modules
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"

	"github.com/steebchen/prisma-client-go/engine"
	"github.com/steebchen/prisma-client-go/engine/mock"
	"github.com/steebchen/prisma-client-go/runtime/builder"
	"github.com/steebchen/prisma-client-go/runtime/lifecycle"
	"github.com/steebchen/prisma-client-go/runtime/raw"
	"github.com/steebchen/prisma-client-go/runtime/transaction"
	"github.com/steebchen/prisma-client-go/runtime/types"
	rawmodels "github.com/steebchen/prisma-client-go/runtime/types/raw"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

type PrismaTransaction = transaction.Transaction

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type Boolean = bool
type String = string
type Int = int
type Float = float64

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

type RawString = rawmodels.String
type RawInt = rawmodels.Int
type RawFloat = rawmodels.Float
type RawBoolean = rawmodels.Boolean
type RawDateTime = rawmodels.DateTime
type RawJSON = rawmodels.JSON
type RawBytes = rawmodels.Bytes
type RawBigInt = rawmodels.BigInt
type RawDecimal = rawmodels.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template client.gotpl ---
const datasources = `[{"name":"db","provider":"postgresql","activeProvider":"postgresql","url":{"fromEnvVar":"DATABASE_URL","value":""},"config":null}]`

const schema = `// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "go run github.com/steebchen/prisma-client-go"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         String        @id @default(cuid())
  fullname   String
  email      String        @unique
  password   String
  dob        String?
  avatar     String
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  isVerified Boolean       @default(false)
  guilds     GuildMember[]
  videos     Videos[]
  ownedGuild Guild?        @relation("Owner")
  comments   Comments[]
  replies    Replies[]
  likes      Likes[]
}

model Guild {
  id          String        @id @default(cuid())
  ownerId     String        @unique
  name        String
  description String?
  avatar      String?
  coverImage  String?
  isPrivate   Boolean       @default(false)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  owner       User          @relation("Owner", fields: [ownerId], references: [id])
  members     GuildMember[]
  videos      Videos[]
  tags        Tags[]
}

model GuildMember {
  id       String   @id @default(cuid())
  userId   String
  guildId  String
  role     ROLE     @default(MEMBER)
  joinedAt DateTime @default(now())
  status   STATUS   @default(APPROVED)
  user     User     @relation(fields: [userId], references: [id])
  guild    Guild    @relation(fields: [guildId], references: [id])

  @@unique([userId, guildId])
}

enum ROLE {
  MEMBER
  LEADER
  CO_LEADER
  ELDER
}

enum STATUS {
  PENDING
  APPROVED
  REJECTED
}

model Videos {
  id          String         @id @default(cuid())
  title       String
  description String
  thumbnail   String
  videoUrl    String
  duration    Int
  ownerId     String
  guildId     String
  createdAt   DateTime       @default(now())
  owner       User           @relation(fields: [ownerId], references: [id])
  guild       Guild          @relation(fields: [guildId], references: [id])
  tags        TagsOnVideos[]
  isPrivate   Boolean        @default(false)
  likes       Likes[]
  views       Int            @default(0)
  history     history[]
  watchLater  WatchLater[]
}

model Tags {
  id      String         @id @default(cuid())
  name    String
  guildId String
  guild   Guild          @relation(fields: [guildId], references: [id], onDelete: Cascade)
  videos  TagsOnVideos[]

  @@unique([name, guildId])
}

model TagsOnVideos {
  id      String @id @default(cuid())
  videoId String
  tagId   String

  video Videos @relation(fields: [videoId], references: [id], onDelete: Cascade)
  tag   Tags   @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([videoId, tagId])
}

model Comments {
  id        String   @id @default(cuid())
  ownerId   String
  role      ROLE
  videoId   String
  content   String
  likes     Likes[]
  owner     User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
}

model Replies {
  id        String   @id @default(cuid())
  ownerId   String
  role      ROLE
  commentId String?
  replyId   String?
  content   String
  likes     Likes[]
  createdAt DateTime @default(now())
  videoId   String
  owner     User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
}

model Likes {
  id         String @id @default(cuid())
  entityType ENTITY
  ownerId    String

  videoId   String?
  commentId String?
  replyId   String?

  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  video   Videos?   @relation(fields: [videoId], references: [id])
  comment Comments? @relation(fields: [commentId], references: [id])
  reply   Replies?  @relation(fields: [replyId], references: [id])
}

enum ENTITY {
  VIDEO
  COMMENT
  REPLY
}

model history {
  id       String   @id @default(cuid())
  userId   String
  videoId  String
  video    Videos   @relation(fields: [videoId], references: [id])
  viewedAt DateTime @default(now())
}

model WatchLater {
  id        String   @id @default(cuid())
  userId    String
  videoId   String
  video     Videos   @relation(fields: [videoId], references: [id])
  createdAt DateTime @default(now())
}
`
const schemaDatasourceURL = ""
const schemaEnvVarName = "DATABASE_URL"

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = true

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//	client := db.NewClient()
//	if err := client.Prisma.Connect(); err != nil {
//	  handle(err)
//	}
//
//	defer func() {
//	  if err := client.Prisma.Disconnect(); err != nil {
//	    panic(fmt.Errorf("could not disconnect: %w", err))
//	  }
//	}()
func NewClient(options ...func(config *PrismaConfig)) *PrismaClient {
	var config PrismaConfig
	for _, option := range options {
		option(&config)
	}

	c := newClient()

	// use the schema connection url if set
	url := config.datasourceURL
	if url == "" {
		url = schemaDatasourceURL
		if url == "" {
			// if not, use the schema env var name
			url = os.Getenv(schemaEnvVarName)
			if url == "" {
				//panic("no connection string found")
				println("WARNING: env var which was defined in the Prisma schema is not set " + schemaEnvVarName)
			}
		}
	}

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets, datasources, url)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

type PrismaConfig struct {
	datasourceURL string
}

func WithDatasourceURL(url string) func(*PrismaConfig) {
	return func(config *PrismaConfig) {
		config.datasourceURL = url
	}
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.User = userActions{client: c}
	c.Guild = guildActions{client: c}
	c.GuildMember = guildMemberActions{client: c}
	c.Videos = videosActions{client: c}
	c.Tags = tagsActions{client: c}
	c.TagsOnVideos = tagsOnVideosActions{client: c}
	c.Comments = commentsActions{client: c}
	c.Replies = repliesActions{client: c}
	c.Likes = likesActions{client: c}
	c.History = historyActions{client: c}
	c.WatchLater = watchLaterActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// User provides access to CRUD methods.
	User userActions
	// Guild provides access to CRUD methods.
	Guild guildActions
	// GuildMember provides access to CRUD methods.
	GuildMember guildMemberActions
	// Videos provides access to CRUD methods.
	Videos videosActions
	// Tags provides access to CRUD methods.
	Tags tagsActions
	// TagsOnVideos provides access to CRUD methods.
	TagsOnVideos tagsOnVideosActions
	// Comments provides access to CRUD methods.
	Comments commentsActions
	// Replies provides access to CRUD methods.
	Replies repliesActions
	// Likes provides access to CRUD methods.
	Likes likesActions
	// History provides access to CRUD methods.
	History historyActions
	// WatchLater provides access to CRUD methods.
	WatchLater watchLaterActions
}

// --- template enums.gotpl ---

type Role string

const (
	RoleMember   Role = "MEMBER"
	RoleLeader   Role = "LEADER"
	RoleCoLeader Role = "CO_LEADER"
	RoleElder    Role = "ELDER"
)

type RawRole Role
type Status string

const (
	StatusPending  Status = "PENDING"
	StatusApproved Status = "APPROVED"
	StatusRejected Status = "REJECTED"
)

type RawStatus Status
type Entity string

const (
	EntityVideo   Entity = "VIDEO"
	EntityComment Entity = "COMMENT"
	EntityReply   Entity = "REPLY"
)

type RawEntity Entity

type TransactionIsolationLevel string

const (
	TransactionIsolationLevelReadUncommitted TransactionIsolationLevel = "ReadUncommitted"
	TransactionIsolationLevelReadCommitted   TransactionIsolationLevel = "ReadCommitted"
	TransactionIsolationLevelRepeatableRead  TransactionIsolationLevel = "RepeatableRead"
	TransactionIsolationLevelSerializable    TransactionIsolationLevel = "Serializable"
)

type UserScalarFieldEnum string

const (
	UserScalarFieldEnumID         UserScalarFieldEnum = "id"
	UserScalarFieldEnumFullname   UserScalarFieldEnum = "fullname"
	UserScalarFieldEnumEmail      UserScalarFieldEnum = "email"
	UserScalarFieldEnumPassword   UserScalarFieldEnum = "password"
	UserScalarFieldEnumDob        UserScalarFieldEnum = "dob"
	UserScalarFieldEnumAvatar     UserScalarFieldEnum = "avatar"
	UserScalarFieldEnumCreatedAt  UserScalarFieldEnum = "createdAt"
	UserScalarFieldEnumUpdatedAt  UserScalarFieldEnum = "updatedAt"
	UserScalarFieldEnumIsVerified UserScalarFieldEnum = "isVerified"
)

type GuildScalarFieldEnum string

const (
	GuildScalarFieldEnumID          GuildScalarFieldEnum = "id"
	GuildScalarFieldEnumOwnerID     GuildScalarFieldEnum = "ownerId"
	GuildScalarFieldEnumName        GuildScalarFieldEnum = "name"
	GuildScalarFieldEnumDescription GuildScalarFieldEnum = "description"
	GuildScalarFieldEnumAvatar      GuildScalarFieldEnum = "avatar"
	GuildScalarFieldEnumCoverImage  GuildScalarFieldEnum = "coverImage"
	GuildScalarFieldEnumIsPrivate   GuildScalarFieldEnum = "isPrivate"
	GuildScalarFieldEnumCreatedAt   GuildScalarFieldEnum = "createdAt"
	GuildScalarFieldEnumUpdatedAt   GuildScalarFieldEnum = "updatedAt"
)

type GuildMemberScalarFieldEnum string

const (
	GuildMemberScalarFieldEnumID       GuildMemberScalarFieldEnum = "id"
	GuildMemberScalarFieldEnumUserID   GuildMemberScalarFieldEnum = "userId"
	GuildMemberScalarFieldEnumGuildID  GuildMemberScalarFieldEnum = "guildId"
	GuildMemberScalarFieldEnumRole     GuildMemberScalarFieldEnum = "role"
	GuildMemberScalarFieldEnumJoinedAt GuildMemberScalarFieldEnum = "joinedAt"
	GuildMemberScalarFieldEnumStatus   GuildMemberScalarFieldEnum = "status"
)

type VideosScalarFieldEnum string

const (
	VideosScalarFieldEnumID          VideosScalarFieldEnum = "id"
	VideosScalarFieldEnumTitle       VideosScalarFieldEnum = "title"
	VideosScalarFieldEnumDescription VideosScalarFieldEnum = "description"
	VideosScalarFieldEnumThumbnail   VideosScalarFieldEnum = "thumbnail"
	VideosScalarFieldEnumVideoURL    VideosScalarFieldEnum = "videoUrl"
	VideosScalarFieldEnumDuration    VideosScalarFieldEnum = "duration"
	VideosScalarFieldEnumOwnerID     VideosScalarFieldEnum = "ownerId"
	VideosScalarFieldEnumGuildID     VideosScalarFieldEnum = "guildId"
	VideosScalarFieldEnumCreatedAt   VideosScalarFieldEnum = "createdAt"
	VideosScalarFieldEnumIsPrivate   VideosScalarFieldEnum = "isPrivate"
	VideosScalarFieldEnumViews       VideosScalarFieldEnum = "views"
)

type TagsScalarFieldEnum string

const (
	TagsScalarFieldEnumID      TagsScalarFieldEnum = "id"
	TagsScalarFieldEnumName    TagsScalarFieldEnum = "name"
	TagsScalarFieldEnumGuildID TagsScalarFieldEnum = "guildId"
)

type TagsOnVideosScalarFieldEnum string

const (
	TagsOnVideosScalarFieldEnumID      TagsOnVideosScalarFieldEnum = "id"
	TagsOnVideosScalarFieldEnumVideoID TagsOnVideosScalarFieldEnum = "videoId"
	TagsOnVideosScalarFieldEnumTagID   TagsOnVideosScalarFieldEnum = "tagId"
)

type CommentsScalarFieldEnum string

const (
	CommentsScalarFieldEnumID        CommentsScalarFieldEnum = "id"
	CommentsScalarFieldEnumOwnerID   CommentsScalarFieldEnum = "ownerId"
	CommentsScalarFieldEnumRole      CommentsScalarFieldEnum = "role"
	CommentsScalarFieldEnumVideoID   CommentsScalarFieldEnum = "videoId"
	CommentsScalarFieldEnumContent   CommentsScalarFieldEnum = "content"
	CommentsScalarFieldEnumCreatedAt CommentsScalarFieldEnum = "createdAt"
)

type RepliesScalarFieldEnum string

const (
	RepliesScalarFieldEnumID        RepliesScalarFieldEnum = "id"
	RepliesScalarFieldEnumOwnerID   RepliesScalarFieldEnum = "ownerId"
	RepliesScalarFieldEnumRole      RepliesScalarFieldEnum = "role"
	RepliesScalarFieldEnumCommentID RepliesScalarFieldEnum = "commentId"
	RepliesScalarFieldEnumReplyID   RepliesScalarFieldEnum = "replyId"
	RepliesScalarFieldEnumContent   RepliesScalarFieldEnum = "content"
	RepliesScalarFieldEnumCreatedAt RepliesScalarFieldEnum = "createdAt"
	RepliesScalarFieldEnumVideoID   RepliesScalarFieldEnum = "videoId"
)

type LikesScalarFieldEnum string

const (
	LikesScalarFieldEnumID         LikesScalarFieldEnum = "id"
	LikesScalarFieldEnumEntityType LikesScalarFieldEnum = "entityType"
	LikesScalarFieldEnumOwnerID    LikesScalarFieldEnum = "ownerId"
	LikesScalarFieldEnumVideoID    LikesScalarFieldEnum = "videoId"
	LikesScalarFieldEnumCommentID  LikesScalarFieldEnum = "commentId"
	LikesScalarFieldEnumReplyID    LikesScalarFieldEnum = "replyId"
)

type HistoryScalarFieldEnum string

const (
	HistoryScalarFieldEnumID       HistoryScalarFieldEnum = "id"
	HistoryScalarFieldEnumUserID   HistoryScalarFieldEnum = "userId"
	HistoryScalarFieldEnumVideoID  HistoryScalarFieldEnum = "videoId"
	HistoryScalarFieldEnumViewedAt HistoryScalarFieldEnum = "viewedAt"
)

type WatchLaterScalarFieldEnum string

const (
	WatchLaterScalarFieldEnumID        WatchLaterScalarFieldEnum = "id"
	WatchLaterScalarFieldEnumUserID    WatchLaterScalarFieldEnum = "userId"
	WatchLaterScalarFieldEnumVideoID   WatchLaterScalarFieldEnum = "videoId"
	WatchLaterScalarFieldEnumCreatedAt WatchLaterScalarFieldEnum = "createdAt"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type QueryMode string

const (
	QueryModeDefault     QueryMode = "default"
	QueryModeInsensitive QueryMode = "insensitive"
)

type NullsOrder string

const (
	NullsOrderFirst NullsOrder = "first"
	NullsOrderLast  NullsOrder = "last"
)

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound
var IsErrNotFound = types.IsErrNotFound

type ErrUniqueConstraint = types.ErrUniqueConstraint[prismaFields]

// IsErrUniqueConstraint returns on a unique constraint error or violation with error info
// Use as follows:
//
//	user, err := db.User.CreateOne(...).Exec(cxt)
//	if err != nil {
//		if info, err := db.IsErrUniqueConstraint(err); err != nil {
//			// Fields exists for Postgres and SQLite
//			log.Printf("unique constraint on the fields: %s", info.Fields)
//
//			// you can also compare it with generated field names:
//			if info.Fields[0] == db.User.Name.Field() {
//				// do something
//			}
//
//			// For MySQL, use the constraint key
//			log.Printf("unique constraint on the key: %s", info.Key)
//		}
//	}
func IsErrUniqueConstraint(err error) (*types.ErrUniqueConstraint[prismaFields], bool) {
	return types.CheckUniqueConstraint[prismaFields](err)
}

// --- template fields.gotpl ---
type prismaFields string

type userPrismaFields = prismaFields

const userFieldID userPrismaFields = "id"

const userFieldFullname userPrismaFields = "fullname"

const userFieldEmail userPrismaFields = "email"

const userFieldPassword userPrismaFields = "password"

const userFieldDob userPrismaFields = "dob"

const userFieldAvatar userPrismaFields = "avatar"

const userFieldCreatedAt userPrismaFields = "createdAt"

const userFieldUpdatedAt userPrismaFields = "updatedAt"

const userFieldIsVerified userPrismaFields = "isVerified"

const userFieldGuilds userPrismaFields = "guilds"

const userFieldVideos userPrismaFields = "videos"

const userFieldOwnedGuild userPrismaFields = "ownedGuild"

const userFieldComments userPrismaFields = "comments"

const userFieldReplies userPrismaFields = "replies"

const userFieldLikes userPrismaFields = "likes"

type guildPrismaFields = prismaFields

const guildFieldID guildPrismaFields = "id"

const guildFieldOwnerID guildPrismaFields = "ownerId"

const guildFieldName guildPrismaFields = "name"

const guildFieldDescription guildPrismaFields = "description"

const guildFieldAvatar guildPrismaFields = "avatar"

const guildFieldCoverImage guildPrismaFields = "coverImage"

const guildFieldIsPrivate guildPrismaFields = "isPrivate"

const guildFieldCreatedAt guildPrismaFields = "createdAt"

const guildFieldUpdatedAt guildPrismaFields = "updatedAt"

const guildFieldOwner guildPrismaFields = "owner"

const guildFieldMembers guildPrismaFields = "members"

const guildFieldVideos guildPrismaFields = "videos"

const guildFieldTags guildPrismaFields = "tags"

type guildMemberPrismaFields = prismaFields

const guildMemberFieldID guildMemberPrismaFields = "id"

const guildMemberFieldUserID guildMemberPrismaFields = "userId"

const guildMemberFieldGuildID guildMemberPrismaFields = "guildId"

const guildMemberFieldRole guildMemberPrismaFields = "role"

const guildMemberFieldJoinedAt guildMemberPrismaFields = "joinedAt"

const guildMemberFieldStatus guildMemberPrismaFields = "status"

const guildMemberFieldUser guildMemberPrismaFields = "user"

const guildMemberFieldGuild guildMemberPrismaFields = "guild"

type videosPrismaFields = prismaFields

const videosFieldID videosPrismaFields = "id"

const videosFieldTitle videosPrismaFields = "title"

const videosFieldDescription videosPrismaFields = "description"

const videosFieldThumbnail videosPrismaFields = "thumbnail"

const videosFieldVideoURL videosPrismaFields = "videoUrl"

const videosFieldDuration videosPrismaFields = "duration"

const videosFieldOwnerID videosPrismaFields = "ownerId"

const videosFieldGuildID videosPrismaFields = "guildId"

const videosFieldCreatedAt videosPrismaFields = "createdAt"

const videosFieldOwner videosPrismaFields = "owner"

const videosFieldGuild videosPrismaFields = "guild"

const videosFieldTags videosPrismaFields = "tags"

const videosFieldIsPrivate videosPrismaFields = "isPrivate"

const videosFieldLikes videosPrismaFields = "likes"

const videosFieldViews videosPrismaFields = "views"

const videosFieldHistory videosPrismaFields = "history"

const videosFieldWatchLater videosPrismaFields = "watchLater"

type tagsPrismaFields = prismaFields

const tagsFieldID tagsPrismaFields = "id"

const tagsFieldName tagsPrismaFields = "name"

const tagsFieldGuildID tagsPrismaFields = "guildId"

const tagsFieldGuild tagsPrismaFields = "guild"

const tagsFieldVideos tagsPrismaFields = "videos"

type tagsOnVideosPrismaFields = prismaFields

const tagsOnVideosFieldID tagsOnVideosPrismaFields = "id"

const tagsOnVideosFieldVideoID tagsOnVideosPrismaFields = "videoId"

const tagsOnVideosFieldTagID tagsOnVideosPrismaFields = "tagId"

const tagsOnVideosFieldVideo tagsOnVideosPrismaFields = "video"

const tagsOnVideosFieldTag tagsOnVideosPrismaFields = "tag"

type commentsPrismaFields = prismaFields

const commentsFieldID commentsPrismaFields = "id"

const commentsFieldOwnerID commentsPrismaFields = "ownerId"

const commentsFieldRole commentsPrismaFields = "role"

const commentsFieldVideoID commentsPrismaFields = "videoId"

const commentsFieldContent commentsPrismaFields = "content"

const commentsFieldLikes commentsPrismaFields = "likes"

const commentsFieldOwner commentsPrismaFields = "owner"

const commentsFieldCreatedAt commentsPrismaFields = "createdAt"

type repliesPrismaFields = prismaFields

const repliesFieldID repliesPrismaFields = "id"

const repliesFieldOwnerID repliesPrismaFields = "ownerId"

const repliesFieldRole repliesPrismaFields = "role"

const repliesFieldCommentID repliesPrismaFields = "commentId"

const repliesFieldReplyID repliesPrismaFields = "replyId"

const repliesFieldContent repliesPrismaFields = "content"

const repliesFieldLikes repliesPrismaFields = "likes"

const repliesFieldCreatedAt repliesPrismaFields = "createdAt"

const repliesFieldVideoID repliesPrismaFields = "videoId"

const repliesFieldOwner repliesPrismaFields = "owner"

type likesPrismaFields = prismaFields

const likesFieldID likesPrismaFields = "id"

const likesFieldEntityType likesPrismaFields = "entityType"

const likesFieldOwnerID likesPrismaFields = "ownerId"

const likesFieldVideoID likesPrismaFields = "videoId"

const likesFieldCommentID likesPrismaFields = "commentId"

const likesFieldReplyID likesPrismaFields = "replyId"

const likesFieldOwner likesPrismaFields = "owner"

const likesFieldVideo likesPrismaFields = "video"

const likesFieldComment likesPrismaFields = "comment"

const likesFieldReply likesPrismaFields = "reply"

type historyPrismaFields = prismaFields

const historyFieldID historyPrismaFields = "id"

const historyFieldUserID historyPrismaFields = "userId"

const historyFieldVideoID historyPrismaFields = "videoId"

const historyFieldVideo historyPrismaFields = "video"

const historyFieldViewedAt historyPrismaFields = "viewedAt"

type watchLaterPrismaFields = prismaFields

const watchLaterFieldID watchLaterPrismaFields = "id"

const watchLaterFieldUserID watchLaterPrismaFields = "userId"

const watchLaterFieldVideoID watchLaterPrismaFields = "videoId"

const watchLaterFieldVideo watchLaterPrismaFields = "video"

const watchLaterFieldCreatedAt watchLaterPrismaFields = "createdAt"

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.User = userMock{
		mock: m,
	}

	m.Guild = guildMock{
		mock: m,
	}

	m.GuildMember = guildMemberMock{
		mock: m,
	}

	m.Videos = videosMock{
		mock: m,
	}

	m.Tags = tagsMock{
		mock: m,
	}

	m.TagsOnVideos = tagsOnVideosMock{
		mock: m,
	}

	m.Comments = commentsMock{
		mock: m,
	}

	m.Replies = repliesMock{
		mock: m,
	}

	m.Likes = likesMock{
		mock: m,
	}

	m.History = historyMock{
		mock: m,
	}

	m.WatchLater = watchLaterMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	User userMock

	Guild guildMock

	GuildMember guildMemberMock

	Videos videosMock

	Tags tagsMock

	TagsOnVideos tagsOnVideosMock

	Comments commentsMock

	Replies repliesMock

	Likes likesMock

	History historyMock

	WatchLater watchLaterMock
}

type userMock struct {
	mock *Mock
}

type UserMockExpectParam interface {
	ExtractQuery() builder.Query
	userModel()
}

func (m *userMock) Expect(query UserMockExpectParam) *userMockExec {
	return &userMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type userMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *userMockExec) Returns(v UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) ReturnsMany(v []UserModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *userMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type guildMock struct {
	mock *Mock
}

type GuildMockExpectParam interface {
	ExtractQuery() builder.Query
	guildModel()
}

func (m *guildMock) Expect(query GuildMockExpectParam) *guildMockExec {
	return &guildMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type guildMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *guildMockExec) Returns(v GuildModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *guildMockExec) ReturnsMany(v []GuildModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *guildMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type guildMemberMock struct {
	mock *Mock
}

type GuildMemberMockExpectParam interface {
	ExtractQuery() builder.Query
	guildMemberModel()
}

func (m *guildMemberMock) Expect(query GuildMemberMockExpectParam) *guildMemberMockExec {
	return &guildMemberMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type guildMemberMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *guildMemberMockExec) Returns(v GuildMemberModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *guildMemberMockExec) ReturnsMany(v []GuildMemberModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *guildMemberMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type videosMock struct {
	mock *Mock
}

type VideosMockExpectParam interface {
	ExtractQuery() builder.Query
	videosModel()
}

func (m *videosMock) Expect(query VideosMockExpectParam) *videosMockExec {
	return &videosMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type videosMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *videosMockExec) Returns(v VideosModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *videosMockExec) ReturnsMany(v []VideosModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *videosMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type tagsMock struct {
	mock *Mock
}

type TagsMockExpectParam interface {
	ExtractQuery() builder.Query
	tagsModel()
}

func (m *tagsMock) Expect(query TagsMockExpectParam) *tagsMockExec {
	return &tagsMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type tagsMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *tagsMockExec) Returns(v TagsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *tagsMockExec) ReturnsMany(v []TagsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *tagsMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type tagsOnVideosMock struct {
	mock *Mock
}

type TagsOnVideosMockExpectParam interface {
	ExtractQuery() builder.Query
	tagsOnVideosModel()
}

func (m *tagsOnVideosMock) Expect(query TagsOnVideosMockExpectParam) *tagsOnVideosMockExec {
	return &tagsOnVideosMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type tagsOnVideosMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *tagsOnVideosMockExec) Returns(v TagsOnVideosModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *tagsOnVideosMockExec) ReturnsMany(v []TagsOnVideosModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *tagsOnVideosMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type commentsMock struct {
	mock *Mock
}

type CommentsMockExpectParam interface {
	ExtractQuery() builder.Query
	commentsModel()
}

func (m *commentsMock) Expect(query CommentsMockExpectParam) *commentsMockExec {
	return &commentsMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type commentsMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *commentsMockExec) Returns(v CommentsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *commentsMockExec) ReturnsMany(v []CommentsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *commentsMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type repliesMock struct {
	mock *Mock
}

type RepliesMockExpectParam interface {
	ExtractQuery() builder.Query
	repliesModel()
}

func (m *repliesMock) Expect(query RepliesMockExpectParam) *repliesMockExec {
	return &repliesMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type repliesMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *repliesMockExec) Returns(v RepliesModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *repliesMockExec) ReturnsMany(v []RepliesModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *repliesMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type likesMock struct {
	mock *Mock
}

type LikesMockExpectParam interface {
	ExtractQuery() builder.Query
	likesModel()
}

func (m *likesMock) Expect(query LikesMockExpectParam) *likesMockExec {
	return &likesMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type likesMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *likesMockExec) Returns(v LikesModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *likesMockExec) ReturnsMany(v []LikesModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *likesMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type historyMock struct {
	mock *Mock
}

type HistoryMockExpectParam interface {
	ExtractQuery() builder.Query
	historyModel()
}

func (m *historyMock) Expect(query HistoryMockExpectParam) *historyMockExec {
	return &historyMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type historyMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *historyMockExec) Returns(v HistoryModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *historyMockExec) ReturnsMany(v []HistoryModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *historyMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type watchLaterMock struct {
	mock *Mock
}

type WatchLaterMockExpectParam interface {
	ExtractQuery() builder.Query
	watchLaterModel()
}

func (m *watchLaterMock) Expect(query WatchLaterMockExpectParam) *watchLaterMockExec {
	return &watchLaterMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type watchLaterMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *watchLaterMockExec) Returns(v WatchLaterModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *watchLaterMockExec) ReturnsMany(v []WatchLaterModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *watchLaterMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// UserModel represents the User model and is a wrapper for accessing fields and methods
type UserModel struct {
	InnerUser
	RelationsUser
}

// InnerUser holds the actual data
type InnerUser struct {
	ID         string   `json:"id"`
	Fullname   string   `json:"fullname"`
	Email      string   `json:"email"`
	Password   string   `json:"password"`
	Dob        *string  `json:"dob,omitempty"`
	Avatar     string   `json:"avatar"`
	CreatedAt  DateTime `json:"createdAt"`
	UpdatedAt  DateTime `json:"updatedAt"`
	IsVerified bool     `json:"isVerified"`
}

// RawUserModel is a struct for User when used in raw queries
type RawUserModel struct {
	ID         RawString   `json:"id"`
	Fullname   RawString   `json:"fullname"`
	Email      RawString   `json:"email"`
	Password   RawString   `json:"password"`
	Dob        *RawString  `json:"dob,omitempty"`
	Avatar     RawString   `json:"avatar"`
	CreatedAt  RawDateTime `json:"createdAt"`
	UpdatedAt  RawDateTime `json:"updatedAt"`
	IsVerified RawBoolean  `json:"isVerified"`
}

// RelationsUser holds the relation data separately
type RelationsUser struct {
	Guilds     []GuildMemberModel `json:"guilds,omitempty"`
	Videos     []VideosModel      `json:"videos,omitempty"`
	OwnedGuild *GuildModel        `json:"ownedGuild,omitempty"`
	Comments   []CommentsModel    `json:"comments,omitempty"`
	Replies    []RepliesModel     `json:"replies,omitempty"`
	Likes      []LikesModel       `json:"likes,omitempty"`
}

func (r UserModel) Dob() (value String, ok bool) {
	if r.InnerUser.Dob == nil {
		return value, false
	}
	return *r.InnerUser.Dob, true
}

func (r UserModel) Guilds() (value []GuildMemberModel) {
	if r.RelationsUser.Guilds == nil {
		panic("attempted to access guilds but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Guilds
}

func (r UserModel) Videos() (value []VideosModel) {
	if r.RelationsUser.Videos == nil {
		panic("attempted to access videos but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Videos
}

func (r UserModel) OwnedGuild() (value *GuildModel, ok bool) {
	if r.RelationsUser.OwnedGuild == nil {
		return value, false
	}
	return r.RelationsUser.OwnedGuild, true
}

func (r UserModel) Comments() (value []CommentsModel) {
	if r.RelationsUser.Comments == nil {
		panic("attempted to access comments but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Comments
}

func (r UserModel) Replies() (value []RepliesModel) {
	if r.RelationsUser.Replies == nil {
		panic("attempted to access replies but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Replies
}

func (r UserModel) Likes() (value []LikesModel) {
	if r.RelationsUser.Likes == nil {
		panic("attempted to access likes but did not fetch it using the .With() syntax")
	}
	return r.RelationsUser.Likes
}

// GuildModel represents the Guild model and is a wrapper for accessing fields and methods
type GuildModel struct {
	InnerGuild
	RelationsGuild
}

// InnerGuild holds the actual data
type InnerGuild struct {
	ID          string   `json:"id"`
	OwnerID     string   `json:"ownerId"`
	Name        string   `json:"name"`
	Description *string  `json:"description,omitempty"`
	Avatar      *string  `json:"avatar,omitempty"`
	CoverImage  *string  `json:"coverImage,omitempty"`
	IsPrivate   bool     `json:"isPrivate"`
	CreatedAt   DateTime `json:"createdAt"`
	UpdatedAt   DateTime `json:"updatedAt"`
}

// RawGuildModel is a struct for Guild when used in raw queries
type RawGuildModel struct {
	ID          RawString   `json:"id"`
	OwnerID     RawString   `json:"ownerId"`
	Name        RawString   `json:"name"`
	Description *RawString  `json:"description,omitempty"`
	Avatar      *RawString  `json:"avatar,omitempty"`
	CoverImage  *RawString  `json:"coverImage,omitempty"`
	IsPrivate   RawBoolean  `json:"isPrivate"`
	CreatedAt   RawDateTime `json:"createdAt"`
	UpdatedAt   RawDateTime `json:"updatedAt"`
}

// RelationsGuild holds the relation data separately
type RelationsGuild struct {
	Owner   *UserModel         `json:"owner,omitempty"`
	Members []GuildMemberModel `json:"members,omitempty"`
	Videos  []VideosModel      `json:"videos,omitempty"`
	Tags    []TagsModel        `json:"tags,omitempty"`
}

func (r GuildModel) Description() (value String, ok bool) {
	if r.InnerGuild.Description == nil {
		return value, false
	}
	return *r.InnerGuild.Description, true
}

func (r GuildModel) Avatar() (value String, ok bool) {
	if r.InnerGuild.Avatar == nil {
		return value, false
	}
	return *r.InnerGuild.Avatar, true
}

func (r GuildModel) CoverImage() (value String, ok bool) {
	if r.InnerGuild.CoverImage == nil {
		return value, false
	}
	return *r.InnerGuild.CoverImage, true
}

func (r GuildModel) Owner() (value *UserModel) {
	if r.RelationsGuild.Owner == nil {
		panic("attempted to access owner but did not fetch it using the .With() syntax")
	}
	return r.RelationsGuild.Owner
}

func (r GuildModel) Members() (value []GuildMemberModel) {
	if r.RelationsGuild.Members == nil {
		panic("attempted to access members but did not fetch it using the .With() syntax")
	}
	return r.RelationsGuild.Members
}

func (r GuildModel) Videos() (value []VideosModel) {
	if r.RelationsGuild.Videos == nil {
		panic("attempted to access videos but did not fetch it using the .With() syntax")
	}
	return r.RelationsGuild.Videos
}

func (r GuildModel) Tags() (value []TagsModel) {
	if r.RelationsGuild.Tags == nil {
		panic("attempted to access tags but did not fetch it using the .With() syntax")
	}
	return r.RelationsGuild.Tags
}

// GuildMemberModel represents the GuildMember model and is a wrapper for accessing fields and methods
type GuildMemberModel struct {
	InnerGuildMember
	RelationsGuildMember
}

// InnerGuildMember holds the actual data
type InnerGuildMember struct {
	ID       string   `json:"id"`
	UserID   string   `json:"userId"`
	GuildID  string   `json:"guildId"`
	Role     Role     `json:"role"`
	JoinedAt DateTime `json:"joinedAt"`
	Status   Status   `json:"status"`
}

// RawGuildMemberModel is a struct for GuildMember when used in raw queries
type RawGuildMemberModel struct {
	ID       RawString   `json:"id"`
	UserID   RawString   `json:"userId"`
	GuildID  RawString   `json:"guildId"`
	Role     RawRole     `json:"role"`
	JoinedAt RawDateTime `json:"joinedAt"`
	Status   RawStatus   `json:"status"`
}

// RelationsGuildMember holds the relation data separately
type RelationsGuildMember struct {
	User  *UserModel  `json:"user,omitempty"`
	Guild *GuildModel `json:"guild,omitempty"`
}

func (r GuildMemberModel) User() (value *UserModel) {
	if r.RelationsGuildMember.User == nil {
		panic("attempted to access user but did not fetch it using the .With() syntax")
	}
	return r.RelationsGuildMember.User
}

func (r GuildMemberModel) Guild() (value *GuildModel) {
	if r.RelationsGuildMember.Guild == nil {
		panic("attempted to access guild but did not fetch it using the .With() syntax")
	}
	return r.RelationsGuildMember.Guild
}

// VideosModel represents the Videos model and is a wrapper for accessing fields and methods
type VideosModel struct {
	InnerVideos
	RelationsVideos
}

// InnerVideos holds the actual data
type InnerVideos struct {
	ID          string   `json:"id"`
	Title       string   `json:"title"`
	Description string   `json:"description"`
	Thumbnail   string   `json:"thumbnail"`
	VideoURL    string   `json:"videoUrl"`
	Duration    int      `json:"duration"`
	OwnerID     string   `json:"ownerId"`
	GuildID     string   `json:"guildId"`
	CreatedAt   DateTime `json:"createdAt"`
	IsPrivate   bool     `json:"isPrivate"`
	Views       int      `json:"views"`
}

// RawVideosModel is a struct for Videos when used in raw queries
type RawVideosModel struct {
	ID          RawString   `json:"id"`
	Title       RawString   `json:"title"`
	Description RawString   `json:"description"`
	Thumbnail   RawString   `json:"thumbnail"`
	VideoURL    RawString   `json:"videoUrl"`
	Duration    RawInt      `json:"duration"`
	OwnerID     RawString   `json:"ownerId"`
	GuildID     RawString   `json:"guildId"`
	CreatedAt   RawDateTime `json:"createdAt"`
	IsPrivate   RawBoolean  `json:"isPrivate"`
	Views       RawInt      `json:"views"`
}

// RelationsVideos holds the relation data separately
type RelationsVideos struct {
	Owner      *UserModel          `json:"owner,omitempty"`
	Guild      *GuildModel         `json:"guild,omitempty"`
	Tags       []TagsOnVideosModel `json:"tags,omitempty"`
	Likes      []LikesModel        `json:"likes,omitempty"`
	History    []HistoryModel      `json:"history,omitempty"`
	WatchLater []WatchLaterModel   `json:"watchLater,omitempty"`
}

func (r VideosModel) Owner() (value *UserModel) {
	if r.RelationsVideos.Owner == nil {
		panic("attempted to access owner but did not fetch it using the .With() syntax")
	}
	return r.RelationsVideos.Owner
}

func (r VideosModel) Guild() (value *GuildModel) {
	if r.RelationsVideos.Guild == nil {
		panic("attempted to access guild but did not fetch it using the .With() syntax")
	}
	return r.RelationsVideos.Guild
}

func (r VideosModel) Tags() (value []TagsOnVideosModel) {
	if r.RelationsVideos.Tags == nil {
		panic("attempted to access tags but did not fetch it using the .With() syntax")
	}
	return r.RelationsVideos.Tags
}

func (r VideosModel) Likes() (value []LikesModel) {
	if r.RelationsVideos.Likes == nil {
		panic("attempted to access likes but did not fetch it using the .With() syntax")
	}
	return r.RelationsVideos.Likes
}

func (r VideosModel) History() (value []HistoryModel) {
	if r.RelationsVideos.History == nil {
		panic("attempted to access history but did not fetch it using the .With() syntax")
	}
	return r.RelationsVideos.History
}

func (r VideosModel) WatchLater() (value []WatchLaterModel) {
	if r.RelationsVideos.WatchLater == nil {
		panic("attempted to access watchLater but did not fetch it using the .With() syntax")
	}
	return r.RelationsVideos.WatchLater
}

// TagsModel represents the Tags model and is a wrapper for accessing fields and methods
type TagsModel struct {
	InnerTags
	RelationsTags
}

// InnerTags holds the actual data
type InnerTags struct {
	ID      string `json:"id"`
	Name    string `json:"name"`
	GuildID string `json:"guildId"`
}

// RawTagsModel is a struct for Tags when used in raw queries
type RawTagsModel struct {
	ID      RawString `json:"id"`
	Name    RawString `json:"name"`
	GuildID RawString `json:"guildId"`
}

// RelationsTags holds the relation data separately
type RelationsTags struct {
	Guild  *GuildModel         `json:"guild,omitempty"`
	Videos []TagsOnVideosModel `json:"videos,omitempty"`
}

func (r TagsModel) Guild() (value *GuildModel) {
	if r.RelationsTags.Guild == nil {
		panic("attempted to access guild but did not fetch it using the .With() syntax")
	}
	return r.RelationsTags.Guild
}

func (r TagsModel) Videos() (value []TagsOnVideosModel) {
	if r.RelationsTags.Videos == nil {
		panic("attempted to access videos but did not fetch it using the .With() syntax")
	}
	return r.RelationsTags.Videos
}

// TagsOnVideosModel represents the TagsOnVideos model and is a wrapper for accessing fields and methods
type TagsOnVideosModel struct {
	InnerTagsOnVideos
	RelationsTagsOnVideos
}

// InnerTagsOnVideos holds the actual data
type InnerTagsOnVideos struct {
	ID      string `json:"id"`
	VideoID string `json:"videoId"`
	TagID   string `json:"tagId"`
}

// RawTagsOnVideosModel is a struct for TagsOnVideos when used in raw queries
type RawTagsOnVideosModel struct {
	ID      RawString `json:"id"`
	VideoID RawString `json:"videoId"`
	TagID   RawString `json:"tagId"`
}

// RelationsTagsOnVideos holds the relation data separately
type RelationsTagsOnVideos struct {
	Video *VideosModel `json:"video,omitempty"`
	Tag   *TagsModel   `json:"tag,omitempty"`
}

func (r TagsOnVideosModel) Video() (value *VideosModel) {
	if r.RelationsTagsOnVideos.Video == nil {
		panic("attempted to access video but did not fetch it using the .With() syntax")
	}
	return r.RelationsTagsOnVideos.Video
}

func (r TagsOnVideosModel) Tag() (value *TagsModel) {
	if r.RelationsTagsOnVideos.Tag == nil {
		panic("attempted to access tag but did not fetch it using the .With() syntax")
	}
	return r.RelationsTagsOnVideos.Tag
}

// CommentsModel represents the Comments model and is a wrapper for accessing fields and methods
type CommentsModel struct {
	InnerComments
	RelationsComments
}

// InnerComments holds the actual data
type InnerComments struct {
	ID        string   `json:"id"`
	OwnerID   string   `json:"ownerId"`
	Role      Role     `json:"role"`
	VideoID   string   `json:"videoId"`
	Content   string   `json:"content"`
	CreatedAt DateTime `json:"createdAt"`
}

// RawCommentsModel is a struct for Comments when used in raw queries
type RawCommentsModel struct {
	ID        RawString   `json:"id"`
	OwnerID   RawString   `json:"ownerId"`
	Role      RawRole     `json:"role"`
	VideoID   RawString   `json:"videoId"`
	Content   RawString   `json:"content"`
	CreatedAt RawDateTime `json:"createdAt"`
}

// RelationsComments holds the relation data separately
type RelationsComments struct {
	Likes []LikesModel `json:"likes,omitempty"`
	Owner *UserModel   `json:"owner,omitempty"`
}

func (r CommentsModel) Likes() (value []LikesModel) {
	if r.RelationsComments.Likes == nil {
		panic("attempted to access likes but did not fetch it using the .With() syntax")
	}
	return r.RelationsComments.Likes
}

func (r CommentsModel) Owner() (value *UserModel) {
	if r.RelationsComments.Owner == nil {
		panic("attempted to access owner but did not fetch it using the .With() syntax")
	}
	return r.RelationsComments.Owner
}

// RepliesModel represents the Replies model and is a wrapper for accessing fields and methods
type RepliesModel struct {
	InnerReplies
	RelationsReplies
}

// InnerReplies holds the actual data
type InnerReplies struct {
	ID        string   `json:"id"`
	OwnerID   string   `json:"ownerId"`
	Role      Role     `json:"role"`
	CommentID *string  `json:"commentId,omitempty"`
	ReplyID   *string  `json:"replyId,omitempty"`
	Content   string   `json:"content"`
	CreatedAt DateTime `json:"createdAt"`
	VideoID   string   `json:"videoId"`
}

// RawRepliesModel is a struct for Replies when used in raw queries
type RawRepliesModel struct {
	ID        RawString   `json:"id"`
	OwnerID   RawString   `json:"ownerId"`
	Role      RawRole     `json:"role"`
	CommentID *RawString  `json:"commentId,omitempty"`
	ReplyID   *RawString  `json:"replyId,omitempty"`
	Content   RawString   `json:"content"`
	CreatedAt RawDateTime `json:"createdAt"`
	VideoID   RawString   `json:"videoId"`
}

// RelationsReplies holds the relation data separately
type RelationsReplies struct {
	Likes []LikesModel `json:"likes,omitempty"`
	Owner *UserModel   `json:"owner,omitempty"`
}

func (r RepliesModel) CommentID() (value String, ok bool) {
	if r.InnerReplies.CommentID == nil {
		return value, false
	}
	return *r.InnerReplies.CommentID, true
}

func (r RepliesModel) ReplyID() (value String, ok bool) {
	if r.InnerReplies.ReplyID == nil {
		return value, false
	}
	return *r.InnerReplies.ReplyID, true
}

func (r RepliesModel) Likes() (value []LikesModel) {
	if r.RelationsReplies.Likes == nil {
		panic("attempted to access likes but did not fetch it using the .With() syntax")
	}
	return r.RelationsReplies.Likes
}

func (r RepliesModel) Owner() (value *UserModel) {
	if r.RelationsReplies.Owner == nil {
		panic("attempted to access owner but did not fetch it using the .With() syntax")
	}
	return r.RelationsReplies.Owner
}

// LikesModel represents the Likes model and is a wrapper for accessing fields and methods
type LikesModel struct {
	InnerLikes
	RelationsLikes
}

// InnerLikes holds the actual data
type InnerLikes struct {
	ID         string  `json:"id"`
	EntityType Entity  `json:"entityType"`
	OwnerID    string  `json:"ownerId"`
	VideoID    *string `json:"videoId,omitempty"`
	CommentID  *string `json:"commentId,omitempty"`
	ReplyID    *string `json:"replyId,omitempty"`
}

// RawLikesModel is a struct for Likes when used in raw queries
type RawLikesModel struct {
	ID         RawString  `json:"id"`
	EntityType RawEntity  `json:"entityType"`
	OwnerID    RawString  `json:"ownerId"`
	VideoID    *RawString `json:"videoId,omitempty"`
	CommentID  *RawString `json:"commentId,omitempty"`
	ReplyID    *RawString `json:"replyId,omitempty"`
}

// RelationsLikes holds the relation data separately
type RelationsLikes struct {
	Owner   *UserModel     `json:"owner,omitempty"`
	Video   *VideosModel   `json:"video,omitempty"`
	Comment *CommentsModel `json:"comment,omitempty"`
	Reply   *RepliesModel  `json:"reply,omitempty"`
}

func (r LikesModel) VideoID() (value String, ok bool) {
	if r.InnerLikes.VideoID == nil {
		return value, false
	}
	return *r.InnerLikes.VideoID, true
}

func (r LikesModel) CommentID() (value String, ok bool) {
	if r.InnerLikes.CommentID == nil {
		return value, false
	}
	return *r.InnerLikes.CommentID, true
}

func (r LikesModel) ReplyID() (value String, ok bool) {
	if r.InnerLikes.ReplyID == nil {
		return value, false
	}
	return *r.InnerLikes.ReplyID, true
}

func (r LikesModel) Owner() (value *UserModel) {
	if r.RelationsLikes.Owner == nil {
		panic("attempted to access owner but did not fetch it using the .With() syntax")
	}
	return r.RelationsLikes.Owner
}

func (r LikesModel) Video() (value *VideosModel, ok bool) {
	if r.RelationsLikes.Video == nil {
		return value, false
	}
	return r.RelationsLikes.Video, true
}

func (r LikesModel) Comment() (value *CommentsModel, ok bool) {
	if r.RelationsLikes.Comment == nil {
		return value, false
	}
	return r.RelationsLikes.Comment, true
}

func (r LikesModel) Reply() (value *RepliesModel, ok bool) {
	if r.RelationsLikes.Reply == nil {
		return value, false
	}
	return r.RelationsLikes.Reply, true
}

// HistoryModel represents the history model and is a wrapper for accessing fields and methods
type HistoryModel struct {
	InnerHistory
	RelationsHistory
}

// InnerHistory holds the actual data
type InnerHistory struct {
	ID       string   `json:"id"`
	UserID   string   `json:"userId"`
	VideoID  string   `json:"videoId"`
	ViewedAt DateTime `json:"viewedAt"`
}

// RawHistoryModel is a struct for history when used in raw queries
type RawHistoryModel struct {
	ID       RawString   `json:"id"`
	UserID   RawString   `json:"userId"`
	VideoID  RawString   `json:"videoId"`
	ViewedAt RawDateTime `json:"viewedAt"`
}

// RelationsHistory holds the relation data separately
type RelationsHistory struct {
	Video *VideosModel `json:"video,omitempty"`
}

func (r HistoryModel) Video() (value *VideosModel) {
	if r.RelationsHistory.Video == nil {
		panic("attempted to access video but did not fetch it using the .With() syntax")
	}
	return r.RelationsHistory.Video
}

// WatchLaterModel represents the WatchLater model and is a wrapper for accessing fields and methods
type WatchLaterModel struct {
	InnerWatchLater
	RelationsWatchLater
}

// InnerWatchLater holds the actual data
type InnerWatchLater struct {
	ID        string   `json:"id"`
	UserID    string   `json:"userId"`
	VideoID   string   `json:"videoId"`
	CreatedAt DateTime `json:"createdAt"`
}

// RawWatchLaterModel is a struct for WatchLater when used in raw queries
type RawWatchLaterModel struct {
	ID        RawString   `json:"id"`
	UserID    RawString   `json:"userId"`
	VideoID   RawString   `json:"videoId"`
	CreatedAt RawDateTime `json:"createdAt"`
}

// RelationsWatchLater holds the relation data separately
type RelationsWatchLater struct {
	Video *VideosModel `json:"video,omitempty"`
}

func (r WatchLaterModel) Video() (value *VideosModel) {
	if r.RelationsWatchLater.Video == nil {
		panic("attempted to access video but did not fetch it using the .With() syntax")
	}
	return r.RelationsWatchLater.Video
}

// --- template query.gotpl ---

// User acts as a namespaces to access query methods for the User model
var User = userQuery{}

// userQuery exposes query functions for the user model
type userQuery struct {

	// ID
	//
	// @required
	ID userQueryIDString

	// Fullname
	//
	// @required
	Fullname userQueryFullnameString

	// Email
	//
	// @required
	// @unique
	Email userQueryEmailString

	// Password
	//
	// @required
	Password userQueryPasswordString

	// Dob
	//
	// @optional
	Dob userQueryDobString

	// Avatar
	//
	// @required
	Avatar userQueryAvatarString

	// CreatedAt
	//
	// @required
	CreatedAt userQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt userQueryUpdatedAtDateTime

	// IsVerified
	//
	// @required
	IsVerified userQueryIsVerifiedBoolean

	Guilds userQueryGuildsRelations

	Videos userQueryVideosRelations

	OwnedGuild userQueryOwnedGuildRelations

	Comments userQueryCommentsRelations

	Replies userQueryRepliesRelations

	Likes userQueryLikesRelations
}

func (userQuery) Not(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) Or(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (userQuery) And(params ...UserWhereParam) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type userQueryIDString struct{}

// Set the required value of ID
func (r userQueryIDString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r userQueryIDString) SetIfPresent(value *String) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryIDString) Equals(value string) userWithPrismaIDEqualsUniqueParam {

	return userWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EqualsIfPresent(value *string) userWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return userWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryIDString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r userQueryIDString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r userQueryIDString) In(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryIDString) NotIn(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryIDString) Lt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryIDString) Lte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryIDString) Gt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryIDString) Gte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryIDString) Contains(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryIDString) StartsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryIDString) EndsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryIDString) Mode(value QueryMode) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) ModeIfPresent(value *QueryMode) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Mode(*value)
}

func (r userQueryIDString) Not(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIDString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryIDString) HasPrefix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryIDString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryIDString) HasSuffix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryIDString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryIDString) Field() userPrismaFields {
	return userFieldID
}

// base struct
type userQueryFullnameString struct{}

// Set the required value of Fullname
func (r userQueryFullnameString) Set(value string) userWithPrismaFullnameSetParam {

	return userWithPrismaFullnameSetParam{
		data: builder.Field{
			Name:  "fullname",
			Value: value,
		},
	}

}

// Set the optional value of Fullname dynamically
func (r userQueryFullnameString) SetIfPresent(value *String) userWithPrismaFullnameSetParam {
	if value == nil {
		return userWithPrismaFullnameSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryFullnameString) Equals(value string) userWithPrismaFullnameEqualsParam {

	return userWithPrismaFullnameEqualsParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFullnameString) EqualsIfPresent(value *string) userWithPrismaFullnameEqualsParam {
	if value == nil {
		return userWithPrismaFullnameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryFullnameString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "fullname",
			Value: direction,
		},
	}
}

func (r userQueryFullnameString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "fullname",
			Value: cursor,
		},
	}
}

func (r userQueryFullnameString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFullnameString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryFullnameString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFullnameString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryFullnameString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFullnameString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryFullnameString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFullnameString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryFullnameString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFullnameString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryFullnameString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFullnameString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryFullnameString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFullnameString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryFullnameString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFullnameString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryFullnameString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFullnameString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryFullnameString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFullnameString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryFullnameString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryFullnameString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryFullnameString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryFullnameString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryFullnameString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "fullname",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryFullnameString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryFullnameString) Field() userPrismaFields {
	return userFieldFullname
}

// base struct
type userQueryEmailString struct{}

// Set the required value of Email
func (r userQueryEmailString) Set(value string) userWithPrismaEmailSetParam {

	return userWithPrismaEmailSetParam{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}

}

// Set the optional value of Email dynamically
func (r userQueryEmailString) SetIfPresent(value *String) userWithPrismaEmailSetParam {
	if value == nil {
		return userWithPrismaEmailSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryEmailString) Equals(value string) userWithPrismaEmailEqualsUniqueParam {

	return userWithPrismaEmailEqualsUniqueParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) EqualsIfPresent(value *string) userWithPrismaEmailEqualsUniqueParam {
	if value == nil {
		return userWithPrismaEmailEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r userQueryEmailString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "email",
			Value: direction,
		},
	}
}

func (r userQueryEmailString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "email",
			Value: cursor,
		},
	}
}

func (r userQueryEmailString) In(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) InIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.In(value)
}

func (r userQueryEmailString) NotIn(value []string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) NotInIfPresent(value []string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.NotIn(value)
}

func (r userQueryEmailString) Lt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) LtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lt(*value)
}

func (r userQueryEmailString) Lte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) LteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Lte(*value)
}

func (r userQueryEmailString) Gt(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) GtIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gt(*value)
}

func (r userQueryEmailString) Gte(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) GteIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Gte(*value)
}

func (r userQueryEmailString) Contains(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) ContainsIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Contains(*value)
}

func (r userQueryEmailString) StartsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) StartsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r userQueryEmailString) EndsWith(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) EndsWithIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r userQueryEmailString) Mode(value QueryMode) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) ModeIfPresent(value *QueryMode) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Mode(*value)
}

func (r userQueryEmailString) Not(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryEmailString) NotIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryEmailString) HasPrefix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryEmailString) HasPrefixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryEmailString) HasSuffix(value string) userParamUnique {
	return userParamUnique{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryEmailString) HasSuffixIfPresent(value *string) userParamUnique {
	if value == nil {
		return userParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryEmailString) Field() userPrismaFields {
	return userFieldEmail
}

// base struct
type userQueryPasswordString struct{}

// Set the required value of Password
func (r userQueryPasswordString) Set(value string) userWithPrismaPasswordSetParam {

	return userWithPrismaPasswordSetParam{
		data: builder.Field{
			Name:  "password",
			Value: value,
		},
	}

}

// Set the optional value of Password dynamically
func (r userQueryPasswordString) SetIfPresent(value *String) userWithPrismaPasswordSetParam {
	if value == nil {
		return userWithPrismaPasswordSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryPasswordString) Equals(value string) userWithPrismaPasswordEqualsParam {

	return userWithPrismaPasswordEqualsParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) EqualsIfPresent(value *string) userWithPrismaPasswordEqualsParam {
	if value == nil {
		return userWithPrismaPasswordEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryPasswordString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "password",
			Value: direction,
		},
	}
}

func (r userQueryPasswordString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "password",
			Value: cursor,
		},
	}
}

func (r userQueryPasswordString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryPasswordString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryPasswordString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryPasswordString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryPasswordString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryPasswordString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryPasswordString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryPasswordString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryPasswordString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryPasswordString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryPasswordString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryPasswordString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryPasswordString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryPasswordString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryPasswordString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "password",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryPasswordString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryPasswordString) Field() userPrismaFields {
	return userFieldPassword
}

// base struct
type userQueryDobString struct{}

// Set the optional value of Dob
func (r userQueryDobString) Set(value string) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "dob",
			Value: value,
		},
	}

}

// Set the optional value of Dob dynamically
func (r userQueryDobString) SetIfPresent(value *String) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Dob dynamically
func (r userQueryDobString) SetOptional(value *String) userSetParam {
	if value == nil {

		var v *string
		return userSetParam{
			data: builder.Field{
				Name:  "dob",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r userQueryDobString) Equals(value string) userWithPrismaDobEqualsParam {

	return userWithPrismaDobEqualsParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDobString) EqualsIfPresent(value *string) userWithPrismaDobEqualsParam {
	if value == nil {
		return userWithPrismaDobEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryDobString) EqualsOptional(value *String) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDobString) IsNull() userDefaultParam {
	var str *string = nil
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r userQueryDobString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "dob",
			Value: direction,
		},
	}
}

func (r userQueryDobString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "dob",
			Value: cursor,
		},
	}
}

func (r userQueryDobString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDobString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryDobString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDobString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryDobString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDobString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryDobString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDobString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryDobString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDobString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryDobString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDobString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryDobString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDobString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryDobString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDobString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryDobString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDobString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryDobString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDobString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryDobString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryDobString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryDobString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryDobString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryDobString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "dob",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryDobString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryDobString) Field() userPrismaFields {
	return userFieldDob
}

// base struct
type userQueryAvatarString struct{}

// Set the required value of Avatar
func (r userQueryAvatarString) Set(value string) userWithPrismaAvatarSetParam {

	return userWithPrismaAvatarSetParam{
		data: builder.Field{
			Name:  "avatar",
			Value: value,
		},
	}

}

// Set the optional value of Avatar dynamically
func (r userQueryAvatarString) SetIfPresent(value *String) userWithPrismaAvatarSetParam {
	if value == nil {
		return userWithPrismaAvatarSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryAvatarString) Equals(value string) userWithPrismaAvatarEqualsParam {

	return userWithPrismaAvatarEqualsParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) EqualsIfPresent(value *string) userWithPrismaAvatarEqualsParam {
	if value == nil {
		return userWithPrismaAvatarEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryAvatarString) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "avatar",
			Value: direction,
		},
	}
}

func (r userQueryAvatarString) Cursor(cursor string) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "avatar",
			Value: cursor,
		},
	}
}

func (r userQueryAvatarString) In(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) InIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryAvatarString) NotIn(value []string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) NotInIfPresent(value []string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryAvatarString) Lt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) LtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryAvatarString) Lte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) LteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryAvatarString) Gt(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) GtIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryAvatarString) Gte(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) GteIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryAvatarString) Contains(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) ContainsIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Contains(*value)
}

func (r userQueryAvatarString) StartsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) StartsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r userQueryAvatarString) EndsWith(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) EndsWithIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r userQueryAvatarString) Mode(value QueryMode) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) ModeIfPresent(value *QueryMode) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Mode(*value)
}

func (r userQueryAvatarString) Not(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryAvatarString) NotIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r userQueryAvatarString) HasPrefix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r userQueryAvatarString) HasPrefixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r userQueryAvatarString) HasSuffix(value string) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r userQueryAvatarString) HasSuffixIfPresent(value *string) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r userQueryAvatarString) Field() userPrismaFields {
	return userFieldAvatar
}

// base struct
type userQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r userQueryCreatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r userQueryCreatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryCreatedAtDateTime) Equals(value DateTime) userWithPrismaCreatedAtEqualsParam {

	return userWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return userWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryCreatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r userQueryCreatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r userQueryCreatedAtDateTime) In(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryCreatedAtDateTime) NotIn(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryCreatedAtDateTime) Lt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryCreatedAtDateTime) Lte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryCreatedAtDateTime) Gt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryCreatedAtDateTime) Gte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryCreatedAtDateTime) Not(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryCreatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryCreatedAtDateTime) Before(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryCreatedAtDateTime) After(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryCreatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryCreatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r userQueryCreatedAtDateTime) Field() userPrismaFields {
	return userFieldCreatedAt
}

// base struct
type userQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r userQueryUpdatedAtDateTime) Set(value DateTime) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r userQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryUpdatedAtDateTime) Equals(value DateTime) userWithPrismaUpdatedAtEqualsParam {

	return userWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) userWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return userWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryUpdatedAtDateTime) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r userQueryUpdatedAtDateTime) Cursor(cursor DateTime) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r userQueryUpdatedAtDateTime) In(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) InIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.In(value)
}

func (r userQueryUpdatedAtDateTime) NotIn(value []DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.NotIn(value)
}

func (r userQueryUpdatedAtDateTime) Lt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lt(*value)
}

func (r userQueryUpdatedAtDateTime) Lte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Lte(*value)
}

func (r userQueryUpdatedAtDateTime) Gt(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gt(*value)
}

func (r userQueryUpdatedAtDateTime) Gte(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Gte(*value)
}

func (r userQueryUpdatedAtDateTime) Not(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r userQueryUpdatedAtDateTime) Before(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r userQueryUpdatedAtDateTime) After(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r userQueryUpdatedAtDateTime) BeforeEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r userQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r userQueryUpdatedAtDateTime) AfterEquals(value DateTime) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r userQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) userDefaultParam {
	if value == nil {
		return userDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r userQueryUpdatedAtDateTime) Field() userPrismaFields {
	return userFieldUpdatedAt
}

// base struct
type userQueryIsVerifiedBoolean struct{}

// Set the required value of IsVerified
func (r userQueryIsVerifiedBoolean) Set(value bool) userSetParam {

	return userSetParam{
		data: builder.Field{
			Name:  "isVerified",
			Value: value,
		},
	}

}

// Set the optional value of IsVerified dynamically
func (r userQueryIsVerifiedBoolean) SetIfPresent(value *Boolean) userSetParam {
	if value == nil {
		return userSetParam{}
	}

	return r.Set(*value)
}

func (r userQueryIsVerifiedBoolean) Equals(value bool) userWithPrismaIsVerifiedEqualsParam {

	return userWithPrismaIsVerifiedEqualsParam{
		data: builder.Field{
			Name: "isVerified",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r userQueryIsVerifiedBoolean) EqualsIfPresent(value *bool) userWithPrismaIsVerifiedEqualsParam {
	if value == nil {
		return userWithPrismaIsVerifiedEqualsParam{}
	}
	return r.Equals(*value)
}

func (r userQueryIsVerifiedBoolean) Order(direction SortOrder) userDefaultParam {
	return userDefaultParam{
		data: builder.Field{
			Name:  "isVerified",
			Value: direction,
		},
	}
}

func (r userQueryIsVerifiedBoolean) Cursor(cursor bool) userCursorParam {
	return userCursorParam{
		data: builder.Field{
			Name:  "isVerified",
			Value: cursor,
		},
	}
}

func (r userQueryIsVerifiedBoolean) Field() userPrismaFields {
	return userFieldIsVerified
}

// base struct
type userQueryGuildsGuildMember struct{}

type userQueryGuildsRelations struct{}

// User -> Guilds
//
// @relation
// @required
func (userQueryGuildsRelations) Some(
	params ...GuildMemberWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "guilds",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Guilds
//
// @relation
// @required
func (userQueryGuildsRelations) Every(
	params ...GuildMemberWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "guilds",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Guilds
//
// @relation
// @required
func (userQueryGuildsRelations) None(
	params ...GuildMemberWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "guilds",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryGuildsRelations) Fetch(

	params ...GuildMemberWhereParam,

) userToGuildsFindMany {
	var v userToGuildsFindMany

	v.query.Operation = "query"
	v.query.Method = "guilds"
	v.query.Outputs = guildMemberOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryGuildsRelations) Link(
	params ...GuildMemberWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "guilds",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryGuildsRelations) Unlink(
	params ...GuildMemberWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "guilds",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryGuildsGuildMember) Field() userPrismaFields {
	return userFieldGuilds
}

// base struct
type userQueryVideosVideos struct{}

type userQueryVideosRelations struct{}

// User -> Videos
//
// @relation
// @required
func (userQueryVideosRelations) Some(
	params ...VideosWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Videos
//
// @relation
// @required
func (userQueryVideosRelations) Every(
	params ...VideosWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Videos
//
// @relation
// @required
func (userQueryVideosRelations) None(
	params ...VideosWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryVideosRelations) Fetch(

	params ...VideosWhereParam,

) userToVideosFindMany {
	var v userToVideosFindMany

	v.query.Operation = "query"
	v.query.Method = "videos"
	v.query.Outputs = videosOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryVideosRelations) Link(
	params ...VideosWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryVideosRelations) Unlink(
	params ...VideosWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryVideosVideos) Field() userPrismaFields {
	return userFieldVideos
}

// base struct
type userQueryOwnedGuildGuild struct{}

type userQueryOwnedGuildRelations struct{}

// User -> OwnedGuild
//
// @relation
// @optional
func (userQueryOwnedGuildRelations) Where(
	params ...GuildWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "ownedGuild",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryOwnedGuildRelations) Fetch() userToOwnedGuildFindUnique {
	var v userToOwnedGuildFindUnique

	v.query.Operation = "query"
	v.query.Method = "ownedGuild"
	v.query.Outputs = guildOutput

	return v
}

func (r userQueryOwnedGuildRelations) Link(
	params GuildWhereParam,
) userSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return userSetParam{}
	}

	fields = append(fields, f)

	return userSetParam{
		data: builder.Field{
			Name: "ownedGuild",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r userQueryOwnedGuildRelations) Unlink() userSetParam {
	var v userSetParam

	v = userSetParam{
		data: builder.Field{
			Name: "ownedGuild",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r userQueryOwnedGuildGuild) Field() userPrismaFields {
	return userFieldOwnedGuild
}

// base struct
type userQueryCommentsComments struct{}

type userQueryCommentsRelations struct{}

// User -> Comments
//
// @relation
// @required
func (userQueryCommentsRelations) Some(
	params ...CommentsWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Comments
//
// @relation
// @required
func (userQueryCommentsRelations) Every(
	params ...CommentsWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Comments
//
// @relation
// @required
func (userQueryCommentsRelations) None(
	params ...CommentsWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryCommentsRelations) Fetch(

	params ...CommentsWhereParam,

) userToCommentsFindMany {
	var v userToCommentsFindMany

	v.query.Operation = "query"
	v.query.Method = "comments"
	v.query.Outputs = commentsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryCommentsRelations) Link(
	params ...CommentsWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryCommentsRelations) Unlink(
	params ...CommentsWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "comments",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryCommentsComments) Field() userPrismaFields {
	return userFieldComments
}

// base struct
type userQueryRepliesReplies struct{}

type userQueryRepliesRelations struct{}

// User -> Replies
//
// @relation
// @required
func (userQueryRepliesRelations) Some(
	params ...RepliesWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "replies",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Replies
//
// @relation
// @required
func (userQueryRepliesRelations) Every(
	params ...RepliesWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "replies",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Replies
//
// @relation
// @required
func (userQueryRepliesRelations) None(
	params ...RepliesWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "replies",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryRepliesRelations) Fetch(

	params ...RepliesWhereParam,

) userToRepliesFindMany {
	var v userToRepliesFindMany

	v.query.Operation = "query"
	v.query.Method = "replies"
	v.query.Outputs = repliesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryRepliesRelations) Link(
	params ...RepliesWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "replies",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryRepliesRelations) Unlink(
	params ...RepliesWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "replies",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryRepliesReplies) Field() userPrismaFields {
	return userFieldReplies
}

// base struct
type userQueryLikesLikes struct{}

type userQueryLikesRelations struct{}

// User -> Likes
//
// @relation
// @required
func (userQueryLikesRelations) Some(
	params ...LikesWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Likes
//
// @relation
// @required
func (userQueryLikesRelations) Every(
	params ...LikesWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// User -> Likes
//
// @relation
// @required
func (userQueryLikesRelations) None(
	params ...LikesWhereParam,
) userDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (userQueryLikesRelations) Fetch(

	params ...LikesWhereParam,

) userToLikesFindMany {
	var v userToLikesFindMany

	v.query.Operation = "query"
	v.query.Method = "likes"
	v.query.Outputs = likesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userQueryLikesRelations) Link(
	params ...LikesWhereParam,
) userSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return userSetParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r userQueryLikesRelations) Unlink(
	params ...LikesWhereParam,
) userSetParam {
	var v userSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = userSetParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r userQueryLikesLikes) Field() userPrismaFields {
	return userFieldLikes
}

// Guild acts as a namespaces to access query methods for the Guild model
var Guild = guildQuery{}

// guildQuery exposes query functions for the guild model
type guildQuery struct {

	// ID
	//
	// @required
	ID guildQueryIDString

	// OwnerID
	//
	// @required
	// @unique
	OwnerID guildQueryOwnerIDString

	// Name
	//
	// @required
	Name guildQueryNameString

	// Description
	//
	// @optional
	Description guildQueryDescriptionString

	// Avatar
	//
	// @optional
	Avatar guildQueryAvatarString

	// CoverImage
	//
	// @optional
	CoverImage guildQueryCoverImageString

	// IsPrivate
	//
	// @required
	IsPrivate guildQueryIsPrivateBoolean

	// CreatedAt
	//
	// @required
	CreatedAt guildQueryCreatedAtDateTime

	// UpdatedAt
	//
	// @required
	UpdatedAt guildQueryUpdatedAtDateTime

	Owner guildQueryOwnerRelations

	Members guildQueryMembersRelations

	Videos guildQueryVideosRelations

	Tags guildQueryTagsRelations
}

func (guildQuery) Not(params ...GuildWhereParam) guildDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (guildQuery) Or(params ...GuildWhereParam) guildDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (guildQuery) And(params ...GuildWhereParam) guildDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type guildQueryIDString struct{}

// Set the required value of ID
func (r guildQueryIDString) Set(value string) guildSetParam {

	return guildSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r guildQueryIDString) SetIfPresent(value *String) guildSetParam {
	if value == nil {
		return guildSetParam{}
	}

	return r.Set(*value)
}

func (r guildQueryIDString) Equals(value string) guildWithPrismaIDEqualsUniqueParam {

	return guildWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryIDString) EqualsIfPresent(value *string) guildWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return guildWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r guildQueryIDString) Order(direction SortOrder) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r guildQueryIDString) Cursor(cursor string) guildCursorParam {
	return guildCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r guildQueryIDString) In(value []string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryIDString) InIfPresent(value []string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.In(value)
}

func (r guildQueryIDString) NotIn(value []string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryIDString) NotInIfPresent(value []string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.NotIn(value)
}

func (r guildQueryIDString) Lt(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryIDString) LtIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Lt(*value)
}

func (r guildQueryIDString) Lte(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryIDString) LteIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Lte(*value)
}

func (r guildQueryIDString) Gt(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryIDString) GtIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Gt(*value)
}

func (r guildQueryIDString) Gte(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryIDString) GteIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Gte(*value)
}

func (r guildQueryIDString) Contains(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryIDString) ContainsIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Contains(*value)
}

func (r guildQueryIDString) StartsWith(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryIDString) StartsWithIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r guildQueryIDString) EndsWith(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryIDString) EndsWithIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r guildQueryIDString) Mode(value QueryMode) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryIDString) ModeIfPresent(value *QueryMode) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Mode(*value)
}

func (r guildQueryIDString) Not(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryIDString) NotIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r guildQueryIDString) HasPrefix(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r guildQueryIDString) HasPrefixIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r guildQueryIDString) HasSuffix(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r guildQueryIDString) HasSuffixIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r guildQueryIDString) Field() guildPrismaFields {
	return guildFieldID
}

// base struct
type guildQueryOwnerIDString struct{}

// Set the required value of OwnerID
func (r guildQueryOwnerIDString) Set(value string) guildSetParam {

	return guildSetParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: value,
		},
	}

}

// Set the optional value of OwnerID dynamically
func (r guildQueryOwnerIDString) SetIfPresent(value *String) guildSetParam {
	if value == nil {
		return guildSetParam{}
	}

	return r.Set(*value)
}

func (r guildQueryOwnerIDString) Equals(value string) guildWithPrismaOwnerIDEqualsUniqueParam {

	return guildWithPrismaOwnerIDEqualsUniqueParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryOwnerIDString) EqualsIfPresent(value *string) guildWithPrismaOwnerIDEqualsUniqueParam {
	if value == nil {
		return guildWithPrismaOwnerIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r guildQueryOwnerIDString) Order(direction SortOrder) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: direction,
		},
	}
}

func (r guildQueryOwnerIDString) Cursor(cursor string) guildCursorParam {
	return guildCursorParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: cursor,
		},
	}
}

func (r guildQueryOwnerIDString) In(value []string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryOwnerIDString) InIfPresent(value []string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.In(value)
}

func (r guildQueryOwnerIDString) NotIn(value []string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryOwnerIDString) NotInIfPresent(value []string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.NotIn(value)
}

func (r guildQueryOwnerIDString) Lt(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryOwnerIDString) LtIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Lt(*value)
}

func (r guildQueryOwnerIDString) Lte(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryOwnerIDString) LteIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Lte(*value)
}

func (r guildQueryOwnerIDString) Gt(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryOwnerIDString) GtIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Gt(*value)
}

func (r guildQueryOwnerIDString) Gte(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryOwnerIDString) GteIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Gte(*value)
}

func (r guildQueryOwnerIDString) Contains(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryOwnerIDString) ContainsIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Contains(*value)
}

func (r guildQueryOwnerIDString) StartsWith(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryOwnerIDString) StartsWithIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r guildQueryOwnerIDString) EndsWith(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryOwnerIDString) EndsWithIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r guildQueryOwnerIDString) Mode(value QueryMode) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryOwnerIDString) ModeIfPresent(value *QueryMode) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Mode(*value)
}

func (r guildQueryOwnerIDString) Not(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryOwnerIDString) NotIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r guildQueryOwnerIDString) HasPrefix(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r guildQueryOwnerIDString) HasPrefixIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r guildQueryOwnerIDString) HasSuffix(value string) guildParamUnique {
	return guildParamUnique{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r guildQueryOwnerIDString) HasSuffixIfPresent(value *string) guildParamUnique {
	if value == nil {
		return guildParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r guildQueryOwnerIDString) Field() guildPrismaFields {
	return guildFieldOwnerID
}

// base struct
type guildQueryNameString struct{}

// Set the required value of Name
func (r guildQueryNameString) Set(value string) guildWithPrismaNameSetParam {

	return guildWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r guildQueryNameString) SetIfPresent(value *String) guildWithPrismaNameSetParam {
	if value == nil {
		return guildWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r guildQueryNameString) Equals(value string) guildWithPrismaNameEqualsParam {

	return guildWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryNameString) EqualsIfPresent(value *string) guildWithPrismaNameEqualsParam {
	if value == nil {
		return guildWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r guildQueryNameString) Order(direction SortOrder) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r guildQueryNameString) Cursor(cursor string) guildCursorParam {
	return guildCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r guildQueryNameString) In(value []string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryNameString) InIfPresent(value []string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.In(value)
}

func (r guildQueryNameString) NotIn(value []string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryNameString) NotInIfPresent(value []string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.NotIn(value)
}

func (r guildQueryNameString) Lt(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryNameString) LtIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Lt(*value)
}

func (r guildQueryNameString) Lte(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryNameString) LteIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Lte(*value)
}

func (r guildQueryNameString) Gt(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryNameString) GtIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Gt(*value)
}

func (r guildQueryNameString) Gte(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryNameString) GteIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Gte(*value)
}

func (r guildQueryNameString) Contains(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryNameString) ContainsIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Contains(*value)
}

func (r guildQueryNameString) StartsWith(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryNameString) StartsWithIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r guildQueryNameString) EndsWith(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryNameString) EndsWithIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r guildQueryNameString) Mode(value QueryMode) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryNameString) ModeIfPresent(value *QueryMode) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Mode(*value)
}

func (r guildQueryNameString) Not(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryNameString) NotIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r guildQueryNameString) HasPrefix(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r guildQueryNameString) HasPrefixIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r guildQueryNameString) HasSuffix(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r guildQueryNameString) HasSuffixIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r guildQueryNameString) Field() guildPrismaFields {
	return guildFieldName
}

// base struct
type guildQueryDescriptionString struct{}

// Set the optional value of Description
func (r guildQueryDescriptionString) Set(value string) guildSetParam {

	return guildSetParam{
		data: builder.Field{
			Name:  "description",
			Value: value,
		},
	}

}

// Set the optional value of Description dynamically
func (r guildQueryDescriptionString) SetIfPresent(value *String) guildSetParam {
	if value == nil {
		return guildSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Description dynamically
func (r guildQueryDescriptionString) SetOptional(value *String) guildSetParam {
	if value == nil {

		var v *string
		return guildSetParam{
			data: builder.Field{
				Name:  "description",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r guildQueryDescriptionString) Equals(value string) guildWithPrismaDescriptionEqualsParam {

	return guildWithPrismaDescriptionEqualsParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) EqualsIfPresent(value *string) guildWithPrismaDescriptionEqualsParam {
	if value == nil {
		return guildWithPrismaDescriptionEqualsParam{}
	}
	return r.Equals(*value)
}

func (r guildQueryDescriptionString) EqualsOptional(value *String) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) IsNull() guildDefaultParam {
	var str *string = nil
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) Order(direction SortOrder) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name:  "description",
			Value: direction,
		},
	}
}

func (r guildQueryDescriptionString) Cursor(cursor string) guildCursorParam {
	return guildCursorParam{
		data: builder.Field{
			Name:  "description",
			Value: cursor,
		},
	}
}

func (r guildQueryDescriptionString) In(value []string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) InIfPresent(value []string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.In(value)
}

func (r guildQueryDescriptionString) NotIn(value []string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) NotInIfPresent(value []string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.NotIn(value)
}

func (r guildQueryDescriptionString) Lt(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) LtIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Lt(*value)
}

func (r guildQueryDescriptionString) Lte(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) LteIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Lte(*value)
}

func (r guildQueryDescriptionString) Gt(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) GtIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Gt(*value)
}

func (r guildQueryDescriptionString) Gte(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) GteIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Gte(*value)
}

func (r guildQueryDescriptionString) Contains(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) ContainsIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Contains(*value)
}

func (r guildQueryDescriptionString) StartsWith(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) StartsWithIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r guildQueryDescriptionString) EndsWith(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) EndsWithIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r guildQueryDescriptionString) Mode(value QueryMode) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) ModeIfPresent(value *QueryMode) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Mode(*value)
}

func (r guildQueryDescriptionString) Not(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryDescriptionString) NotIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r guildQueryDescriptionString) HasPrefix(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r guildQueryDescriptionString) HasPrefixIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r guildQueryDescriptionString) HasSuffix(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r guildQueryDescriptionString) HasSuffixIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r guildQueryDescriptionString) Field() guildPrismaFields {
	return guildFieldDescription
}

// base struct
type guildQueryAvatarString struct{}

// Set the optional value of Avatar
func (r guildQueryAvatarString) Set(value string) guildSetParam {

	return guildSetParam{
		data: builder.Field{
			Name:  "avatar",
			Value: value,
		},
	}

}

// Set the optional value of Avatar dynamically
func (r guildQueryAvatarString) SetIfPresent(value *String) guildSetParam {
	if value == nil {
		return guildSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Avatar dynamically
func (r guildQueryAvatarString) SetOptional(value *String) guildSetParam {
	if value == nil {

		var v *string
		return guildSetParam{
			data: builder.Field{
				Name:  "avatar",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r guildQueryAvatarString) Equals(value string) guildWithPrismaAvatarEqualsParam {

	return guildWithPrismaAvatarEqualsParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) EqualsIfPresent(value *string) guildWithPrismaAvatarEqualsParam {
	if value == nil {
		return guildWithPrismaAvatarEqualsParam{}
	}
	return r.Equals(*value)
}

func (r guildQueryAvatarString) EqualsOptional(value *String) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) IsNull() guildDefaultParam {
	var str *string = nil
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) Order(direction SortOrder) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name:  "avatar",
			Value: direction,
		},
	}
}

func (r guildQueryAvatarString) Cursor(cursor string) guildCursorParam {
	return guildCursorParam{
		data: builder.Field{
			Name:  "avatar",
			Value: cursor,
		},
	}
}

func (r guildQueryAvatarString) In(value []string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) InIfPresent(value []string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.In(value)
}

func (r guildQueryAvatarString) NotIn(value []string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) NotInIfPresent(value []string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.NotIn(value)
}

func (r guildQueryAvatarString) Lt(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) LtIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Lt(*value)
}

func (r guildQueryAvatarString) Lte(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) LteIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Lte(*value)
}

func (r guildQueryAvatarString) Gt(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) GtIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Gt(*value)
}

func (r guildQueryAvatarString) Gte(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) GteIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Gte(*value)
}

func (r guildQueryAvatarString) Contains(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) ContainsIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Contains(*value)
}

func (r guildQueryAvatarString) StartsWith(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) StartsWithIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r guildQueryAvatarString) EndsWith(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) EndsWithIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r guildQueryAvatarString) Mode(value QueryMode) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) ModeIfPresent(value *QueryMode) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Mode(*value)
}

func (r guildQueryAvatarString) Not(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryAvatarString) NotIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r guildQueryAvatarString) HasPrefix(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r guildQueryAvatarString) HasPrefixIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r guildQueryAvatarString) HasSuffix(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "avatar",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r guildQueryAvatarString) HasSuffixIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r guildQueryAvatarString) Field() guildPrismaFields {
	return guildFieldAvatar
}

// base struct
type guildQueryCoverImageString struct{}

// Set the optional value of CoverImage
func (r guildQueryCoverImageString) Set(value string) guildSetParam {

	return guildSetParam{
		data: builder.Field{
			Name:  "coverImage",
			Value: value,
		},
	}

}

// Set the optional value of CoverImage dynamically
func (r guildQueryCoverImageString) SetIfPresent(value *String) guildSetParam {
	if value == nil {
		return guildSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of CoverImage dynamically
func (r guildQueryCoverImageString) SetOptional(value *String) guildSetParam {
	if value == nil {

		var v *string
		return guildSetParam{
			data: builder.Field{
				Name:  "coverImage",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r guildQueryCoverImageString) Equals(value string) guildWithPrismaCoverImageEqualsParam {

	return guildWithPrismaCoverImageEqualsParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) EqualsIfPresent(value *string) guildWithPrismaCoverImageEqualsParam {
	if value == nil {
		return guildWithPrismaCoverImageEqualsParam{}
	}
	return r.Equals(*value)
}

func (r guildQueryCoverImageString) EqualsOptional(value *String) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) IsNull() guildDefaultParam {
	var str *string = nil
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) Order(direction SortOrder) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name:  "coverImage",
			Value: direction,
		},
	}
}

func (r guildQueryCoverImageString) Cursor(cursor string) guildCursorParam {
	return guildCursorParam{
		data: builder.Field{
			Name:  "coverImage",
			Value: cursor,
		},
	}
}

func (r guildQueryCoverImageString) In(value []string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) InIfPresent(value []string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.In(value)
}

func (r guildQueryCoverImageString) NotIn(value []string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) NotInIfPresent(value []string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.NotIn(value)
}

func (r guildQueryCoverImageString) Lt(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) LtIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Lt(*value)
}

func (r guildQueryCoverImageString) Lte(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) LteIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Lte(*value)
}

func (r guildQueryCoverImageString) Gt(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) GtIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Gt(*value)
}

func (r guildQueryCoverImageString) Gte(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) GteIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Gte(*value)
}

func (r guildQueryCoverImageString) Contains(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) ContainsIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Contains(*value)
}

func (r guildQueryCoverImageString) StartsWith(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) StartsWithIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r guildQueryCoverImageString) EndsWith(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) EndsWithIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r guildQueryCoverImageString) Mode(value QueryMode) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) ModeIfPresent(value *QueryMode) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Mode(*value)
}

func (r guildQueryCoverImageString) Not(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCoverImageString) NotIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r guildQueryCoverImageString) HasPrefix(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r guildQueryCoverImageString) HasPrefixIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r guildQueryCoverImageString) HasSuffix(value string) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "coverImage",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r guildQueryCoverImageString) HasSuffixIfPresent(value *string) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r guildQueryCoverImageString) Field() guildPrismaFields {
	return guildFieldCoverImage
}

// base struct
type guildQueryIsPrivateBoolean struct{}

// Set the required value of IsPrivate
func (r guildQueryIsPrivateBoolean) Set(value bool) guildSetParam {

	return guildSetParam{
		data: builder.Field{
			Name:  "isPrivate",
			Value: value,
		},
	}

}

// Set the optional value of IsPrivate dynamically
func (r guildQueryIsPrivateBoolean) SetIfPresent(value *Boolean) guildSetParam {
	if value == nil {
		return guildSetParam{}
	}

	return r.Set(*value)
}

func (r guildQueryIsPrivateBoolean) Equals(value bool) guildWithPrismaIsPrivateEqualsParam {

	return guildWithPrismaIsPrivateEqualsParam{
		data: builder.Field{
			Name: "isPrivate",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryIsPrivateBoolean) EqualsIfPresent(value *bool) guildWithPrismaIsPrivateEqualsParam {
	if value == nil {
		return guildWithPrismaIsPrivateEqualsParam{}
	}
	return r.Equals(*value)
}

func (r guildQueryIsPrivateBoolean) Order(direction SortOrder) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name:  "isPrivate",
			Value: direction,
		},
	}
}

func (r guildQueryIsPrivateBoolean) Cursor(cursor bool) guildCursorParam {
	return guildCursorParam{
		data: builder.Field{
			Name:  "isPrivate",
			Value: cursor,
		},
	}
}

func (r guildQueryIsPrivateBoolean) Field() guildPrismaFields {
	return guildFieldIsPrivate
}

// base struct
type guildQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r guildQueryCreatedAtDateTime) Set(value DateTime) guildSetParam {

	return guildSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r guildQueryCreatedAtDateTime) SetIfPresent(value *DateTime) guildSetParam {
	if value == nil {
		return guildSetParam{}
	}

	return r.Set(*value)
}

func (r guildQueryCreatedAtDateTime) Equals(value DateTime) guildWithPrismaCreatedAtEqualsParam {

	return guildWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) guildWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return guildWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r guildQueryCreatedAtDateTime) Order(direction SortOrder) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r guildQueryCreatedAtDateTime) Cursor(cursor DateTime) guildCursorParam {
	return guildCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r guildQueryCreatedAtDateTime) In(value []DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCreatedAtDateTime) InIfPresent(value []DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.In(value)
}

func (r guildQueryCreatedAtDateTime) NotIn(value []DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.NotIn(value)
}

func (r guildQueryCreatedAtDateTime) Lt(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCreatedAtDateTime) LtIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Lt(*value)
}

func (r guildQueryCreatedAtDateTime) Lte(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCreatedAtDateTime) LteIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Lte(*value)
}

func (r guildQueryCreatedAtDateTime) Gt(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCreatedAtDateTime) GtIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Gt(*value)
}

func (r guildQueryCreatedAtDateTime) Gte(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCreatedAtDateTime) GteIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Gte(*value)
}

func (r guildQueryCreatedAtDateTime) Not(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryCreatedAtDateTime) NotIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r guildQueryCreatedAtDateTime) Before(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r guildQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r guildQueryCreatedAtDateTime) After(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r guildQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r guildQueryCreatedAtDateTime) BeforeEquals(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r guildQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r guildQueryCreatedAtDateTime) AfterEquals(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r guildQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r guildQueryCreatedAtDateTime) Field() guildPrismaFields {
	return guildFieldCreatedAt
}

// base struct
type guildQueryUpdatedAtDateTime struct{}

// Set the required value of UpdatedAt
func (r guildQueryUpdatedAtDateTime) Set(value DateTime) guildSetParam {

	return guildSetParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: value,
		},
	}

}

// Set the optional value of UpdatedAt dynamically
func (r guildQueryUpdatedAtDateTime) SetIfPresent(value *DateTime) guildSetParam {
	if value == nil {
		return guildSetParam{}
	}

	return r.Set(*value)
}

func (r guildQueryUpdatedAtDateTime) Equals(value DateTime) guildWithPrismaUpdatedAtEqualsParam {

	return guildWithPrismaUpdatedAtEqualsParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryUpdatedAtDateTime) EqualsIfPresent(value *DateTime) guildWithPrismaUpdatedAtEqualsParam {
	if value == nil {
		return guildWithPrismaUpdatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r guildQueryUpdatedAtDateTime) Order(direction SortOrder) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: direction,
		},
	}
}

func (r guildQueryUpdatedAtDateTime) Cursor(cursor DateTime) guildCursorParam {
	return guildCursorParam{
		data: builder.Field{
			Name:  "updatedAt",
			Value: cursor,
		},
	}
}

func (r guildQueryUpdatedAtDateTime) In(value []DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryUpdatedAtDateTime) InIfPresent(value []DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.In(value)
}

func (r guildQueryUpdatedAtDateTime) NotIn(value []DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryUpdatedAtDateTime) NotInIfPresent(value []DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.NotIn(value)
}

func (r guildQueryUpdatedAtDateTime) Lt(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryUpdatedAtDateTime) LtIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Lt(*value)
}

func (r guildQueryUpdatedAtDateTime) Lte(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryUpdatedAtDateTime) LteIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Lte(*value)
}

func (r guildQueryUpdatedAtDateTime) Gt(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryUpdatedAtDateTime) GtIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Gt(*value)
}

func (r guildQueryUpdatedAtDateTime) Gte(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryUpdatedAtDateTime) GteIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Gte(*value)
}

func (r guildQueryUpdatedAtDateTime) Not(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildQueryUpdatedAtDateTime) NotIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r guildQueryUpdatedAtDateTime) Before(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r guildQueryUpdatedAtDateTime) BeforeIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r guildQueryUpdatedAtDateTime) After(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r guildQueryUpdatedAtDateTime) AfterIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r guildQueryUpdatedAtDateTime) BeforeEquals(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r guildQueryUpdatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r guildQueryUpdatedAtDateTime) AfterEquals(value DateTime) guildDefaultParam {
	return guildDefaultParam{
		data: builder.Field{
			Name: "updatedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r guildQueryUpdatedAtDateTime) AfterEqualsIfPresent(value *DateTime) guildDefaultParam {
	if value == nil {
		return guildDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r guildQueryUpdatedAtDateTime) Field() guildPrismaFields {
	return guildFieldUpdatedAt
}

// base struct
type guildQueryOwnerUser struct{}

type guildQueryOwnerRelations struct{}

// Guild -> Owner
//
// @relation
// @required
func (guildQueryOwnerRelations) Where(
	params ...UserWhereParam,
) guildDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildDefaultParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (guildQueryOwnerRelations) Fetch() guildToOwnerFindUnique {
	var v guildToOwnerFindUnique

	v.query.Operation = "query"
	v.query.Method = "owner"
	v.query.Outputs = userOutput

	return v
}

func (r guildQueryOwnerRelations) Link(
	params UserWhereParam,
) guildWithPrismaOwnerSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return guildWithPrismaOwnerSetParam{}
	}

	fields = append(fields, f)

	return guildWithPrismaOwnerSetParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r guildQueryOwnerRelations) Unlink() guildWithPrismaOwnerSetParam {
	var v guildWithPrismaOwnerSetParam

	v = guildWithPrismaOwnerSetParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r guildQueryOwnerUser) Field() guildPrismaFields {
	return guildFieldOwner
}

// base struct
type guildQueryMembersGuildMember struct{}

type guildQueryMembersRelations struct{}

// Guild -> Members
//
// @relation
// @required
func (guildQueryMembersRelations) Some(
	params ...GuildMemberWhereParam,
) guildDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildDefaultParam{
		data: builder.Field{
			Name: "members",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Guild -> Members
//
// @relation
// @required
func (guildQueryMembersRelations) Every(
	params ...GuildMemberWhereParam,
) guildDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildDefaultParam{
		data: builder.Field{
			Name: "members",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Guild -> Members
//
// @relation
// @required
func (guildQueryMembersRelations) None(
	params ...GuildMemberWhereParam,
) guildDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildDefaultParam{
		data: builder.Field{
			Name: "members",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (guildQueryMembersRelations) Fetch(

	params ...GuildMemberWhereParam,

) guildToMembersFindMany {
	var v guildToMembersFindMany

	v.query.Operation = "query"
	v.query.Method = "members"
	v.query.Outputs = guildMemberOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r guildQueryMembersRelations) Link(
	params ...GuildMemberWhereParam,
) guildSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildSetParam{
		data: builder.Field{
			Name: "members",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r guildQueryMembersRelations) Unlink(
	params ...GuildMemberWhereParam,
) guildSetParam {
	var v guildSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = guildSetParam{
		data: builder.Field{
			Name: "members",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r guildQueryMembersGuildMember) Field() guildPrismaFields {
	return guildFieldMembers
}

// base struct
type guildQueryVideosVideos struct{}

type guildQueryVideosRelations struct{}

// Guild -> Videos
//
// @relation
// @required
func (guildQueryVideosRelations) Some(
	params ...VideosWhereParam,
) guildDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildDefaultParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Guild -> Videos
//
// @relation
// @required
func (guildQueryVideosRelations) Every(
	params ...VideosWhereParam,
) guildDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildDefaultParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Guild -> Videos
//
// @relation
// @required
func (guildQueryVideosRelations) None(
	params ...VideosWhereParam,
) guildDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildDefaultParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (guildQueryVideosRelations) Fetch(

	params ...VideosWhereParam,

) guildToVideosFindMany {
	var v guildToVideosFindMany

	v.query.Operation = "query"
	v.query.Method = "videos"
	v.query.Outputs = videosOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r guildQueryVideosRelations) Link(
	params ...VideosWhereParam,
) guildSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildSetParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r guildQueryVideosRelations) Unlink(
	params ...VideosWhereParam,
) guildSetParam {
	var v guildSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = guildSetParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r guildQueryVideosVideos) Field() guildPrismaFields {
	return guildFieldVideos
}

// base struct
type guildQueryTagsTags struct{}

type guildQueryTagsRelations struct{}

// Guild -> Tags
//
// @relation
// @required
func (guildQueryTagsRelations) Some(
	params ...TagsWhereParam,
) guildDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildDefaultParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Guild -> Tags
//
// @relation
// @required
func (guildQueryTagsRelations) Every(
	params ...TagsWhereParam,
) guildDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildDefaultParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Guild -> Tags
//
// @relation
// @required
func (guildQueryTagsRelations) None(
	params ...TagsWhereParam,
) guildDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildDefaultParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (guildQueryTagsRelations) Fetch(

	params ...TagsWhereParam,

) guildToTagsFindMany {
	var v guildToTagsFindMany

	v.query.Operation = "query"
	v.query.Method = "tags"
	v.query.Outputs = tagsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r guildQueryTagsRelations) Link(
	params ...TagsWhereParam,
) guildSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildSetParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r guildQueryTagsRelations) Unlink(
	params ...TagsWhereParam,
) guildSetParam {
	var v guildSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = guildSetParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r guildQueryTagsTags) Field() guildPrismaFields {
	return guildFieldTags
}

// GuildMember acts as a namespaces to access query methods for the GuildMember model
var GuildMember = guildMemberQuery{}

// guildMemberQuery exposes query functions for the guildMember model
type guildMemberQuery struct {

	// ID
	//
	// @required
	ID guildMemberQueryIDString

	// UserID
	//
	// @required
	UserID guildMemberQueryUserIDString

	// GuildID
	//
	// @required
	GuildID guildMemberQueryGuildIDString

	// Role
	//
	// @required
	Role guildMemberQueryRoleROLE

	// JoinedAt
	//
	// @required
	JoinedAt guildMemberQueryJoinedAtDateTime

	// Status
	//
	// @required
	Status guildMemberQueryStatusSTATUS

	User guildMemberQueryUserRelations

	Guild guildMemberQueryGuildRelations
}

func (guildMemberQuery) Not(params ...GuildMemberWhereParam) guildMemberDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildMemberDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (guildMemberQuery) Or(params ...GuildMemberWhereParam) guildMemberDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildMemberDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (guildMemberQuery) And(params ...GuildMemberWhereParam) guildMemberDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildMemberDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (guildMemberQuery) UserIDGuildID(
	_userID GuildMemberWithPrismaUserIDWhereParam,

	_guildID GuildMemberWithPrismaGuildIDWhereParam,
) GuildMemberEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _userID.field())
	fields = append(fields, _guildID.field())

	return guildMemberEqualsUniqueParam{
		data: builder.Field{
			Name:   "userId_guildId",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type guildMemberQueryIDString struct{}

// Set the required value of ID
func (r guildMemberQueryIDString) Set(value string) guildMemberSetParam {

	return guildMemberSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r guildMemberQueryIDString) SetIfPresent(value *String) guildMemberSetParam {
	if value == nil {
		return guildMemberSetParam{}
	}

	return r.Set(*value)
}

func (r guildMemberQueryIDString) Equals(value string) guildMemberWithPrismaIDEqualsUniqueParam {

	return guildMemberWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryIDString) EqualsIfPresent(value *string) guildMemberWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return guildMemberWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r guildMemberQueryIDString) Order(direction SortOrder) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r guildMemberQueryIDString) Cursor(cursor string) guildMemberCursorParam {
	return guildMemberCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r guildMemberQueryIDString) In(value []string) guildMemberParamUnique {
	return guildMemberParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryIDString) InIfPresent(value []string) guildMemberParamUnique {
	if value == nil {
		return guildMemberParamUnique{}
	}
	return r.In(value)
}

func (r guildMemberQueryIDString) NotIn(value []string) guildMemberParamUnique {
	return guildMemberParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryIDString) NotInIfPresent(value []string) guildMemberParamUnique {
	if value == nil {
		return guildMemberParamUnique{}
	}
	return r.NotIn(value)
}

func (r guildMemberQueryIDString) Lt(value string) guildMemberParamUnique {
	return guildMemberParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryIDString) LtIfPresent(value *string) guildMemberParamUnique {
	if value == nil {
		return guildMemberParamUnique{}
	}
	return r.Lt(*value)
}

func (r guildMemberQueryIDString) Lte(value string) guildMemberParamUnique {
	return guildMemberParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryIDString) LteIfPresent(value *string) guildMemberParamUnique {
	if value == nil {
		return guildMemberParamUnique{}
	}
	return r.Lte(*value)
}

func (r guildMemberQueryIDString) Gt(value string) guildMemberParamUnique {
	return guildMemberParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryIDString) GtIfPresent(value *string) guildMemberParamUnique {
	if value == nil {
		return guildMemberParamUnique{}
	}
	return r.Gt(*value)
}

func (r guildMemberQueryIDString) Gte(value string) guildMemberParamUnique {
	return guildMemberParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryIDString) GteIfPresent(value *string) guildMemberParamUnique {
	if value == nil {
		return guildMemberParamUnique{}
	}
	return r.Gte(*value)
}

func (r guildMemberQueryIDString) Contains(value string) guildMemberParamUnique {
	return guildMemberParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryIDString) ContainsIfPresent(value *string) guildMemberParamUnique {
	if value == nil {
		return guildMemberParamUnique{}
	}
	return r.Contains(*value)
}

func (r guildMemberQueryIDString) StartsWith(value string) guildMemberParamUnique {
	return guildMemberParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryIDString) StartsWithIfPresent(value *string) guildMemberParamUnique {
	if value == nil {
		return guildMemberParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r guildMemberQueryIDString) EndsWith(value string) guildMemberParamUnique {
	return guildMemberParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryIDString) EndsWithIfPresent(value *string) guildMemberParamUnique {
	if value == nil {
		return guildMemberParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r guildMemberQueryIDString) Mode(value QueryMode) guildMemberParamUnique {
	return guildMemberParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryIDString) ModeIfPresent(value *QueryMode) guildMemberParamUnique {
	if value == nil {
		return guildMemberParamUnique{}
	}
	return r.Mode(*value)
}

func (r guildMemberQueryIDString) Not(value string) guildMemberParamUnique {
	return guildMemberParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryIDString) NotIfPresent(value *string) guildMemberParamUnique {
	if value == nil {
		return guildMemberParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r guildMemberQueryIDString) HasPrefix(value string) guildMemberParamUnique {
	return guildMemberParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r guildMemberQueryIDString) HasPrefixIfPresent(value *string) guildMemberParamUnique {
	if value == nil {
		return guildMemberParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r guildMemberQueryIDString) HasSuffix(value string) guildMemberParamUnique {
	return guildMemberParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r guildMemberQueryIDString) HasSuffixIfPresent(value *string) guildMemberParamUnique {
	if value == nil {
		return guildMemberParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r guildMemberQueryIDString) Field() guildMemberPrismaFields {
	return guildMemberFieldID
}

// base struct
type guildMemberQueryUserIDString struct{}

// Set the required value of UserID
func (r guildMemberQueryUserIDString) Set(value string) guildMemberSetParam {

	return guildMemberSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r guildMemberQueryUserIDString) SetIfPresent(value *String) guildMemberSetParam {
	if value == nil {
		return guildMemberSetParam{}
	}

	return r.Set(*value)
}

func (r guildMemberQueryUserIDString) Equals(value string) guildMemberWithPrismaUserIDEqualsParam {

	return guildMemberWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryUserIDString) EqualsIfPresent(value *string) guildMemberWithPrismaUserIDEqualsParam {
	if value == nil {
		return guildMemberWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r guildMemberQueryUserIDString) Order(direction SortOrder) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r guildMemberQueryUserIDString) Cursor(cursor string) guildMemberCursorParam {
	return guildMemberCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r guildMemberQueryUserIDString) In(value []string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryUserIDString) InIfPresent(value []string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.In(value)
}

func (r guildMemberQueryUserIDString) NotIn(value []string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryUserIDString) NotInIfPresent(value []string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.NotIn(value)
}

func (r guildMemberQueryUserIDString) Lt(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryUserIDString) LtIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Lt(*value)
}

func (r guildMemberQueryUserIDString) Lte(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryUserIDString) LteIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Lte(*value)
}

func (r guildMemberQueryUserIDString) Gt(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryUserIDString) GtIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Gt(*value)
}

func (r guildMemberQueryUserIDString) Gte(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryUserIDString) GteIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Gte(*value)
}

func (r guildMemberQueryUserIDString) Contains(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryUserIDString) ContainsIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Contains(*value)
}

func (r guildMemberQueryUserIDString) StartsWith(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryUserIDString) StartsWithIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r guildMemberQueryUserIDString) EndsWith(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryUserIDString) EndsWithIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r guildMemberQueryUserIDString) Mode(value QueryMode) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryUserIDString) ModeIfPresent(value *QueryMode) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Mode(*value)
}

func (r guildMemberQueryUserIDString) Not(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryUserIDString) NotIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r guildMemberQueryUserIDString) HasPrefix(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r guildMemberQueryUserIDString) HasPrefixIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r guildMemberQueryUserIDString) HasSuffix(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r guildMemberQueryUserIDString) HasSuffixIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r guildMemberQueryUserIDString) Field() guildMemberPrismaFields {
	return guildMemberFieldUserID
}

// base struct
type guildMemberQueryGuildIDString struct{}

// Set the required value of GuildID
func (r guildMemberQueryGuildIDString) Set(value string) guildMemberSetParam {

	return guildMemberSetParam{
		data: builder.Field{
			Name:  "guildId",
			Value: value,
		},
	}

}

// Set the optional value of GuildID dynamically
func (r guildMemberQueryGuildIDString) SetIfPresent(value *String) guildMemberSetParam {
	if value == nil {
		return guildMemberSetParam{}
	}

	return r.Set(*value)
}

func (r guildMemberQueryGuildIDString) Equals(value string) guildMemberWithPrismaGuildIDEqualsParam {

	return guildMemberWithPrismaGuildIDEqualsParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryGuildIDString) EqualsIfPresent(value *string) guildMemberWithPrismaGuildIDEqualsParam {
	if value == nil {
		return guildMemberWithPrismaGuildIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r guildMemberQueryGuildIDString) Order(direction SortOrder) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name:  "guildId",
			Value: direction,
		},
	}
}

func (r guildMemberQueryGuildIDString) Cursor(cursor string) guildMemberCursorParam {
	return guildMemberCursorParam{
		data: builder.Field{
			Name:  "guildId",
			Value: cursor,
		},
	}
}

func (r guildMemberQueryGuildIDString) In(value []string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryGuildIDString) InIfPresent(value []string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.In(value)
}

func (r guildMemberQueryGuildIDString) NotIn(value []string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryGuildIDString) NotInIfPresent(value []string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.NotIn(value)
}

func (r guildMemberQueryGuildIDString) Lt(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryGuildIDString) LtIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Lt(*value)
}

func (r guildMemberQueryGuildIDString) Lte(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryGuildIDString) LteIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Lte(*value)
}

func (r guildMemberQueryGuildIDString) Gt(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryGuildIDString) GtIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Gt(*value)
}

func (r guildMemberQueryGuildIDString) Gte(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryGuildIDString) GteIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Gte(*value)
}

func (r guildMemberQueryGuildIDString) Contains(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryGuildIDString) ContainsIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Contains(*value)
}

func (r guildMemberQueryGuildIDString) StartsWith(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryGuildIDString) StartsWithIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r guildMemberQueryGuildIDString) EndsWith(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryGuildIDString) EndsWithIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r guildMemberQueryGuildIDString) Mode(value QueryMode) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryGuildIDString) ModeIfPresent(value *QueryMode) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Mode(*value)
}

func (r guildMemberQueryGuildIDString) Not(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryGuildIDString) NotIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r guildMemberQueryGuildIDString) HasPrefix(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r guildMemberQueryGuildIDString) HasPrefixIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r guildMemberQueryGuildIDString) HasSuffix(value string) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r guildMemberQueryGuildIDString) HasSuffixIfPresent(value *string) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r guildMemberQueryGuildIDString) Field() guildMemberPrismaFields {
	return guildMemberFieldGuildID
}

// base struct
type guildMemberQueryRoleROLE struct{}

// Set the required value of Role
func (r guildMemberQueryRoleROLE) Set(value Role) guildMemberSetParam {

	return guildMemberSetParam{
		data: builder.Field{
			Name:  "role",
			Value: value,
		},
	}

}

// Set the optional value of Role dynamically
func (r guildMemberQueryRoleROLE) SetIfPresent(value *Role) guildMemberSetParam {
	if value == nil {
		return guildMemberSetParam{}
	}

	return r.Set(*value)
}

func (r guildMemberQueryRoleROLE) Equals(value Role) guildMemberWithPrismaRoleEqualsParam {

	return guildMemberWithPrismaRoleEqualsParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryRoleROLE) EqualsIfPresent(value *Role) guildMemberWithPrismaRoleEqualsParam {
	if value == nil {
		return guildMemberWithPrismaRoleEqualsParam{}
	}
	return r.Equals(*value)
}

func (r guildMemberQueryRoleROLE) Order(direction SortOrder) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name:  "role",
			Value: direction,
		},
	}
}

func (r guildMemberQueryRoleROLE) Cursor(cursor Role) guildMemberCursorParam {
	return guildMemberCursorParam{
		data: builder.Field{
			Name:  "role",
			Value: cursor,
		},
	}
}

func (r guildMemberQueryRoleROLE) In(value []Role) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryRoleROLE) InIfPresent(value []Role) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.In(value)
}

func (r guildMemberQueryRoleROLE) NotIn(value []Role) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryRoleROLE) NotInIfPresent(value []Role) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.NotIn(value)
}

func (r guildMemberQueryRoleROLE) Not(value Role) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryRoleROLE) NotIfPresent(value *Role) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Not(*value)
}

func (r guildMemberQueryRoleROLE) Field() guildMemberPrismaFields {
	return guildMemberFieldRole
}

// base struct
type guildMemberQueryJoinedAtDateTime struct{}

// Set the required value of JoinedAt
func (r guildMemberQueryJoinedAtDateTime) Set(value DateTime) guildMemberSetParam {

	return guildMemberSetParam{
		data: builder.Field{
			Name:  "joinedAt",
			Value: value,
		},
	}

}

// Set the optional value of JoinedAt dynamically
func (r guildMemberQueryJoinedAtDateTime) SetIfPresent(value *DateTime) guildMemberSetParam {
	if value == nil {
		return guildMemberSetParam{}
	}

	return r.Set(*value)
}

func (r guildMemberQueryJoinedAtDateTime) Equals(value DateTime) guildMemberWithPrismaJoinedAtEqualsParam {

	return guildMemberWithPrismaJoinedAtEqualsParam{
		data: builder.Field{
			Name: "joinedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryJoinedAtDateTime) EqualsIfPresent(value *DateTime) guildMemberWithPrismaJoinedAtEqualsParam {
	if value == nil {
		return guildMemberWithPrismaJoinedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r guildMemberQueryJoinedAtDateTime) Order(direction SortOrder) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name:  "joinedAt",
			Value: direction,
		},
	}
}

func (r guildMemberQueryJoinedAtDateTime) Cursor(cursor DateTime) guildMemberCursorParam {
	return guildMemberCursorParam{
		data: builder.Field{
			Name:  "joinedAt",
			Value: cursor,
		},
	}
}

func (r guildMemberQueryJoinedAtDateTime) In(value []DateTime) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "joinedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryJoinedAtDateTime) InIfPresent(value []DateTime) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.In(value)
}

func (r guildMemberQueryJoinedAtDateTime) NotIn(value []DateTime) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "joinedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryJoinedAtDateTime) NotInIfPresent(value []DateTime) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.NotIn(value)
}

func (r guildMemberQueryJoinedAtDateTime) Lt(value DateTime) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "joinedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryJoinedAtDateTime) LtIfPresent(value *DateTime) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Lt(*value)
}

func (r guildMemberQueryJoinedAtDateTime) Lte(value DateTime) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "joinedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryJoinedAtDateTime) LteIfPresent(value *DateTime) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Lte(*value)
}

func (r guildMemberQueryJoinedAtDateTime) Gt(value DateTime) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "joinedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryJoinedAtDateTime) GtIfPresent(value *DateTime) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Gt(*value)
}

func (r guildMemberQueryJoinedAtDateTime) Gte(value DateTime) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "joinedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryJoinedAtDateTime) GteIfPresent(value *DateTime) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Gte(*value)
}

func (r guildMemberQueryJoinedAtDateTime) Not(value DateTime) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "joinedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryJoinedAtDateTime) NotIfPresent(value *DateTime) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r guildMemberQueryJoinedAtDateTime) Before(value DateTime) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "joinedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r guildMemberQueryJoinedAtDateTime) BeforeIfPresent(value *DateTime) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r guildMemberQueryJoinedAtDateTime) After(value DateTime) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "joinedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r guildMemberQueryJoinedAtDateTime) AfterIfPresent(value *DateTime) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r guildMemberQueryJoinedAtDateTime) BeforeEquals(value DateTime) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "joinedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r guildMemberQueryJoinedAtDateTime) BeforeEqualsIfPresent(value *DateTime) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r guildMemberQueryJoinedAtDateTime) AfterEquals(value DateTime) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "joinedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r guildMemberQueryJoinedAtDateTime) AfterEqualsIfPresent(value *DateTime) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r guildMemberQueryJoinedAtDateTime) Field() guildMemberPrismaFields {
	return guildMemberFieldJoinedAt
}

// base struct
type guildMemberQueryStatusSTATUS struct{}

// Set the required value of Status
func (r guildMemberQueryStatusSTATUS) Set(value Status) guildMemberSetParam {

	return guildMemberSetParam{
		data: builder.Field{
			Name:  "status",
			Value: value,
		},
	}

}

// Set the optional value of Status dynamically
func (r guildMemberQueryStatusSTATUS) SetIfPresent(value *Status) guildMemberSetParam {
	if value == nil {
		return guildMemberSetParam{}
	}

	return r.Set(*value)
}

func (r guildMemberQueryStatusSTATUS) Equals(value Status) guildMemberWithPrismaStatusEqualsParam {

	return guildMemberWithPrismaStatusEqualsParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryStatusSTATUS) EqualsIfPresent(value *Status) guildMemberWithPrismaStatusEqualsParam {
	if value == nil {
		return guildMemberWithPrismaStatusEqualsParam{}
	}
	return r.Equals(*value)
}

func (r guildMemberQueryStatusSTATUS) Order(direction SortOrder) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name:  "status",
			Value: direction,
		},
	}
}

func (r guildMemberQueryStatusSTATUS) Cursor(cursor Status) guildMemberCursorParam {
	return guildMemberCursorParam{
		data: builder.Field{
			Name:  "status",
			Value: cursor,
		},
	}
}

func (r guildMemberQueryStatusSTATUS) In(value []Status) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryStatusSTATUS) InIfPresent(value []Status) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.In(value)
}

func (r guildMemberQueryStatusSTATUS) NotIn(value []Status) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryStatusSTATUS) NotInIfPresent(value []Status) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.NotIn(value)
}

func (r guildMemberQueryStatusSTATUS) Not(value Status) guildMemberDefaultParam {
	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "status",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r guildMemberQueryStatusSTATUS) NotIfPresent(value *Status) guildMemberDefaultParam {
	if value == nil {
		return guildMemberDefaultParam{}
	}
	return r.Not(*value)
}

func (r guildMemberQueryStatusSTATUS) Field() guildMemberPrismaFields {
	return guildMemberFieldStatus
}

// base struct
type guildMemberQueryUserUser struct{}

type guildMemberQueryUserRelations struct{}

// GuildMember -> User
//
// @relation
// @required
func (guildMemberQueryUserRelations) Where(
	params ...UserWhereParam,
) guildMemberDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (guildMemberQueryUserRelations) Fetch() guildMemberToUserFindUnique {
	var v guildMemberToUserFindUnique

	v.query.Operation = "query"
	v.query.Method = "user"
	v.query.Outputs = userOutput

	return v
}

func (r guildMemberQueryUserRelations) Link(
	params UserWhereParam,
) guildMemberWithPrismaUserSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return guildMemberWithPrismaUserSetParam{}
	}

	fields = append(fields, f)

	return guildMemberWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r guildMemberQueryUserRelations) Unlink() guildMemberWithPrismaUserSetParam {
	var v guildMemberWithPrismaUserSetParam

	v = guildMemberWithPrismaUserSetParam{
		data: builder.Field{
			Name: "user",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r guildMemberQueryUserUser) Field() guildMemberPrismaFields {
	return guildMemberFieldUser
}

// base struct
type guildMemberQueryGuildGuild struct{}

type guildMemberQueryGuildRelations struct{}

// GuildMember -> Guild
//
// @relation
// @required
func (guildMemberQueryGuildRelations) Where(
	params ...GuildWhereParam,
) guildMemberDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return guildMemberDefaultParam{
		data: builder.Field{
			Name: "guild",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (guildMemberQueryGuildRelations) Fetch() guildMemberToGuildFindUnique {
	var v guildMemberToGuildFindUnique

	v.query.Operation = "query"
	v.query.Method = "guild"
	v.query.Outputs = guildOutput

	return v
}

func (r guildMemberQueryGuildRelations) Link(
	params GuildWhereParam,
) guildMemberWithPrismaGuildSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return guildMemberWithPrismaGuildSetParam{}
	}

	fields = append(fields, f)

	return guildMemberWithPrismaGuildSetParam{
		data: builder.Field{
			Name: "guild",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r guildMemberQueryGuildRelations) Unlink() guildMemberWithPrismaGuildSetParam {
	var v guildMemberWithPrismaGuildSetParam

	v = guildMemberWithPrismaGuildSetParam{
		data: builder.Field{
			Name: "guild",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r guildMemberQueryGuildGuild) Field() guildMemberPrismaFields {
	return guildMemberFieldGuild
}

// Videos acts as a namespaces to access query methods for the Videos model
var Videos = videosQuery{}

// videosQuery exposes query functions for the videos model
type videosQuery struct {

	// ID
	//
	// @required
	ID videosQueryIDString

	// Title
	//
	// @required
	Title videosQueryTitleString

	// Description
	//
	// @required
	Description videosQueryDescriptionString

	// Thumbnail
	//
	// @required
	Thumbnail videosQueryThumbnailString

	// VideoURL
	//
	// @required
	VideoURL videosQueryVideoURLString

	// Duration
	//
	// @required
	Duration videosQueryDurationInt

	// OwnerID
	//
	// @required
	OwnerID videosQueryOwnerIDString

	// GuildID
	//
	// @required
	GuildID videosQueryGuildIDString

	// CreatedAt
	//
	// @required
	CreatedAt videosQueryCreatedAtDateTime

	Owner videosQueryOwnerRelations

	Guild videosQueryGuildRelations

	Tags videosQueryTagsRelations

	// IsPrivate
	//
	// @required
	IsPrivate videosQueryIsPrivateBoolean

	Likes videosQueryLikesRelations

	// Views
	//
	// @required
	Views videosQueryViewsInt

	History videosQueryHistoryRelations

	WatchLater videosQueryWatchLaterRelations
}

func (videosQuery) Not(params ...VideosWhereParam) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (videosQuery) Or(params ...VideosWhereParam) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (videosQuery) And(params ...VideosWhereParam) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type videosQueryIDString struct{}

// Set the required value of ID
func (r videosQueryIDString) Set(value string) videosSetParam {

	return videosSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r videosQueryIDString) SetIfPresent(value *String) videosSetParam {
	if value == nil {
		return videosSetParam{}
	}

	return r.Set(*value)
}

func (r videosQueryIDString) Equals(value string) videosWithPrismaIDEqualsUniqueParam {

	return videosWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryIDString) EqualsIfPresent(value *string) videosWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return videosWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r videosQueryIDString) Order(direction SortOrder) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r videosQueryIDString) Cursor(cursor string) videosCursorParam {
	return videosCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r videosQueryIDString) In(value []string) videosParamUnique {
	return videosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryIDString) InIfPresent(value []string) videosParamUnique {
	if value == nil {
		return videosParamUnique{}
	}
	return r.In(value)
}

func (r videosQueryIDString) NotIn(value []string) videosParamUnique {
	return videosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryIDString) NotInIfPresent(value []string) videosParamUnique {
	if value == nil {
		return videosParamUnique{}
	}
	return r.NotIn(value)
}

func (r videosQueryIDString) Lt(value string) videosParamUnique {
	return videosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryIDString) LtIfPresent(value *string) videosParamUnique {
	if value == nil {
		return videosParamUnique{}
	}
	return r.Lt(*value)
}

func (r videosQueryIDString) Lte(value string) videosParamUnique {
	return videosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryIDString) LteIfPresent(value *string) videosParamUnique {
	if value == nil {
		return videosParamUnique{}
	}
	return r.Lte(*value)
}

func (r videosQueryIDString) Gt(value string) videosParamUnique {
	return videosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryIDString) GtIfPresent(value *string) videosParamUnique {
	if value == nil {
		return videosParamUnique{}
	}
	return r.Gt(*value)
}

func (r videosQueryIDString) Gte(value string) videosParamUnique {
	return videosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryIDString) GteIfPresent(value *string) videosParamUnique {
	if value == nil {
		return videosParamUnique{}
	}
	return r.Gte(*value)
}

func (r videosQueryIDString) Contains(value string) videosParamUnique {
	return videosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryIDString) ContainsIfPresent(value *string) videosParamUnique {
	if value == nil {
		return videosParamUnique{}
	}
	return r.Contains(*value)
}

func (r videosQueryIDString) StartsWith(value string) videosParamUnique {
	return videosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryIDString) StartsWithIfPresent(value *string) videosParamUnique {
	if value == nil {
		return videosParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r videosQueryIDString) EndsWith(value string) videosParamUnique {
	return videosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryIDString) EndsWithIfPresent(value *string) videosParamUnique {
	if value == nil {
		return videosParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r videosQueryIDString) Mode(value QueryMode) videosParamUnique {
	return videosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryIDString) ModeIfPresent(value *QueryMode) videosParamUnique {
	if value == nil {
		return videosParamUnique{}
	}
	return r.Mode(*value)
}

func (r videosQueryIDString) Not(value string) videosParamUnique {
	return videosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryIDString) NotIfPresent(value *string) videosParamUnique {
	if value == nil {
		return videosParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r videosQueryIDString) HasPrefix(value string) videosParamUnique {
	return videosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r videosQueryIDString) HasPrefixIfPresent(value *string) videosParamUnique {
	if value == nil {
		return videosParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r videosQueryIDString) HasSuffix(value string) videosParamUnique {
	return videosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r videosQueryIDString) HasSuffixIfPresent(value *string) videosParamUnique {
	if value == nil {
		return videosParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r videosQueryIDString) Field() videosPrismaFields {
	return videosFieldID
}

// base struct
type videosQueryTitleString struct{}

// Set the required value of Title
func (r videosQueryTitleString) Set(value string) videosWithPrismaTitleSetParam {

	return videosWithPrismaTitleSetParam{
		data: builder.Field{
			Name:  "title",
			Value: value,
		},
	}

}

// Set the optional value of Title dynamically
func (r videosQueryTitleString) SetIfPresent(value *String) videosWithPrismaTitleSetParam {
	if value == nil {
		return videosWithPrismaTitleSetParam{}
	}

	return r.Set(*value)
}

func (r videosQueryTitleString) Equals(value string) videosWithPrismaTitleEqualsParam {

	return videosWithPrismaTitleEqualsParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryTitleString) EqualsIfPresent(value *string) videosWithPrismaTitleEqualsParam {
	if value == nil {
		return videosWithPrismaTitleEqualsParam{}
	}
	return r.Equals(*value)
}

func (r videosQueryTitleString) Order(direction SortOrder) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name:  "title",
			Value: direction,
		},
	}
}

func (r videosQueryTitleString) Cursor(cursor string) videosCursorParam {
	return videosCursorParam{
		data: builder.Field{
			Name:  "title",
			Value: cursor,
		},
	}
}

func (r videosQueryTitleString) In(value []string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryTitleString) InIfPresent(value []string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.In(value)
}

func (r videosQueryTitleString) NotIn(value []string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryTitleString) NotInIfPresent(value []string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.NotIn(value)
}

func (r videosQueryTitleString) Lt(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryTitleString) LtIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lt(*value)
}

func (r videosQueryTitleString) Lte(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryTitleString) LteIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lte(*value)
}

func (r videosQueryTitleString) Gt(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryTitleString) GtIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gt(*value)
}

func (r videosQueryTitleString) Gte(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryTitleString) GteIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gte(*value)
}

func (r videosQueryTitleString) Contains(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryTitleString) ContainsIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Contains(*value)
}

func (r videosQueryTitleString) StartsWith(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryTitleString) StartsWithIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r videosQueryTitleString) EndsWith(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryTitleString) EndsWithIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r videosQueryTitleString) Mode(value QueryMode) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryTitleString) ModeIfPresent(value *QueryMode) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Mode(*value)
}

func (r videosQueryTitleString) Not(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryTitleString) NotIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r videosQueryTitleString) HasPrefix(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r videosQueryTitleString) HasPrefixIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r videosQueryTitleString) HasSuffix(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "title",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r videosQueryTitleString) HasSuffixIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r videosQueryTitleString) Field() videosPrismaFields {
	return videosFieldTitle
}

// base struct
type videosQueryDescriptionString struct{}

// Set the required value of Description
func (r videosQueryDescriptionString) Set(value string) videosWithPrismaDescriptionSetParam {

	return videosWithPrismaDescriptionSetParam{
		data: builder.Field{
			Name:  "description",
			Value: value,
		},
	}

}

// Set the optional value of Description dynamically
func (r videosQueryDescriptionString) SetIfPresent(value *String) videosWithPrismaDescriptionSetParam {
	if value == nil {
		return videosWithPrismaDescriptionSetParam{}
	}

	return r.Set(*value)
}

func (r videosQueryDescriptionString) Equals(value string) videosWithPrismaDescriptionEqualsParam {

	return videosWithPrismaDescriptionEqualsParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDescriptionString) EqualsIfPresent(value *string) videosWithPrismaDescriptionEqualsParam {
	if value == nil {
		return videosWithPrismaDescriptionEqualsParam{}
	}
	return r.Equals(*value)
}

func (r videosQueryDescriptionString) Order(direction SortOrder) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name:  "description",
			Value: direction,
		},
	}
}

func (r videosQueryDescriptionString) Cursor(cursor string) videosCursorParam {
	return videosCursorParam{
		data: builder.Field{
			Name:  "description",
			Value: cursor,
		},
	}
}

func (r videosQueryDescriptionString) In(value []string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDescriptionString) InIfPresent(value []string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.In(value)
}

func (r videosQueryDescriptionString) NotIn(value []string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDescriptionString) NotInIfPresent(value []string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.NotIn(value)
}

func (r videosQueryDescriptionString) Lt(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDescriptionString) LtIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lt(*value)
}

func (r videosQueryDescriptionString) Lte(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDescriptionString) LteIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lte(*value)
}

func (r videosQueryDescriptionString) Gt(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDescriptionString) GtIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gt(*value)
}

func (r videosQueryDescriptionString) Gte(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDescriptionString) GteIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gte(*value)
}

func (r videosQueryDescriptionString) Contains(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDescriptionString) ContainsIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Contains(*value)
}

func (r videosQueryDescriptionString) StartsWith(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDescriptionString) StartsWithIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r videosQueryDescriptionString) EndsWith(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDescriptionString) EndsWithIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r videosQueryDescriptionString) Mode(value QueryMode) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDescriptionString) ModeIfPresent(value *QueryMode) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Mode(*value)
}

func (r videosQueryDescriptionString) Not(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDescriptionString) NotIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r videosQueryDescriptionString) HasPrefix(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r videosQueryDescriptionString) HasPrefixIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r videosQueryDescriptionString) HasSuffix(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "description",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r videosQueryDescriptionString) HasSuffixIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r videosQueryDescriptionString) Field() videosPrismaFields {
	return videosFieldDescription
}

// base struct
type videosQueryThumbnailString struct{}

// Set the required value of Thumbnail
func (r videosQueryThumbnailString) Set(value string) videosWithPrismaThumbnailSetParam {

	return videosWithPrismaThumbnailSetParam{
		data: builder.Field{
			Name:  "thumbnail",
			Value: value,
		},
	}

}

// Set the optional value of Thumbnail dynamically
func (r videosQueryThumbnailString) SetIfPresent(value *String) videosWithPrismaThumbnailSetParam {
	if value == nil {
		return videosWithPrismaThumbnailSetParam{}
	}

	return r.Set(*value)
}

func (r videosQueryThumbnailString) Equals(value string) videosWithPrismaThumbnailEqualsParam {

	return videosWithPrismaThumbnailEqualsParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryThumbnailString) EqualsIfPresent(value *string) videosWithPrismaThumbnailEqualsParam {
	if value == nil {
		return videosWithPrismaThumbnailEqualsParam{}
	}
	return r.Equals(*value)
}

func (r videosQueryThumbnailString) Order(direction SortOrder) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name:  "thumbnail",
			Value: direction,
		},
	}
}

func (r videosQueryThumbnailString) Cursor(cursor string) videosCursorParam {
	return videosCursorParam{
		data: builder.Field{
			Name:  "thumbnail",
			Value: cursor,
		},
	}
}

func (r videosQueryThumbnailString) In(value []string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryThumbnailString) InIfPresent(value []string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.In(value)
}

func (r videosQueryThumbnailString) NotIn(value []string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryThumbnailString) NotInIfPresent(value []string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.NotIn(value)
}

func (r videosQueryThumbnailString) Lt(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryThumbnailString) LtIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lt(*value)
}

func (r videosQueryThumbnailString) Lte(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryThumbnailString) LteIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lte(*value)
}

func (r videosQueryThumbnailString) Gt(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryThumbnailString) GtIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gt(*value)
}

func (r videosQueryThumbnailString) Gte(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryThumbnailString) GteIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gte(*value)
}

func (r videosQueryThumbnailString) Contains(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryThumbnailString) ContainsIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Contains(*value)
}

func (r videosQueryThumbnailString) StartsWith(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryThumbnailString) StartsWithIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r videosQueryThumbnailString) EndsWith(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryThumbnailString) EndsWithIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r videosQueryThumbnailString) Mode(value QueryMode) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryThumbnailString) ModeIfPresent(value *QueryMode) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Mode(*value)
}

func (r videosQueryThumbnailString) Not(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryThumbnailString) NotIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r videosQueryThumbnailString) HasPrefix(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r videosQueryThumbnailString) HasPrefixIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r videosQueryThumbnailString) HasSuffix(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "thumbnail",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r videosQueryThumbnailString) HasSuffixIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r videosQueryThumbnailString) Field() videosPrismaFields {
	return videosFieldThumbnail
}

// base struct
type videosQueryVideoURLString struct{}

// Set the required value of VideoURL
func (r videosQueryVideoURLString) Set(value string) videosWithPrismaVideoURLSetParam {

	return videosWithPrismaVideoURLSetParam{
		data: builder.Field{
			Name:  "videoUrl",
			Value: value,
		},
	}

}

// Set the optional value of VideoURL dynamically
func (r videosQueryVideoURLString) SetIfPresent(value *String) videosWithPrismaVideoURLSetParam {
	if value == nil {
		return videosWithPrismaVideoURLSetParam{}
	}

	return r.Set(*value)
}

func (r videosQueryVideoURLString) Equals(value string) videosWithPrismaVideoURLEqualsParam {

	return videosWithPrismaVideoURLEqualsParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryVideoURLString) EqualsIfPresent(value *string) videosWithPrismaVideoURLEqualsParam {
	if value == nil {
		return videosWithPrismaVideoURLEqualsParam{}
	}
	return r.Equals(*value)
}

func (r videosQueryVideoURLString) Order(direction SortOrder) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name:  "videoUrl",
			Value: direction,
		},
	}
}

func (r videosQueryVideoURLString) Cursor(cursor string) videosCursorParam {
	return videosCursorParam{
		data: builder.Field{
			Name:  "videoUrl",
			Value: cursor,
		},
	}
}

func (r videosQueryVideoURLString) In(value []string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryVideoURLString) InIfPresent(value []string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.In(value)
}

func (r videosQueryVideoURLString) NotIn(value []string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryVideoURLString) NotInIfPresent(value []string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.NotIn(value)
}

func (r videosQueryVideoURLString) Lt(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryVideoURLString) LtIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lt(*value)
}

func (r videosQueryVideoURLString) Lte(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryVideoURLString) LteIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lte(*value)
}

func (r videosQueryVideoURLString) Gt(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryVideoURLString) GtIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gt(*value)
}

func (r videosQueryVideoURLString) Gte(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryVideoURLString) GteIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gte(*value)
}

func (r videosQueryVideoURLString) Contains(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryVideoURLString) ContainsIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Contains(*value)
}

func (r videosQueryVideoURLString) StartsWith(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryVideoURLString) StartsWithIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r videosQueryVideoURLString) EndsWith(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryVideoURLString) EndsWithIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r videosQueryVideoURLString) Mode(value QueryMode) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryVideoURLString) ModeIfPresent(value *QueryMode) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Mode(*value)
}

func (r videosQueryVideoURLString) Not(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryVideoURLString) NotIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r videosQueryVideoURLString) HasPrefix(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r videosQueryVideoURLString) HasPrefixIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r videosQueryVideoURLString) HasSuffix(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "videoUrl",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r videosQueryVideoURLString) HasSuffixIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r videosQueryVideoURLString) Field() videosPrismaFields {
	return videosFieldVideoURL
}

// base struct
type videosQueryDurationInt struct{}

// Set the required value of Duration
func (r videosQueryDurationInt) Set(value int) videosWithPrismaDurationSetParam {

	return videosWithPrismaDurationSetParam{
		data: builder.Field{
			Name:  "duration",
			Value: value,
		},
	}

}

// Set the optional value of Duration dynamically
func (r videosQueryDurationInt) SetIfPresent(value *Int) videosWithPrismaDurationSetParam {
	if value == nil {
		return videosWithPrismaDurationSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Duration
func (r videosQueryDurationInt) Increment(value int) videosWithPrismaDurationSetParam {
	return videosWithPrismaDurationSetParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDurationInt) IncrementIfPresent(value *int) videosWithPrismaDurationSetParam {
	if value == nil {
		return videosWithPrismaDurationSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Duration
func (r videosQueryDurationInt) Decrement(value int) videosWithPrismaDurationSetParam {
	return videosWithPrismaDurationSetParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDurationInt) DecrementIfPresent(value *int) videosWithPrismaDurationSetParam {
	if value == nil {
		return videosWithPrismaDurationSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Duration
func (r videosQueryDurationInt) Multiply(value int) videosWithPrismaDurationSetParam {
	return videosWithPrismaDurationSetParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDurationInt) MultiplyIfPresent(value *int) videosWithPrismaDurationSetParam {
	if value == nil {
		return videosWithPrismaDurationSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Duration
func (r videosQueryDurationInt) Divide(value int) videosWithPrismaDurationSetParam {
	return videosWithPrismaDurationSetParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDurationInt) DivideIfPresent(value *int) videosWithPrismaDurationSetParam {
	if value == nil {
		return videosWithPrismaDurationSetParam{}
	}
	return r.Divide(*value)
}

func (r videosQueryDurationInt) Equals(value int) videosWithPrismaDurationEqualsParam {

	return videosWithPrismaDurationEqualsParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDurationInt) EqualsIfPresent(value *int) videosWithPrismaDurationEqualsParam {
	if value == nil {
		return videosWithPrismaDurationEqualsParam{}
	}
	return r.Equals(*value)
}

func (r videosQueryDurationInt) Order(direction SortOrder) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name:  "duration",
			Value: direction,
		},
	}
}

func (r videosQueryDurationInt) Cursor(cursor int) videosCursorParam {
	return videosCursorParam{
		data: builder.Field{
			Name:  "duration",
			Value: cursor,
		},
	}
}

func (r videosQueryDurationInt) In(value []int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDurationInt) InIfPresent(value []int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.In(value)
}

func (r videosQueryDurationInt) NotIn(value []int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDurationInt) NotInIfPresent(value []int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.NotIn(value)
}

func (r videosQueryDurationInt) Lt(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDurationInt) LtIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lt(*value)
}

func (r videosQueryDurationInt) Lte(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDurationInt) LteIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lte(*value)
}

func (r videosQueryDurationInt) Gt(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDurationInt) GtIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gt(*value)
}

func (r videosQueryDurationInt) Gte(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDurationInt) GteIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gte(*value)
}

func (r videosQueryDurationInt) Not(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryDurationInt) NotIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r videosQueryDurationInt) LT(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r videosQueryDurationInt) LTIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r videosQueryDurationInt) LTE(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r videosQueryDurationInt) LTEIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r videosQueryDurationInt) GT(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r videosQueryDurationInt) GTIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r videosQueryDurationInt) GTE(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "duration",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r videosQueryDurationInt) GTEIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.GTE(*value)
}

func (r videosQueryDurationInt) Field() videosPrismaFields {
	return videosFieldDuration
}

// base struct
type videosQueryOwnerIDString struct{}

// Set the required value of OwnerID
func (r videosQueryOwnerIDString) Set(value string) videosSetParam {

	return videosSetParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: value,
		},
	}

}

// Set the optional value of OwnerID dynamically
func (r videosQueryOwnerIDString) SetIfPresent(value *String) videosSetParam {
	if value == nil {
		return videosSetParam{}
	}

	return r.Set(*value)
}

func (r videosQueryOwnerIDString) Equals(value string) videosWithPrismaOwnerIDEqualsParam {

	return videosWithPrismaOwnerIDEqualsParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryOwnerIDString) EqualsIfPresent(value *string) videosWithPrismaOwnerIDEqualsParam {
	if value == nil {
		return videosWithPrismaOwnerIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r videosQueryOwnerIDString) Order(direction SortOrder) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: direction,
		},
	}
}

func (r videosQueryOwnerIDString) Cursor(cursor string) videosCursorParam {
	return videosCursorParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: cursor,
		},
	}
}

func (r videosQueryOwnerIDString) In(value []string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryOwnerIDString) InIfPresent(value []string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.In(value)
}

func (r videosQueryOwnerIDString) NotIn(value []string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryOwnerIDString) NotInIfPresent(value []string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.NotIn(value)
}

func (r videosQueryOwnerIDString) Lt(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryOwnerIDString) LtIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lt(*value)
}

func (r videosQueryOwnerIDString) Lte(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryOwnerIDString) LteIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lte(*value)
}

func (r videosQueryOwnerIDString) Gt(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryOwnerIDString) GtIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gt(*value)
}

func (r videosQueryOwnerIDString) Gte(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryOwnerIDString) GteIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gte(*value)
}

func (r videosQueryOwnerIDString) Contains(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryOwnerIDString) ContainsIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Contains(*value)
}

func (r videosQueryOwnerIDString) StartsWith(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryOwnerIDString) StartsWithIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r videosQueryOwnerIDString) EndsWith(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryOwnerIDString) EndsWithIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r videosQueryOwnerIDString) Mode(value QueryMode) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryOwnerIDString) ModeIfPresent(value *QueryMode) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Mode(*value)
}

func (r videosQueryOwnerIDString) Not(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryOwnerIDString) NotIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r videosQueryOwnerIDString) HasPrefix(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r videosQueryOwnerIDString) HasPrefixIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r videosQueryOwnerIDString) HasSuffix(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r videosQueryOwnerIDString) HasSuffixIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r videosQueryOwnerIDString) Field() videosPrismaFields {
	return videosFieldOwnerID
}

// base struct
type videosQueryGuildIDString struct{}

// Set the required value of GuildID
func (r videosQueryGuildIDString) Set(value string) videosSetParam {

	return videosSetParam{
		data: builder.Field{
			Name:  "guildId",
			Value: value,
		},
	}

}

// Set the optional value of GuildID dynamically
func (r videosQueryGuildIDString) SetIfPresent(value *String) videosSetParam {
	if value == nil {
		return videosSetParam{}
	}

	return r.Set(*value)
}

func (r videosQueryGuildIDString) Equals(value string) videosWithPrismaGuildIDEqualsParam {

	return videosWithPrismaGuildIDEqualsParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryGuildIDString) EqualsIfPresent(value *string) videosWithPrismaGuildIDEqualsParam {
	if value == nil {
		return videosWithPrismaGuildIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r videosQueryGuildIDString) Order(direction SortOrder) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name:  "guildId",
			Value: direction,
		},
	}
}

func (r videosQueryGuildIDString) Cursor(cursor string) videosCursorParam {
	return videosCursorParam{
		data: builder.Field{
			Name:  "guildId",
			Value: cursor,
		},
	}
}

func (r videosQueryGuildIDString) In(value []string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryGuildIDString) InIfPresent(value []string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.In(value)
}

func (r videosQueryGuildIDString) NotIn(value []string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryGuildIDString) NotInIfPresent(value []string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.NotIn(value)
}

func (r videosQueryGuildIDString) Lt(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryGuildIDString) LtIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lt(*value)
}

func (r videosQueryGuildIDString) Lte(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryGuildIDString) LteIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lte(*value)
}

func (r videosQueryGuildIDString) Gt(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryGuildIDString) GtIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gt(*value)
}

func (r videosQueryGuildIDString) Gte(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryGuildIDString) GteIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gte(*value)
}

func (r videosQueryGuildIDString) Contains(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryGuildIDString) ContainsIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Contains(*value)
}

func (r videosQueryGuildIDString) StartsWith(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryGuildIDString) StartsWithIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r videosQueryGuildIDString) EndsWith(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryGuildIDString) EndsWithIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r videosQueryGuildIDString) Mode(value QueryMode) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryGuildIDString) ModeIfPresent(value *QueryMode) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Mode(*value)
}

func (r videosQueryGuildIDString) Not(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryGuildIDString) NotIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r videosQueryGuildIDString) HasPrefix(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r videosQueryGuildIDString) HasPrefixIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r videosQueryGuildIDString) HasSuffix(value string) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r videosQueryGuildIDString) HasSuffixIfPresent(value *string) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r videosQueryGuildIDString) Field() videosPrismaFields {
	return videosFieldGuildID
}

// base struct
type videosQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r videosQueryCreatedAtDateTime) Set(value DateTime) videosSetParam {

	return videosSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r videosQueryCreatedAtDateTime) SetIfPresent(value *DateTime) videosSetParam {
	if value == nil {
		return videosSetParam{}
	}

	return r.Set(*value)
}

func (r videosQueryCreatedAtDateTime) Equals(value DateTime) videosWithPrismaCreatedAtEqualsParam {

	return videosWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) videosWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return videosWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r videosQueryCreatedAtDateTime) Order(direction SortOrder) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r videosQueryCreatedAtDateTime) Cursor(cursor DateTime) videosCursorParam {
	return videosCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r videosQueryCreatedAtDateTime) In(value []DateTime) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryCreatedAtDateTime) InIfPresent(value []DateTime) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.In(value)
}

func (r videosQueryCreatedAtDateTime) NotIn(value []DateTime) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.NotIn(value)
}

func (r videosQueryCreatedAtDateTime) Lt(value DateTime) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryCreatedAtDateTime) LtIfPresent(value *DateTime) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lt(*value)
}

func (r videosQueryCreatedAtDateTime) Lte(value DateTime) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryCreatedAtDateTime) LteIfPresent(value *DateTime) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lte(*value)
}

func (r videosQueryCreatedAtDateTime) Gt(value DateTime) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryCreatedAtDateTime) GtIfPresent(value *DateTime) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gt(*value)
}

func (r videosQueryCreatedAtDateTime) Gte(value DateTime) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryCreatedAtDateTime) GteIfPresent(value *DateTime) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gte(*value)
}

func (r videosQueryCreatedAtDateTime) Not(value DateTime) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryCreatedAtDateTime) NotIfPresent(value *DateTime) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r videosQueryCreatedAtDateTime) Before(value DateTime) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r videosQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r videosQueryCreatedAtDateTime) After(value DateTime) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r videosQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r videosQueryCreatedAtDateTime) BeforeEquals(value DateTime) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r videosQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r videosQueryCreatedAtDateTime) AfterEquals(value DateTime) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r videosQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r videosQueryCreatedAtDateTime) Field() videosPrismaFields {
	return videosFieldCreatedAt
}

// base struct
type videosQueryOwnerUser struct{}

type videosQueryOwnerRelations struct{}

// Videos -> Owner
//
// @relation
// @required
func (videosQueryOwnerRelations) Where(
	params ...UserWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (videosQueryOwnerRelations) Fetch() videosToOwnerFindUnique {
	var v videosToOwnerFindUnique

	v.query.Operation = "query"
	v.query.Method = "owner"
	v.query.Outputs = userOutput

	return v
}

func (r videosQueryOwnerRelations) Link(
	params UserWhereParam,
) videosWithPrismaOwnerSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return videosWithPrismaOwnerSetParam{}
	}

	fields = append(fields, f)

	return videosWithPrismaOwnerSetParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r videosQueryOwnerRelations) Unlink() videosWithPrismaOwnerSetParam {
	var v videosWithPrismaOwnerSetParam

	v = videosWithPrismaOwnerSetParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r videosQueryOwnerUser) Field() videosPrismaFields {
	return videosFieldOwner
}

// base struct
type videosQueryGuildGuild struct{}

type videosQueryGuildRelations struct{}

// Videos -> Guild
//
// @relation
// @required
func (videosQueryGuildRelations) Where(
	params ...GuildWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "guild",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (videosQueryGuildRelations) Fetch() videosToGuildFindUnique {
	var v videosToGuildFindUnique

	v.query.Operation = "query"
	v.query.Method = "guild"
	v.query.Outputs = guildOutput

	return v
}

func (r videosQueryGuildRelations) Link(
	params GuildWhereParam,
) videosWithPrismaGuildSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return videosWithPrismaGuildSetParam{}
	}

	fields = append(fields, f)

	return videosWithPrismaGuildSetParam{
		data: builder.Field{
			Name: "guild",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r videosQueryGuildRelations) Unlink() videosWithPrismaGuildSetParam {
	var v videosWithPrismaGuildSetParam

	v = videosWithPrismaGuildSetParam{
		data: builder.Field{
			Name: "guild",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r videosQueryGuildGuild) Field() videosPrismaFields {
	return videosFieldGuild
}

// base struct
type videosQueryTagsTagsOnVideos struct{}

type videosQueryTagsRelations struct{}

// Videos -> Tags
//
// @relation
// @required
func (videosQueryTagsRelations) Some(
	params ...TagsOnVideosWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Videos -> Tags
//
// @relation
// @required
func (videosQueryTagsRelations) Every(
	params ...TagsOnVideosWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Videos -> Tags
//
// @relation
// @required
func (videosQueryTagsRelations) None(
	params ...TagsOnVideosWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (videosQueryTagsRelations) Fetch(

	params ...TagsOnVideosWhereParam,

) videosToTagsFindMany {
	var v videosToTagsFindMany

	v.query.Operation = "query"
	v.query.Method = "tags"
	v.query.Outputs = tagsOnVideosOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r videosQueryTagsRelations) Link(
	params ...TagsOnVideosWhereParam,
) videosSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosSetParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r videosQueryTagsRelations) Unlink(
	params ...TagsOnVideosWhereParam,
) videosSetParam {
	var v videosSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = videosSetParam{
		data: builder.Field{
			Name: "tags",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r videosQueryTagsTagsOnVideos) Field() videosPrismaFields {
	return videosFieldTags
}

// base struct
type videosQueryIsPrivateBoolean struct{}

// Set the required value of IsPrivate
func (r videosQueryIsPrivateBoolean) Set(value bool) videosSetParam {

	return videosSetParam{
		data: builder.Field{
			Name:  "isPrivate",
			Value: value,
		},
	}

}

// Set the optional value of IsPrivate dynamically
func (r videosQueryIsPrivateBoolean) SetIfPresent(value *Boolean) videosSetParam {
	if value == nil {
		return videosSetParam{}
	}

	return r.Set(*value)
}

func (r videosQueryIsPrivateBoolean) Equals(value bool) videosWithPrismaIsPrivateEqualsParam {

	return videosWithPrismaIsPrivateEqualsParam{
		data: builder.Field{
			Name: "isPrivate",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryIsPrivateBoolean) EqualsIfPresent(value *bool) videosWithPrismaIsPrivateEqualsParam {
	if value == nil {
		return videosWithPrismaIsPrivateEqualsParam{}
	}
	return r.Equals(*value)
}

func (r videosQueryIsPrivateBoolean) Order(direction SortOrder) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name:  "isPrivate",
			Value: direction,
		},
	}
}

func (r videosQueryIsPrivateBoolean) Cursor(cursor bool) videosCursorParam {
	return videosCursorParam{
		data: builder.Field{
			Name:  "isPrivate",
			Value: cursor,
		},
	}
}

func (r videosQueryIsPrivateBoolean) Field() videosPrismaFields {
	return videosFieldIsPrivate
}

// base struct
type videosQueryLikesLikes struct{}

type videosQueryLikesRelations struct{}

// Videos -> Likes
//
// @relation
// @required
func (videosQueryLikesRelations) Some(
	params ...LikesWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Videos -> Likes
//
// @relation
// @required
func (videosQueryLikesRelations) Every(
	params ...LikesWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Videos -> Likes
//
// @relation
// @required
func (videosQueryLikesRelations) None(
	params ...LikesWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (videosQueryLikesRelations) Fetch(

	params ...LikesWhereParam,

) videosToLikesFindMany {
	var v videosToLikesFindMany

	v.query.Operation = "query"
	v.query.Method = "likes"
	v.query.Outputs = likesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r videosQueryLikesRelations) Link(
	params ...LikesWhereParam,
) videosSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosSetParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r videosQueryLikesRelations) Unlink(
	params ...LikesWhereParam,
) videosSetParam {
	var v videosSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = videosSetParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r videosQueryLikesLikes) Field() videosPrismaFields {
	return videosFieldLikes
}

// base struct
type videosQueryViewsInt struct{}

// Set the required value of Views
func (r videosQueryViewsInt) Set(value int) videosSetParam {

	return videosSetParam{
		data: builder.Field{
			Name:  "views",
			Value: value,
		},
	}

}

// Set the optional value of Views dynamically
func (r videosQueryViewsInt) SetIfPresent(value *Int) videosSetParam {
	if value == nil {
		return videosSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Views
func (r videosQueryViewsInt) Increment(value int) videosSetParam {
	return videosSetParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryViewsInt) IncrementIfPresent(value *int) videosSetParam {
	if value == nil {
		return videosSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Views
func (r videosQueryViewsInt) Decrement(value int) videosSetParam {
	return videosSetParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryViewsInt) DecrementIfPresent(value *int) videosSetParam {
	if value == nil {
		return videosSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Views
func (r videosQueryViewsInt) Multiply(value int) videosSetParam {
	return videosSetParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryViewsInt) MultiplyIfPresent(value *int) videosSetParam {
	if value == nil {
		return videosSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Views
func (r videosQueryViewsInt) Divide(value int) videosSetParam {
	return videosSetParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryViewsInt) DivideIfPresent(value *int) videosSetParam {
	if value == nil {
		return videosSetParam{}
	}
	return r.Divide(*value)
}

func (r videosQueryViewsInt) Equals(value int) videosWithPrismaViewsEqualsParam {

	return videosWithPrismaViewsEqualsParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryViewsInt) EqualsIfPresent(value *int) videosWithPrismaViewsEqualsParam {
	if value == nil {
		return videosWithPrismaViewsEqualsParam{}
	}
	return r.Equals(*value)
}

func (r videosQueryViewsInt) Order(direction SortOrder) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name:  "views",
			Value: direction,
		},
	}
}

func (r videosQueryViewsInt) Cursor(cursor int) videosCursorParam {
	return videosCursorParam{
		data: builder.Field{
			Name:  "views",
			Value: cursor,
		},
	}
}

func (r videosQueryViewsInt) In(value []int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryViewsInt) InIfPresent(value []int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.In(value)
}

func (r videosQueryViewsInt) NotIn(value []int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryViewsInt) NotInIfPresent(value []int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.NotIn(value)
}

func (r videosQueryViewsInt) Lt(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryViewsInt) LtIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lt(*value)
}

func (r videosQueryViewsInt) Lte(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryViewsInt) LteIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Lte(*value)
}

func (r videosQueryViewsInt) Gt(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryViewsInt) GtIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gt(*value)
}

func (r videosQueryViewsInt) Gte(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryViewsInt) GteIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Gte(*value)
}

func (r videosQueryViewsInt) Not(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r videosQueryViewsInt) NotIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r videosQueryViewsInt) LT(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r videosQueryViewsInt) LTIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.LT(*value)
}

// deprecated: Use Lte instead.

func (r videosQueryViewsInt) LTE(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r videosQueryViewsInt) LTEIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.LTE(*value)
}

// deprecated: Use Gt instead.

func (r videosQueryViewsInt) GT(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r videosQueryViewsInt) GTIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.GT(*value)
}

// deprecated: Use Gte instead.

func (r videosQueryViewsInt) GTE(value int) videosDefaultParam {
	return videosDefaultParam{
		data: builder.Field{
			Name: "views",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r videosQueryViewsInt) GTEIfPresent(value *int) videosDefaultParam {
	if value == nil {
		return videosDefaultParam{}
	}
	return r.GTE(*value)
}

func (r videosQueryViewsInt) Field() videosPrismaFields {
	return videosFieldViews
}

// base struct
type videosQueryHistoryhistory struct{}

type videosQueryHistoryRelations struct{}

// Videos -> History
//
// @relation
// @required
func (videosQueryHistoryRelations) Some(
	params ...HistoryWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "history",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Videos -> History
//
// @relation
// @required
func (videosQueryHistoryRelations) Every(
	params ...HistoryWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "history",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Videos -> History
//
// @relation
// @required
func (videosQueryHistoryRelations) None(
	params ...HistoryWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "history",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (videosQueryHistoryRelations) Fetch(

	params ...HistoryWhereParam,

) videosToHistoryFindMany {
	var v videosToHistoryFindMany

	v.query.Operation = "query"
	v.query.Method = "history"
	v.query.Outputs = historyOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r videosQueryHistoryRelations) Link(
	params ...HistoryWhereParam,
) videosSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosSetParam{
		data: builder.Field{
			Name: "history",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r videosQueryHistoryRelations) Unlink(
	params ...HistoryWhereParam,
) videosSetParam {
	var v videosSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = videosSetParam{
		data: builder.Field{
			Name: "history",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r videosQueryHistoryhistory) Field() videosPrismaFields {
	return videosFieldHistory
}

// base struct
type videosQueryWatchLaterWatchLater struct{}

type videosQueryWatchLaterRelations struct{}

// Videos -> WatchLater
//
// @relation
// @required
func (videosQueryWatchLaterRelations) Some(
	params ...WatchLaterWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "watchLater",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Videos -> WatchLater
//
// @relation
// @required
func (videosQueryWatchLaterRelations) Every(
	params ...WatchLaterWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "watchLater",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Videos -> WatchLater
//
// @relation
// @required
func (videosQueryWatchLaterRelations) None(
	params ...WatchLaterWhereParam,
) videosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosDefaultParam{
		data: builder.Field{
			Name: "watchLater",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (videosQueryWatchLaterRelations) Fetch(

	params ...WatchLaterWhereParam,

) videosToWatchLaterFindMany {
	var v videosToWatchLaterFindMany

	v.query.Operation = "query"
	v.query.Method = "watchLater"
	v.query.Outputs = watchLaterOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r videosQueryWatchLaterRelations) Link(
	params ...WatchLaterWhereParam,
) videosSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return videosSetParam{
		data: builder.Field{
			Name: "watchLater",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r videosQueryWatchLaterRelations) Unlink(
	params ...WatchLaterWhereParam,
) videosSetParam {
	var v videosSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = videosSetParam{
		data: builder.Field{
			Name: "watchLater",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r videosQueryWatchLaterWatchLater) Field() videosPrismaFields {
	return videosFieldWatchLater
}

// Tags acts as a namespaces to access query methods for the Tags model
var Tags = tagsQuery{}

// tagsQuery exposes query functions for the tags model
type tagsQuery struct {

	// ID
	//
	// @required
	ID tagsQueryIDString

	// Name
	//
	// @required
	Name tagsQueryNameString

	// GuildID
	//
	// @required
	GuildID tagsQueryGuildIDString

	Guild tagsQueryGuildRelations

	Videos tagsQueryVideosRelations
}

func (tagsQuery) Not(params ...TagsWhereParam) tagsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagsDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (tagsQuery) Or(params ...TagsWhereParam) tagsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagsDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (tagsQuery) And(params ...TagsWhereParam) tagsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagsDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (tagsQuery) NameGuildID(
	_name TagsWithPrismaNameWhereParam,

	_guildID TagsWithPrismaGuildIDWhereParam,
) TagsEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _guildID.field())

	return tagsEqualsUniqueParam{
		data: builder.Field{
			Name:   "name_guildId",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type tagsQueryIDString struct{}

// Set the required value of ID
func (r tagsQueryIDString) Set(value string) tagsSetParam {

	return tagsSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r tagsQueryIDString) SetIfPresent(value *String) tagsSetParam {
	if value == nil {
		return tagsSetParam{}
	}

	return r.Set(*value)
}

func (r tagsQueryIDString) Equals(value string) tagsWithPrismaIDEqualsUniqueParam {

	return tagsWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryIDString) EqualsIfPresent(value *string) tagsWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return tagsWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r tagsQueryIDString) Order(direction SortOrder) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r tagsQueryIDString) Cursor(cursor string) tagsCursorParam {
	return tagsCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r tagsQueryIDString) In(value []string) tagsParamUnique {
	return tagsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryIDString) InIfPresent(value []string) tagsParamUnique {
	if value == nil {
		return tagsParamUnique{}
	}
	return r.In(value)
}

func (r tagsQueryIDString) NotIn(value []string) tagsParamUnique {
	return tagsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryIDString) NotInIfPresent(value []string) tagsParamUnique {
	if value == nil {
		return tagsParamUnique{}
	}
	return r.NotIn(value)
}

func (r tagsQueryIDString) Lt(value string) tagsParamUnique {
	return tagsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryIDString) LtIfPresent(value *string) tagsParamUnique {
	if value == nil {
		return tagsParamUnique{}
	}
	return r.Lt(*value)
}

func (r tagsQueryIDString) Lte(value string) tagsParamUnique {
	return tagsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryIDString) LteIfPresent(value *string) tagsParamUnique {
	if value == nil {
		return tagsParamUnique{}
	}
	return r.Lte(*value)
}

func (r tagsQueryIDString) Gt(value string) tagsParamUnique {
	return tagsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryIDString) GtIfPresent(value *string) tagsParamUnique {
	if value == nil {
		return tagsParamUnique{}
	}
	return r.Gt(*value)
}

func (r tagsQueryIDString) Gte(value string) tagsParamUnique {
	return tagsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryIDString) GteIfPresent(value *string) tagsParamUnique {
	if value == nil {
		return tagsParamUnique{}
	}
	return r.Gte(*value)
}

func (r tagsQueryIDString) Contains(value string) tagsParamUnique {
	return tagsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryIDString) ContainsIfPresent(value *string) tagsParamUnique {
	if value == nil {
		return tagsParamUnique{}
	}
	return r.Contains(*value)
}

func (r tagsQueryIDString) StartsWith(value string) tagsParamUnique {
	return tagsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryIDString) StartsWithIfPresent(value *string) tagsParamUnique {
	if value == nil {
		return tagsParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r tagsQueryIDString) EndsWith(value string) tagsParamUnique {
	return tagsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryIDString) EndsWithIfPresent(value *string) tagsParamUnique {
	if value == nil {
		return tagsParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r tagsQueryIDString) Mode(value QueryMode) tagsParamUnique {
	return tagsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryIDString) ModeIfPresent(value *QueryMode) tagsParamUnique {
	if value == nil {
		return tagsParamUnique{}
	}
	return r.Mode(*value)
}

func (r tagsQueryIDString) Not(value string) tagsParamUnique {
	return tagsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryIDString) NotIfPresent(value *string) tagsParamUnique {
	if value == nil {
		return tagsParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r tagsQueryIDString) HasPrefix(value string) tagsParamUnique {
	return tagsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r tagsQueryIDString) HasPrefixIfPresent(value *string) tagsParamUnique {
	if value == nil {
		return tagsParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r tagsQueryIDString) HasSuffix(value string) tagsParamUnique {
	return tagsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r tagsQueryIDString) HasSuffixIfPresent(value *string) tagsParamUnique {
	if value == nil {
		return tagsParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r tagsQueryIDString) Field() tagsPrismaFields {
	return tagsFieldID
}

// base struct
type tagsQueryNameString struct{}

// Set the required value of Name
func (r tagsQueryNameString) Set(value string) tagsWithPrismaNameSetParam {

	return tagsWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r tagsQueryNameString) SetIfPresent(value *String) tagsWithPrismaNameSetParam {
	if value == nil {
		return tagsWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r tagsQueryNameString) Equals(value string) tagsWithPrismaNameEqualsParam {

	return tagsWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryNameString) EqualsIfPresent(value *string) tagsWithPrismaNameEqualsParam {
	if value == nil {
		return tagsWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r tagsQueryNameString) Order(direction SortOrder) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r tagsQueryNameString) Cursor(cursor string) tagsCursorParam {
	return tagsCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r tagsQueryNameString) In(value []string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryNameString) InIfPresent(value []string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.In(value)
}

func (r tagsQueryNameString) NotIn(value []string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryNameString) NotInIfPresent(value []string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r tagsQueryNameString) Lt(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryNameString) LtIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r tagsQueryNameString) Lte(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryNameString) LteIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r tagsQueryNameString) Gt(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryNameString) GtIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r tagsQueryNameString) Gte(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryNameString) GteIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r tagsQueryNameString) Contains(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryNameString) ContainsIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r tagsQueryNameString) StartsWith(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryNameString) StartsWithIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r tagsQueryNameString) EndsWith(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryNameString) EndsWithIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r tagsQueryNameString) Mode(value QueryMode) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryNameString) ModeIfPresent(value *QueryMode) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r tagsQueryNameString) Not(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryNameString) NotIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r tagsQueryNameString) HasPrefix(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r tagsQueryNameString) HasPrefixIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r tagsQueryNameString) HasSuffix(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r tagsQueryNameString) HasSuffixIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r tagsQueryNameString) Field() tagsPrismaFields {
	return tagsFieldName
}

// base struct
type tagsQueryGuildIDString struct{}

// Set the required value of GuildID
func (r tagsQueryGuildIDString) Set(value string) tagsSetParam {

	return tagsSetParam{
		data: builder.Field{
			Name:  "guildId",
			Value: value,
		},
	}

}

// Set the optional value of GuildID dynamically
func (r tagsQueryGuildIDString) SetIfPresent(value *String) tagsSetParam {
	if value == nil {
		return tagsSetParam{}
	}

	return r.Set(*value)
}

func (r tagsQueryGuildIDString) Equals(value string) tagsWithPrismaGuildIDEqualsParam {

	return tagsWithPrismaGuildIDEqualsParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryGuildIDString) EqualsIfPresent(value *string) tagsWithPrismaGuildIDEqualsParam {
	if value == nil {
		return tagsWithPrismaGuildIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r tagsQueryGuildIDString) Order(direction SortOrder) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name:  "guildId",
			Value: direction,
		},
	}
}

func (r tagsQueryGuildIDString) Cursor(cursor string) tagsCursorParam {
	return tagsCursorParam{
		data: builder.Field{
			Name:  "guildId",
			Value: cursor,
		},
	}
}

func (r tagsQueryGuildIDString) In(value []string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryGuildIDString) InIfPresent(value []string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.In(value)
}

func (r tagsQueryGuildIDString) NotIn(value []string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryGuildIDString) NotInIfPresent(value []string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r tagsQueryGuildIDString) Lt(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryGuildIDString) LtIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r tagsQueryGuildIDString) Lte(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryGuildIDString) LteIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r tagsQueryGuildIDString) Gt(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryGuildIDString) GtIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r tagsQueryGuildIDString) Gte(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryGuildIDString) GteIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r tagsQueryGuildIDString) Contains(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryGuildIDString) ContainsIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r tagsQueryGuildIDString) StartsWith(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryGuildIDString) StartsWithIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r tagsQueryGuildIDString) EndsWith(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryGuildIDString) EndsWithIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r tagsQueryGuildIDString) Mode(value QueryMode) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryGuildIDString) ModeIfPresent(value *QueryMode) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r tagsQueryGuildIDString) Not(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r tagsQueryGuildIDString) NotIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r tagsQueryGuildIDString) HasPrefix(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r tagsQueryGuildIDString) HasPrefixIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r tagsQueryGuildIDString) HasSuffix(value string) tagsDefaultParam {
	return tagsDefaultParam{
		data: builder.Field{
			Name: "guildId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r tagsQueryGuildIDString) HasSuffixIfPresent(value *string) tagsDefaultParam {
	if value == nil {
		return tagsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r tagsQueryGuildIDString) Field() tagsPrismaFields {
	return tagsFieldGuildID
}

// base struct
type tagsQueryGuildGuild struct{}

type tagsQueryGuildRelations struct{}

// Tags -> Guild
//
// @relation
// @required
func (tagsQueryGuildRelations) Where(
	params ...GuildWhereParam,
) tagsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagsDefaultParam{
		data: builder.Field{
			Name: "guild",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (tagsQueryGuildRelations) Fetch() tagsToGuildFindUnique {
	var v tagsToGuildFindUnique

	v.query.Operation = "query"
	v.query.Method = "guild"
	v.query.Outputs = guildOutput

	return v
}

func (r tagsQueryGuildRelations) Link(
	params GuildWhereParam,
) tagsWithPrismaGuildSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return tagsWithPrismaGuildSetParam{}
	}

	fields = append(fields, f)

	return tagsWithPrismaGuildSetParam{
		data: builder.Field{
			Name: "guild",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r tagsQueryGuildRelations) Unlink() tagsWithPrismaGuildSetParam {
	var v tagsWithPrismaGuildSetParam

	v = tagsWithPrismaGuildSetParam{
		data: builder.Field{
			Name: "guild",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r tagsQueryGuildGuild) Field() tagsPrismaFields {
	return tagsFieldGuild
}

// base struct
type tagsQueryVideosTagsOnVideos struct{}

type tagsQueryVideosRelations struct{}

// Tags -> Videos
//
// @relation
// @required
func (tagsQueryVideosRelations) Some(
	params ...TagsOnVideosWhereParam,
) tagsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagsDefaultParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Tags -> Videos
//
// @relation
// @required
func (tagsQueryVideosRelations) Every(
	params ...TagsOnVideosWhereParam,
) tagsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagsDefaultParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Tags -> Videos
//
// @relation
// @required
func (tagsQueryVideosRelations) None(
	params ...TagsOnVideosWhereParam,
) tagsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagsDefaultParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (tagsQueryVideosRelations) Fetch(

	params ...TagsOnVideosWhereParam,

) tagsToVideosFindMany {
	var v tagsToVideosFindMany

	v.query.Operation = "query"
	v.query.Method = "videos"
	v.query.Outputs = tagsOnVideosOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r tagsQueryVideosRelations) Link(
	params ...TagsOnVideosWhereParam,
) tagsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagsSetParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r tagsQueryVideosRelations) Unlink(
	params ...TagsOnVideosWhereParam,
) tagsSetParam {
	var v tagsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = tagsSetParam{
		data: builder.Field{
			Name: "videos",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r tagsQueryVideosTagsOnVideos) Field() tagsPrismaFields {
	return tagsFieldVideos
}

// TagsOnVideos acts as a namespaces to access query methods for the TagsOnVideos model
var TagsOnVideos = tagsOnVideosQuery{}

// tagsOnVideosQuery exposes query functions for the tagsOnVideos model
type tagsOnVideosQuery struct {

	// ID
	//
	// @required
	ID tagsOnVideosQueryIDString

	// VideoID
	//
	// @required
	VideoID tagsOnVideosQueryVideoIDString

	// TagID
	//
	// @required
	TagID tagsOnVideosQueryTagIDString

	Video tagsOnVideosQueryVideoRelations

	Tag tagsOnVideosQueryTagRelations
}

func (tagsOnVideosQuery) Not(params ...TagsOnVideosWhereParam) tagsOnVideosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (tagsOnVideosQuery) Or(params ...TagsOnVideosWhereParam) tagsOnVideosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (tagsOnVideosQuery) And(params ...TagsOnVideosWhereParam) tagsOnVideosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (tagsOnVideosQuery) VideoIDTagID(
	_videoID TagsOnVideosWithPrismaVideoIDWhereParam,

	_tagID TagsOnVideosWithPrismaTagIDWhereParam,
) TagsOnVideosEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _videoID.field())
	fields = append(fields, _tagID.field())

	return tagsOnVideosEqualsUniqueParam{
		data: builder.Field{
			Name:   "videoId_tagId",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type tagsOnVideosQueryIDString struct{}

// Set the required value of ID
func (r tagsOnVideosQueryIDString) Set(value string) tagsOnVideosSetParam {

	return tagsOnVideosSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r tagsOnVideosQueryIDString) SetIfPresent(value *String) tagsOnVideosSetParam {
	if value == nil {
		return tagsOnVideosSetParam{}
	}

	return r.Set(*value)
}

func (r tagsOnVideosQueryIDString) Equals(value string) tagsOnVideosWithPrismaIDEqualsUniqueParam {

	return tagsOnVideosWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryIDString) EqualsIfPresent(value *string) tagsOnVideosWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return tagsOnVideosWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r tagsOnVideosQueryIDString) Order(direction SortOrder) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r tagsOnVideosQueryIDString) Cursor(cursor string) tagsOnVideosCursorParam {
	return tagsOnVideosCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r tagsOnVideosQueryIDString) In(value []string) tagsOnVideosParamUnique {
	return tagsOnVideosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryIDString) InIfPresent(value []string) tagsOnVideosParamUnique {
	if value == nil {
		return tagsOnVideosParamUnique{}
	}
	return r.In(value)
}

func (r tagsOnVideosQueryIDString) NotIn(value []string) tagsOnVideosParamUnique {
	return tagsOnVideosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryIDString) NotInIfPresent(value []string) tagsOnVideosParamUnique {
	if value == nil {
		return tagsOnVideosParamUnique{}
	}
	return r.NotIn(value)
}

func (r tagsOnVideosQueryIDString) Lt(value string) tagsOnVideosParamUnique {
	return tagsOnVideosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryIDString) LtIfPresent(value *string) tagsOnVideosParamUnique {
	if value == nil {
		return tagsOnVideosParamUnique{}
	}
	return r.Lt(*value)
}

func (r tagsOnVideosQueryIDString) Lte(value string) tagsOnVideosParamUnique {
	return tagsOnVideosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryIDString) LteIfPresent(value *string) tagsOnVideosParamUnique {
	if value == nil {
		return tagsOnVideosParamUnique{}
	}
	return r.Lte(*value)
}

func (r tagsOnVideosQueryIDString) Gt(value string) tagsOnVideosParamUnique {
	return tagsOnVideosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryIDString) GtIfPresent(value *string) tagsOnVideosParamUnique {
	if value == nil {
		return tagsOnVideosParamUnique{}
	}
	return r.Gt(*value)
}

func (r tagsOnVideosQueryIDString) Gte(value string) tagsOnVideosParamUnique {
	return tagsOnVideosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryIDString) GteIfPresent(value *string) tagsOnVideosParamUnique {
	if value == nil {
		return tagsOnVideosParamUnique{}
	}
	return r.Gte(*value)
}

func (r tagsOnVideosQueryIDString) Contains(value string) tagsOnVideosParamUnique {
	return tagsOnVideosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryIDString) ContainsIfPresent(value *string) tagsOnVideosParamUnique {
	if value == nil {
		return tagsOnVideosParamUnique{}
	}
	return r.Contains(*value)
}

func (r tagsOnVideosQueryIDString) StartsWith(value string) tagsOnVideosParamUnique {
	return tagsOnVideosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryIDString) StartsWithIfPresent(value *string) tagsOnVideosParamUnique {
	if value == nil {
		return tagsOnVideosParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r tagsOnVideosQueryIDString) EndsWith(value string) tagsOnVideosParamUnique {
	return tagsOnVideosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryIDString) EndsWithIfPresent(value *string) tagsOnVideosParamUnique {
	if value == nil {
		return tagsOnVideosParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r tagsOnVideosQueryIDString) Mode(value QueryMode) tagsOnVideosParamUnique {
	return tagsOnVideosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryIDString) ModeIfPresent(value *QueryMode) tagsOnVideosParamUnique {
	if value == nil {
		return tagsOnVideosParamUnique{}
	}
	return r.Mode(*value)
}

func (r tagsOnVideosQueryIDString) Not(value string) tagsOnVideosParamUnique {
	return tagsOnVideosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryIDString) NotIfPresent(value *string) tagsOnVideosParamUnique {
	if value == nil {
		return tagsOnVideosParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r tagsOnVideosQueryIDString) HasPrefix(value string) tagsOnVideosParamUnique {
	return tagsOnVideosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r tagsOnVideosQueryIDString) HasPrefixIfPresent(value *string) tagsOnVideosParamUnique {
	if value == nil {
		return tagsOnVideosParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r tagsOnVideosQueryIDString) HasSuffix(value string) tagsOnVideosParamUnique {
	return tagsOnVideosParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r tagsOnVideosQueryIDString) HasSuffixIfPresent(value *string) tagsOnVideosParamUnique {
	if value == nil {
		return tagsOnVideosParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r tagsOnVideosQueryIDString) Field() tagsOnVideosPrismaFields {
	return tagsOnVideosFieldID
}

// base struct
type tagsOnVideosQueryVideoIDString struct{}

// Set the required value of VideoID
func (r tagsOnVideosQueryVideoIDString) Set(value string) tagsOnVideosSetParam {

	return tagsOnVideosSetParam{
		data: builder.Field{
			Name:  "videoId",
			Value: value,
		},
	}

}

// Set the optional value of VideoID dynamically
func (r tagsOnVideosQueryVideoIDString) SetIfPresent(value *String) tagsOnVideosSetParam {
	if value == nil {
		return tagsOnVideosSetParam{}
	}

	return r.Set(*value)
}

func (r tagsOnVideosQueryVideoIDString) Equals(value string) tagsOnVideosWithPrismaVideoIDEqualsParam {

	return tagsOnVideosWithPrismaVideoIDEqualsParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) EqualsIfPresent(value *string) tagsOnVideosWithPrismaVideoIDEqualsParam {
	if value == nil {
		return tagsOnVideosWithPrismaVideoIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r tagsOnVideosQueryVideoIDString) Order(direction SortOrder) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name:  "videoId",
			Value: direction,
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) Cursor(cursor string) tagsOnVideosCursorParam {
	return tagsOnVideosCursorParam{
		data: builder.Field{
			Name:  "videoId",
			Value: cursor,
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) In(value []string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) InIfPresent(value []string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.In(value)
}

func (r tagsOnVideosQueryVideoIDString) NotIn(value []string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) NotInIfPresent(value []string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.NotIn(value)
}

func (r tagsOnVideosQueryVideoIDString) Lt(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) LtIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Lt(*value)
}

func (r tagsOnVideosQueryVideoIDString) Lte(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) LteIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Lte(*value)
}

func (r tagsOnVideosQueryVideoIDString) Gt(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) GtIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Gt(*value)
}

func (r tagsOnVideosQueryVideoIDString) Gte(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) GteIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Gte(*value)
}

func (r tagsOnVideosQueryVideoIDString) Contains(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) ContainsIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Contains(*value)
}

func (r tagsOnVideosQueryVideoIDString) StartsWith(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) StartsWithIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r tagsOnVideosQueryVideoIDString) EndsWith(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) EndsWithIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r tagsOnVideosQueryVideoIDString) Mode(value QueryMode) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) ModeIfPresent(value *QueryMode) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Mode(*value)
}

func (r tagsOnVideosQueryVideoIDString) Not(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryVideoIDString) NotIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r tagsOnVideosQueryVideoIDString) HasPrefix(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r tagsOnVideosQueryVideoIDString) HasPrefixIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r tagsOnVideosQueryVideoIDString) HasSuffix(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r tagsOnVideosQueryVideoIDString) HasSuffixIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r tagsOnVideosQueryVideoIDString) Field() tagsOnVideosPrismaFields {
	return tagsOnVideosFieldVideoID
}

// base struct
type tagsOnVideosQueryTagIDString struct{}

// Set the required value of TagID
func (r tagsOnVideosQueryTagIDString) Set(value string) tagsOnVideosSetParam {

	return tagsOnVideosSetParam{
		data: builder.Field{
			Name:  "tagId",
			Value: value,
		},
	}

}

// Set the optional value of TagID dynamically
func (r tagsOnVideosQueryTagIDString) SetIfPresent(value *String) tagsOnVideosSetParam {
	if value == nil {
		return tagsOnVideosSetParam{}
	}

	return r.Set(*value)
}

func (r tagsOnVideosQueryTagIDString) Equals(value string) tagsOnVideosWithPrismaTagIDEqualsParam {

	return tagsOnVideosWithPrismaTagIDEqualsParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryTagIDString) EqualsIfPresent(value *string) tagsOnVideosWithPrismaTagIDEqualsParam {
	if value == nil {
		return tagsOnVideosWithPrismaTagIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r tagsOnVideosQueryTagIDString) Order(direction SortOrder) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name:  "tagId",
			Value: direction,
		},
	}
}

func (r tagsOnVideosQueryTagIDString) Cursor(cursor string) tagsOnVideosCursorParam {
	return tagsOnVideosCursorParam{
		data: builder.Field{
			Name:  "tagId",
			Value: cursor,
		},
	}
}

func (r tagsOnVideosQueryTagIDString) In(value []string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryTagIDString) InIfPresent(value []string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.In(value)
}

func (r tagsOnVideosQueryTagIDString) NotIn(value []string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryTagIDString) NotInIfPresent(value []string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.NotIn(value)
}

func (r tagsOnVideosQueryTagIDString) Lt(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryTagIDString) LtIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Lt(*value)
}

func (r tagsOnVideosQueryTagIDString) Lte(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryTagIDString) LteIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Lte(*value)
}

func (r tagsOnVideosQueryTagIDString) Gt(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryTagIDString) GtIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Gt(*value)
}

func (r tagsOnVideosQueryTagIDString) Gte(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryTagIDString) GteIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Gte(*value)
}

func (r tagsOnVideosQueryTagIDString) Contains(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryTagIDString) ContainsIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Contains(*value)
}

func (r tagsOnVideosQueryTagIDString) StartsWith(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryTagIDString) StartsWithIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r tagsOnVideosQueryTagIDString) EndsWith(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryTagIDString) EndsWithIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r tagsOnVideosQueryTagIDString) Mode(value QueryMode) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryTagIDString) ModeIfPresent(value *QueryMode) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Mode(*value)
}

func (r tagsOnVideosQueryTagIDString) Not(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r tagsOnVideosQueryTagIDString) NotIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r tagsOnVideosQueryTagIDString) HasPrefix(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r tagsOnVideosQueryTagIDString) HasPrefixIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r tagsOnVideosQueryTagIDString) HasSuffix(value string) tagsOnVideosDefaultParam {
	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tagId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r tagsOnVideosQueryTagIDString) HasSuffixIfPresent(value *string) tagsOnVideosDefaultParam {
	if value == nil {
		return tagsOnVideosDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r tagsOnVideosQueryTagIDString) Field() tagsOnVideosPrismaFields {
	return tagsOnVideosFieldTagID
}

// base struct
type tagsOnVideosQueryVideoVideos struct{}

type tagsOnVideosQueryVideoRelations struct{}

// TagsOnVideos -> Video
//
// @relation
// @required
func (tagsOnVideosQueryVideoRelations) Where(
	params ...VideosWhereParam,
) tagsOnVideosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "video",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (tagsOnVideosQueryVideoRelations) Fetch() tagsOnVideosToVideoFindUnique {
	var v tagsOnVideosToVideoFindUnique

	v.query.Operation = "query"
	v.query.Method = "video"
	v.query.Outputs = videosOutput

	return v
}

func (r tagsOnVideosQueryVideoRelations) Link(
	params VideosWhereParam,
) tagsOnVideosWithPrismaVideoSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return tagsOnVideosWithPrismaVideoSetParam{}
	}

	fields = append(fields, f)

	return tagsOnVideosWithPrismaVideoSetParam{
		data: builder.Field{
			Name: "video",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r tagsOnVideosQueryVideoRelations) Unlink() tagsOnVideosWithPrismaVideoSetParam {
	var v tagsOnVideosWithPrismaVideoSetParam

	v = tagsOnVideosWithPrismaVideoSetParam{
		data: builder.Field{
			Name: "video",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r tagsOnVideosQueryVideoVideos) Field() tagsOnVideosPrismaFields {
	return tagsOnVideosFieldVideo
}

// base struct
type tagsOnVideosQueryTagTags struct{}

type tagsOnVideosQueryTagRelations struct{}

// TagsOnVideos -> Tag
//
// @relation
// @required
func (tagsOnVideosQueryTagRelations) Where(
	params ...TagsWhereParam,
) tagsOnVideosDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return tagsOnVideosDefaultParam{
		data: builder.Field{
			Name: "tag",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (tagsOnVideosQueryTagRelations) Fetch() tagsOnVideosToTagFindUnique {
	var v tagsOnVideosToTagFindUnique

	v.query.Operation = "query"
	v.query.Method = "tag"
	v.query.Outputs = tagsOutput

	return v
}

func (r tagsOnVideosQueryTagRelations) Link(
	params TagsWhereParam,
) tagsOnVideosWithPrismaTagSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return tagsOnVideosWithPrismaTagSetParam{}
	}

	fields = append(fields, f)

	return tagsOnVideosWithPrismaTagSetParam{
		data: builder.Field{
			Name: "tag",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r tagsOnVideosQueryTagRelations) Unlink() tagsOnVideosWithPrismaTagSetParam {
	var v tagsOnVideosWithPrismaTagSetParam

	v = tagsOnVideosWithPrismaTagSetParam{
		data: builder.Field{
			Name: "tag",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r tagsOnVideosQueryTagTags) Field() tagsOnVideosPrismaFields {
	return tagsOnVideosFieldTag
}

// Comments acts as a namespaces to access query methods for the Comments model
var Comments = commentsQuery{}

// commentsQuery exposes query functions for the comments model
type commentsQuery struct {

	// ID
	//
	// @required
	ID commentsQueryIDString

	// OwnerID
	//
	// @required
	OwnerID commentsQueryOwnerIDString

	// Role
	//
	// @required
	Role commentsQueryRoleROLE

	// VideoID
	//
	// @required
	VideoID commentsQueryVideoIDString

	// Content
	//
	// @required
	Content commentsQueryContentString

	Likes commentsQueryLikesRelations

	Owner commentsQueryOwnerRelations

	// CreatedAt
	//
	// @required
	CreatedAt commentsQueryCreatedAtDateTime
}

func (commentsQuery) Not(params ...CommentsWhereParam) commentsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentsDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (commentsQuery) Or(params ...CommentsWhereParam) commentsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentsDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (commentsQuery) And(params ...CommentsWhereParam) commentsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentsDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type commentsQueryIDString struct{}

// Set the required value of ID
func (r commentsQueryIDString) Set(value string) commentsSetParam {

	return commentsSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r commentsQueryIDString) SetIfPresent(value *String) commentsSetParam {
	if value == nil {
		return commentsSetParam{}
	}

	return r.Set(*value)
}

func (r commentsQueryIDString) Equals(value string) commentsWithPrismaIDEqualsUniqueParam {

	return commentsWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryIDString) EqualsIfPresent(value *string) commentsWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return commentsWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r commentsQueryIDString) Order(direction SortOrder) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r commentsQueryIDString) Cursor(cursor string) commentsCursorParam {
	return commentsCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r commentsQueryIDString) In(value []string) commentsParamUnique {
	return commentsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryIDString) InIfPresent(value []string) commentsParamUnique {
	if value == nil {
		return commentsParamUnique{}
	}
	return r.In(value)
}

func (r commentsQueryIDString) NotIn(value []string) commentsParamUnique {
	return commentsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryIDString) NotInIfPresent(value []string) commentsParamUnique {
	if value == nil {
		return commentsParamUnique{}
	}
	return r.NotIn(value)
}

func (r commentsQueryIDString) Lt(value string) commentsParamUnique {
	return commentsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryIDString) LtIfPresent(value *string) commentsParamUnique {
	if value == nil {
		return commentsParamUnique{}
	}
	return r.Lt(*value)
}

func (r commentsQueryIDString) Lte(value string) commentsParamUnique {
	return commentsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryIDString) LteIfPresent(value *string) commentsParamUnique {
	if value == nil {
		return commentsParamUnique{}
	}
	return r.Lte(*value)
}

func (r commentsQueryIDString) Gt(value string) commentsParamUnique {
	return commentsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryIDString) GtIfPresent(value *string) commentsParamUnique {
	if value == nil {
		return commentsParamUnique{}
	}
	return r.Gt(*value)
}

func (r commentsQueryIDString) Gte(value string) commentsParamUnique {
	return commentsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryIDString) GteIfPresent(value *string) commentsParamUnique {
	if value == nil {
		return commentsParamUnique{}
	}
	return r.Gte(*value)
}

func (r commentsQueryIDString) Contains(value string) commentsParamUnique {
	return commentsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryIDString) ContainsIfPresent(value *string) commentsParamUnique {
	if value == nil {
		return commentsParamUnique{}
	}
	return r.Contains(*value)
}

func (r commentsQueryIDString) StartsWith(value string) commentsParamUnique {
	return commentsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryIDString) StartsWithIfPresent(value *string) commentsParamUnique {
	if value == nil {
		return commentsParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r commentsQueryIDString) EndsWith(value string) commentsParamUnique {
	return commentsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryIDString) EndsWithIfPresent(value *string) commentsParamUnique {
	if value == nil {
		return commentsParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r commentsQueryIDString) Mode(value QueryMode) commentsParamUnique {
	return commentsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryIDString) ModeIfPresent(value *QueryMode) commentsParamUnique {
	if value == nil {
		return commentsParamUnique{}
	}
	return r.Mode(*value)
}

func (r commentsQueryIDString) Not(value string) commentsParamUnique {
	return commentsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryIDString) NotIfPresent(value *string) commentsParamUnique {
	if value == nil {
		return commentsParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r commentsQueryIDString) HasPrefix(value string) commentsParamUnique {
	return commentsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r commentsQueryIDString) HasPrefixIfPresent(value *string) commentsParamUnique {
	if value == nil {
		return commentsParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r commentsQueryIDString) HasSuffix(value string) commentsParamUnique {
	return commentsParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r commentsQueryIDString) HasSuffixIfPresent(value *string) commentsParamUnique {
	if value == nil {
		return commentsParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r commentsQueryIDString) Field() commentsPrismaFields {
	return commentsFieldID
}

// base struct
type commentsQueryOwnerIDString struct{}

// Set the required value of OwnerID
func (r commentsQueryOwnerIDString) Set(value string) commentsSetParam {

	return commentsSetParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: value,
		},
	}

}

// Set the optional value of OwnerID dynamically
func (r commentsQueryOwnerIDString) SetIfPresent(value *String) commentsSetParam {
	if value == nil {
		return commentsSetParam{}
	}

	return r.Set(*value)
}

func (r commentsQueryOwnerIDString) Equals(value string) commentsWithPrismaOwnerIDEqualsParam {

	return commentsWithPrismaOwnerIDEqualsParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryOwnerIDString) EqualsIfPresent(value *string) commentsWithPrismaOwnerIDEqualsParam {
	if value == nil {
		return commentsWithPrismaOwnerIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentsQueryOwnerIDString) Order(direction SortOrder) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: direction,
		},
	}
}

func (r commentsQueryOwnerIDString) Cursor(cursor string) commentsCursorParam {
	return commentsCursorParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: cursor,
		},
	}
}

func (r commentsQueryOwnerIDString) In(value []string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryOwnerIDString) InIfPresent(value []string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.In(value)
}

func (r commentsQueryOwnerIDString) NotIn(value []string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryOwnerIDString) NotInIfPresent(value []string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentsQueryOwnerIDString) Lt(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryOwnerIDString) LtIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r commentsQueryOwnerIDString) Lte(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryOwnerIDString) LteIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r commentsQueryOwnerIDString) Gt(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryOwnerIDString) GtIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r commentsQueryOwnerIDString) Gte(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryOwnerIDString) GteIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r commentsQueryOwnerIDString) Contains(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryOwnerIDString) ContainsIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r commentsQueryOwnerIDString) StartsWith(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryOwnerIDString) StartsWithIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r commentsQueryOwnerIDString) EndsWith(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryOwnerIDString) EndsWithIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r commentsQueryOwnerIDString) Mode(value QueryMode) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryOwnerIDString) ModeIfPresent(value *QueryMode) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r commentsQueryOwnerIDString) Not(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryOwnerIDString) NotIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r commentsQueryOwnerIDString) HasPrefix(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r commentsQueryOwnerIDString) HasPrefixIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r commentsQueryOwnerIDString) HasSuffix(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r commentsQueryOwnerIDString) HasSuffixIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r commentsQueryOwnerIDString) Field() commentsPrismaFields {
	return commentsFieldOwnerID
}

// base struct
type commentsQueryRoleROLE struct{}

// Set the required value of Role
func (r commentsQueryRoleROLE) Set(value Role) commentsWithPrismaRoleSetParam {

	return commentsWithPrismaRoleSetParam{
		data: builder.Field{
			Name:  "role",
			Value: value,
		},
	}

}

// Set the optional value of Role dynamically
func (r commentsQueryRoleROLE) SetIfPresent(value *Role) commentsWithPrismaRoleSetParam {
	if value == nil {
		return commentsWithPrismaRoleSetParam{}
	}

	return r.Set(*value)
}

func (r commentsQueryRoleROLE) Equals(value Role) commentsWithPrismaRoleEqualsParam {

	return commentsWithPrismaRoleEqualsParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryRoleROLE) EqualsIfPresent(value *Role) commentsWithPrismaRoleEqualsParam {
	if value == nil {
		return commentsWithPrismaRoleEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentsQueryRoleROLE) Order(direction SortOrder) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name:  "role",
			Value: direction,
		},
	}
}

func (r commentsQueryRoleROLE) Cursor(cursor Role) commentsCursorParam {
	return commentsCursorParam{
		data: builder.Field{
			Name:  "role",
			Value: cursor,
		},
	}
}

func (r commentsQueryRoleROLE) In(value []Role) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryRoleROLE) InIfPresent(value []Role) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.In(value)
}

func (r commentsQueryRoleROLE) NotIn(value []Role) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryRoleROLE) NotInIfPresent(value []Role) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentsQueryRoleROLE) Not(value Role) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryRoleROLE) NotIfPresent(value *Role) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Not(*value)
}

func (r commentsQueryRoleROLE) Field() commentsPrismaFields {
	return commentsFieldRole
}

// base struct
type commentsQueryVideoIDString struct{}

// Set the required value of VideoID
func (r commentsQueryVideoIDString) Set(value string) commentsWithPrismaVideoIDSetParam {

	return commentsWithPrismaVideoIDSetParam{
		data: builder.Field{
			Name:  "videoId",
			Value: value,
		},
	}

}

// Set the optional value of VideoID dynamically
func (r commentsQueryVideoIDString) SetIfPresent(value *String) commentsWithPrismaVideoIDSetParam {
	if value == nil {
		return commentsWithPrismaVideoIDSetParam{}
	}

	return r.Set(*value)
}

func (r commentsQueryVideoIDString) Equals(value string) commentsWithPrismaVideoIDEqualsParam {

	return commentsWithPrismaVideoIDEqualsParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryVideoIDString) EqualsIfPresent(value *string) commentsWithPrismaVideoIDEqualsParam {
	if value == nil {
		return commentsWithPrismaVideoIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentsQueryVideoIDString) Order(direction SortOrder) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name:  "videoId",
			Value: direction,
		},
	}
}

func (r commentsQueryVideoIDString) Cursor(cursor string) commentsCursorParam {
	return commentsCursorParam{
		data: builder.Field{
			Name:  "videoId",
			Value: cursor,
		},
	}
}

func (r commentsQueryVideoIDString) In(value []string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryVideoIDString) InIfPresent(value []string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.In(value)
}

func (r commentsQueryVideoIDString) NotIn(value []string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryVideoIDString) NotInIfPresent(value []string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentsQueryVideoIDString) Lt(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryVideoIDString) LtIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r commentsQueryVideoIDString) Lte(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryVideoIDString) LteIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r commentsQueryVideoIDString) Gt(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryVideoIDString) GtIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r commentsQueryVideoIDString) Gte(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryVideoIDString) GteIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r commentsQueryVideoIDString) Contains(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryVideoIDString) ContainsIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r commentsQueryVideoIDString) StartsWith(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryVideoIDString) StartsWithIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r commentsQueryVideoIDString) EndsWith(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryVideoIDString) EndsWithIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r commentsQueryVideoIDString) Mode(value QueryMode) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryVideoIDString) ModeIfPresent(value *QueryMode) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r commentsQueryVideoIDString) Not(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryVideoIDString) NotIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r commentsQueryVideoIDString) HasPrefix(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r commentsQueryVideoIDString) HasPrefixIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r commentsQueryVideoIDString) HasSuffix(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r commentsQueryVideoIDString) HasSuffixIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r commentsQueryVideoIDString) Field() commentsPrismaFields {
	return commentsFieldVideoID
}

// base struct
type commentsQueryContentString struct{}

// Set the required value of Content
func (r commentsQueryContentString) Set(value string) commentsWithPrismaContentSetParam {

	return commentsWithPrismaContentSetParam{
		data: builder.Field{
			Name:  "content",
			Value: value,
		},
	}

}

// Set the optional value of Content dynamically
func (r commentsQueryContentString) SetIfPresent(value *String) commentsWithPrismaContentSetParam {
	if value == nil {
		return commentsWithPrismaContentSetParam{}
	}

	return r.Set(*value)
}

func (r commentsQueryContentString) Equals(value string) commentsWithPrismaContentEqualsParam {

	return commentsWithPrismaContentEqualsParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryContentString) EqualsIfPresent(value *string) commentsWithPrismaContentEqualsParam {
	if value == nil {
		return commentsWithPrismaContentEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentsQueryContentString) Order(direction SortOrder) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name:  "content",
			Value: direction,
		},
	}
}

func (r commentsQueryContentString) Cursor(cursor string) commentsCursorParam {
	return commentsCursorParam{
		data: builder.Field{
			Name:  "content",
			Value: cursor,
		},
	}
}

func (r commentsQueryContentString) In(value []string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryContentString) InIfPresent(value []string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.In(value)
}

func (r commentsQueryContentString) NotIn(value []string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryContentString) NotInIfPresent(value []string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentsQueryContentString) Lt(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryContentString) LtIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r commentsQueryContentString) Lte(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryContentString) LteIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r commentsQueryContentString) Gt(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryContentString) GtIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r commentsQueryContentString) Gte(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryContentString) GteIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r commentsQueryContentString) Contains(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryContentString) ContainsIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r commentsQueryContentString) StartsWith(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryContentString) StartsWithIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r commentsQueryContentString) EndsWith(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryContentString) EndsWithIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r commentsQueryContentString) Mode(value QueryMode) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryContentString) ModeIfPresent(value *QueryMode) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r commentsQueryContentString) Not(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryContentString) NotIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r commentsQueryContentString) HasPrefix(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r commentsQueryContentString) HasPrefixIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r commentsQueryContentString) HasSuffix(value string) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r commentsQueryContentString) HasSuffixIfPresent(value *string) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r commentsQueryContentString) Field() commentsPrismaFields {
	return commentsFieldContent
}

// base struct
type commentsQueryLikesLikes struct{}

type commentsQueryLikesRelations struct{}

// Comments -> Likes
//
// @relation
// @required
func (commentsQueryLikesRelations) Some(
	params ...LikesWhereParam,
) commentsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentsDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Comments -> Likes
//
// @relation
// @required
func (commentsQueryLikesRelations) Every(
	params ...LikesWhereParam,
) commentsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentsDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Comments -> Likes
//
// @relation
// @required
func (commentsQueryLikesRelations) None(
	params ...LikesWhereParam,
) commentsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentsDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (commentsQueryLikesRelations) Fetch(

	params ...LikesWhereParam,

) commentsToLikesFindMany {
	var v commentsToLikesFindMany

	v.query.Operation = "query"
	v.query.Method = "likes"
	v.query.Outputs = likesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r commentsQueryLikesRelations) Link(
	params ...LikesWhereParam,
) commentsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentsSetParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r commentsQueryLikesRelations) Unlink(
	params ...LikesWhereParam,
) commentsSetParam {
	var v commentsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = commentsSetParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r commentsQueryLikesLikes) Field() commentsPrismaFields {
	return commentsFieldLikes
}

// base struct
type commentsQueryOwnerUser struct{}

type commentsQueryOwnerRelations struct{}

// Comments -> Owner
//
// @relation
// @required
func (commentsQueryOwnerRelations) Where(
	params ...UserWhereParam,
) commentsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return commentsDefaultParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (commentsQueryOwnerRelations) Fetch() commentsToOwnerFindUnique {
	var v commentsToOwnerFindUnique

	v.query.Operation = "query"
	v.query.Method = "owner"
	v.query.Outputs = userOutput

	return v
}

func (r commentsQueryOwnerRelations) Link(
	params UserWhereParam,
) commentsWithPrismaOwnerSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return commentsWithPrismaOwnerSetParam{}
	}

	fields = append(fields, f)

	return commentsWithPrismaOwnerSetParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r commentsQueryOwnerRelations) Unlink() commentsWithPrismaOwnerSetParam {
	var v commentsWithPrismaOwnerSetParam

	v = commentsWithPrismaOwnerSetParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r commentsQueryOwnerUser) Field() commentsPrismaFields {
	return commentsFieldOwner
}

// base struct
type commentsQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r commentsQueryCreatedAtDateTime) Set(value DateTime) commentsSetParam {

	return commentsSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r commentsQueryCreatedAtDateTime) SetIfPresent(value *DateTime) commentsSetParam {
	if value == nil {
		return commentsSetParam{}
	}

	return r.Set(*value)
}

func (r commentsQueryCreatedAtDateTime) Equals(value DateTime) commentsWithPrismaCreatedAtEqualsParam {

	return commentsWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) commentsWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return commentsWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r commentsQueryCreatedAtDateTime) Order(direction SortOrder) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r commentsQueryCreatedAtDateTime) Cursor(cursor DateTime) commentsCursorParam {
	return commentsCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r commentsQueryCreatedAtDateTime) In(value []DateTime) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryCreatedAtDateTime) InIfPresent(value []DateTime) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.In(value)
}

func (r commentsQueryCreatedAtDateTime) NotIn(value []DateTime) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r commentsQueryCreatedAtDateTime) Lt(value DateTime) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryCreatedAtDateTime) LtIfPresent(value *DateTime) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r commentsQueryCreatedAtDateTime) Lte(value DateTime) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryCreatedAtDateTime) LteIfPresent(value *DateTime) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r commentsQueryCreatedAtDateTime) Gt(value DateTime) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryCreatedAtDateTime) GtIfPresent(value *DateTime) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r commentsQueryCreatedAtDateTime) Gte(value DateTime) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryCreatedAtDateTime) GteIfPresent(value *DateTime) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r commentsQueryCreatedAtDateTime) Not(value DateTime) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r commentsQueryCreatedAtDateTime) NotIfPresent(value *DateTime) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r commentsQueryCreatedAtDateTime) Before(value DateTime) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r commentsQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r commentsQueryCreatedAtDateTime) After(value DateTime) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r commentsQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r commentsQueryCreatedAtDateTime) BeforeEquals(value DateTime) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r commentsQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r commentsQueryCreatedAtDateTime) AfterEquals(value DateTime) commentsDefaultParam {
	return commentsDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r commentsQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) commentsDefaultParam {
	if value == nil {
		return commentsDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r commentsQueryCreatedAtDateTime) Field() commentsPrismaFields {
	return commentsFieldCreatedAt
}

// Replies acts as a namespaces to access query methods for the Replies model
var Replies = repliesQuery{}

// repliesQuery exposes query functions for the replies model
type repliesQuery struct {

	// ID
	//
	// @required
	ID repliesQueryIDString

	// OwnerID
	//
	// @required
	OwnerID repliesQueryOwnerIDString

	// Role
	//
	// @required
	Role repliesQueryRoleROLE

	// CommentID
	//
	// @optional
	CommentID repliesQueryCommentIDString

	// ReplyID
	//
	// @optional
	ReplyID repliesQueryReplyIDString

	// Content
	//
	// @required
	Content repliesQueryContentString

	Likes repliesQueryLikesRelations

	// CreatedAt
	//
	// @required
	CreatedAt repliesQueryCreatedAtDateTime

	// VideoID
	//
	// @required
	VideoID repliesQueryVideoIDString

	Owner repliesQueryOwnerRelations
}

func (repliesQuery) Not(params ...RepliesWhereParam) repliesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return repliesDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (repliesQuery) Or(params ...RepliesWhereParam) repliesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return repliesDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (repliesQuery) And(params ...RepliesWhereParam) repliesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return repliesDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type repliesQueryIDString struct{}

// Set the required value of ID
func (r repliesQueryIDString) Set(value string) repliesSetParam {

	return repliesSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r repliesQueryIDString) SetIfPresent(value *String) repliesSetParam {
	if value == nil {
		return repliesSetParam{}
	}

	return r.Set(*value)
}

func (r repliesQueryIDString) Equals(value string) repliesWithPrismaIDEqualsUniqueParam {

	return repliesWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryIDString) EqualsIfPresent(value *string) repliesWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return repliesWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r repliesQueryIDString) Order(direction SortOrder) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r repliesQueryIDString) Cursor(cursor string) repliesCursorParam {
	return repliesCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r repliesQueryIDString) In(value []string) repliesParamUnique {
	return repliesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryIDString) InIfPresent(value []string) repliesParamUnique {
	if value == nil {
		return repliesParamUnique{}
	}
	return r.In(value)
}

func (r repliesQueryIDString) NotIn(value []string) repliesParamUnique {
	return repliesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryIDString) NotInIfPresent(value []string) repliesParamUnique {
	if value == nil {
		return repliesParamUnique{}
	}
	return r.NotIn(value)
}

func (r repliesQueryIDString) Lt(value string) repliesParamUnique {
	return repliesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryIDString) LtIfPresent(value *string) repliesParamUnique {
	if value == nil {
		return repliesParamUnique{}
	}
	return r.Lt(*value)
}

func (r repliesQueryIDString) Lte(value string) repliesParamUnique {
	return repliesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryIDString) LteIfPresent(value *string) repliesParamUnique {
	if value == nil {
		return repliesParamUnique{}
	}
	return r.Lte(*value)
}

func (r repliesQueryIDString) Gt(value string) repliesParamUnique {
	return repliesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryIDString) GtIfPresent(value *string) repliesParamUnique {
	if value == nil {
		return repliesParamUnique{}
	}
	return r.Gt(*value)
}

func (r repliesQueryIDString) Gte(value string) repliesParamUnique {
	return repliesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryIDString) GteIfPresent(value *string) repliesParamUnique {
	if value == nil {
		return repliesParamUnique{}
	}
	return r.Gte(*value)
}

func (r repliesQueryIDString) Contains(value string) repliesParamUnique {
	return repliesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryIDString) ContainsIfPresent(value *string) repliesParamUnique {
	if value == nil {
		return repliesParamUnique{}
	}
	return r.Contains(*value)
}

func (r repliesQueryIDString) StartsWith(value string) repliesParamUnique {
	return repliesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryIDString) StartsWithIfPresent(value *string) repliesParamUnique {
	if value == nil {
		return repliesParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r repliesQueryIDString) EndsWith(value string) repliesParamUnique {
	return repliesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryIDString) EndsWithIfPresent(value *string) repliesParamUnique {
	if value == nil {
		return repliesParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r repliesQueryIDString) Mode(value QueryMode) repliesParamUnique {
	return repliesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryIDString) ModeIfPresent(value *QueryMode) repliesParamUnique {
	if value == nil {
		return repliesParamUnique{}
	}
	return r.Mode(*value)
}

func (r repliesQueryIDString) Not(value string) repliesParamUnique {
	return repliesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryIDString) NotIfPresent(value *string) repliesParamUnique {
	if value == nil {
		return repliesParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r repliesQueryIDString) HasPrefix(value string) repliesParamUnique {
	return repliesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r repliesQueryIDString) HasPrefixIfPresent(value *string) repliesParamUnique {
	if value == nil {
		return repliesParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r repliesQueryIDString) HasSuffix(value string) repliesParamUnique {
	return repliesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r repliesQueryIDString) HasSuffixIfPresent(value *string) repliesParamUnique {
	if value == nil {
		return repliesParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r repliesQueryIDString) Field() repliesPrismaFields {
	return repliesFieldID
}

// base struct
type repliesQueryOwnerIDString struct{}

// Set the required value of OwnerID
func (r repliesQueryOwnerIDString) Set(value string) repliesSetParam {

	return repliesSetParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: value,
		},
	}

}

// Set the optional value of OwnerID dynamically
func (r repliesQueryOwnerIDString) SetIfPresent(value *String) repliesSetParam {
	if value == nil {
		return repliesSetParam{}
	}

	return r.Set(*value)
}

func (r repliesQueryOwnerIDString) Equals(value string) repliesWithPrismaOwnerIDEqualsParam {

	return repliesWithPrismaOwnerIDEqualsParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryOwnerIDString) EqualsIfPresent(value *string) repliesWithPrismaOwnerIDEqualsParam {
	if value == nil {
		return repliesWithPrismaOwnerIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r repliesQueryOwnerIDString) Order(direction SortOrder) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: direction,
		},
	}
}

func (r repliesQueryOwnerIDString) Cursor(cursor string) repliesCursorParam {
	return repliesCursorParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: cursor,
		},
	}
}

func (r repliesQueryOwnerIDString) In(value []string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryOwnerIDString) InIfPresent(value []string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.In(value)
}

func (r repliesQueryOwnerIDString) NotIn(value []string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryOwnerIDString) NotInIfPresent(value []string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r repliesQueryOwnerIDString) Lt(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryOwnerIDString) LtIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r repliesQueryOwnerIDString) Lte(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryOwnerIDString) LteIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r repliesQueryOwnerIDString) Gt(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryOwnerIDString) GtIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r repliesQueryOwnerIDString) Gte(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryOwnerIDString) GteIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r repliesQueryOwnerIDString) Contains(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryOwnerIDString) ContainsIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r repliesQueryOwnerIDString) StartsWith(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryOwnerIDString) StartsWithIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r repliesQueryOwnerIDString) EndsWith(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryOwnerIDString) EndsWithIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r repliesQueryOwnerIDString) Mode(value QueryMode) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryOwnerIDString) ModeIfPresent(value *QueryMode) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r repliesQueryOwnerIDString) Not(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryOwnerIDString) NotIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r repliesQueryOwnerIDString) HasPrefix(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r repliesQueryOwnerIDString) HasPrefixIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r repliesQueryOwnerIDString) HasSuffix(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r repliesQueryOwnerIDString) HasSuffixIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r repliesQueryOwnerIDString) Field() repliesPrismaFields {
	return repliesFieldOwnerID
}

// base struct
type repliesQueryRoleROLE struct{}

// Set the required value of Role
func (r repliesQueryRoleROLE) Set(value Role) repliesWithPrismaRoleSetParam {

	return repliesWithPrismaRoleSetParam{
		data: builder.Field{
			Name:  "role",
			Value: value,
		},
	}

}

// Set the optional value of Role dynamically
func (r repliesQueryRoleROLE) SetIfPresent(value *Role) repliesWithPrismaRoleSetParam {
	if value == nil {
		return repliesWithPrismaRoleSetParam{}
	}

	return r.Set(*value)
}

func (r repliesQueryRoleROLE) Equals(value Role) repliesWithPrismaRoleEqualsParam {

	return repliesWithPrismaRoleEqualsParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryRoleROLE) EqualsIfPresent(value *Role) repliesWithPrismaRoleEqualsParam {
	if value == nil {
		return repliesWithPrismaRoleEqualsParam{}
	}
	return r.Equals(*value)
}

func (r repliesQueryRoleROLE) Order(direction SortOrder) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name:  "role",
			Value: direction,
		},
	}
}

func (r repliesQueryRoleROLE) Cursor(cursor Role) repliesCursorParam {
	return repliesCursorParam{
		data: builder.Field{
			Name:  "role",
			Value: cursor,
		},
	}
}

func (r repliesQueryRoleROLE) In(value []Role) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryRoleROLE) InIfPresent(value []Role) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.In(value)
}

func (r repliesQueryRoleROLE) NotIn(value []Role) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryRoleROLE) NotInIfPresent(value []Role) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r repliesQueryRoleROLE) Not(value Role) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "role",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryRoleROLE) NotIfPresent(value *Role) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Not(*value)
}

func (r repliesQueryRoleROLE) Field() repliesPrismaFields {
	return repliesFieldRole
}

// base struct
type repliesQueryCommentIDString struct{}

// Set the optional value of CommentID
func (r repliesQueryCommentIDString) Set(value string) repliesSetParam {

	return repliesSetParam{
		data: builder.Field{
			Name:  "commentId",
			Value: value,
		},
	}

}

// Set the optional value of CommentID dynamically
func (r repliesQueryCommentIDString) SetIfPresent(value *String) repliesSetParam {
	if value == nil {
		return repliesSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of CommentID dynamically
func (r repliesQueryCommentIDString) SetOptional(value *String) repliesSetParam {
	if value == nil {

		var v *string
		return repliesSetParam{
			data: builder.Field{
				Name:  "commentId",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r repliesQueryCommentIDString) Equals(value string) repliesWithPrismaCommentIDEqualsParam {

	return repliesWithPrismaCommentIDEqualsParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) EqualsIfPresent(value *string) repliesWithPrismaCommentIDEqualsParam {
	if value == nil {
		return repliesWithPrismaCommentIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r repliesQueryCommentIDString) EqualsOptional(value *String) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) IsNull() repliesDefaultParam {
	var str *string = nil
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) Order(direction SortOrder) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name:  "commentId",
			Value: direction,
		},
	}
}

func (r repliesQueryCommentIDString) Cursor(cursor string) repliesCursorParam {
	return repliesCursorParam{
		data: builder.Field{
			Name:  "commentId",
			Value: cursor,
		},
	}
}

func (r repliesQueryCommentIDString) In(value []string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) InIfPresent(value []string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.In(value)
}

func (r repliesQueryCommentIDString) NotIn(value []string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) NotInIfPresent(value []string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r repliesQueryCommentIDString) Lt(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) LtIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r repliesQueryCommentIDString) Lte(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) LteIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r repliesQueryCommentIDString) Gt(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) GtIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r repliesQueryCommentIDString) Gte(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) GteIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r repliesQueryCommentIDString) Contains(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) ContainsIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r repliesQueryCommentIDString) StartsWith(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) StartsWithIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r repliesQueryCommentIDString) EndsWith(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) EndsWithIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r repliesQueryCommentIDString) Mode(value QueryMode) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) ModeIfPresent(value *QueryMode) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r repliesQueryCommentIDString) Not(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCommentIDString) NotIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r repliesQueryCommentIDString) HasPrefix(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r repliesQueryCommentIDString) HasPrefixIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r repliesQueryCommentIDString) HasSuffix(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r repliesQueryCommentIDString) HasSuffixIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r repliesQueryCommentIDString) Field() repliesPrismaFields {
	return repliesFieldCommentID
}

// base struct
type repliesQueryReplyIDString struct{}

// Set the optional value of ReplyID
func (r repliesQueryReplyIDString) Set(value string) repliesSetParam {

	return repliesSetParam{
		data: builder.Field{
			Name:  "replyId",
			Value: value,
		},
	}

}

// Set the optional value of ReplyID dynamically
func (r repliesQueryReplyIDString) SetIfPresent(value *String) repliesSetParam {
	if value == nil {
		return repliesSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of ReplyID dynamically
func (r repliesQueryReplyIDString) SetOptional(value *String) repliesSetParam {
	if value == nil {

		var v *string
		return repliesSetParam{
			data: builder.Field{
				Name:  "replyId",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r repliesQueryReplyIDString) Equals(value string) repliesWithPrismaReplyIDEqualsParam {

	return repliesWithPrismaReplyIDEqualsParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) EqualsIfPresent(value *string) repliesWithPrismaReplyIDEqualsParam {
	if value == nil {
		return repliesWithPrismaReplyIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r repliesQueryReplyIDString) EqualsOptional(value *String) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) IsNull() repliesDefaultParam {
	var str *string = nil
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) Order(direction SortOrder) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name:  "replyId",
			Value: direction,
		},
	}
}

func (r repliesQueryReplyIDString) Cursor(cursor string) repliesCursorParam {
	return repliesCursorParam{
		data: builder.Field{
			Name:  "replyId",
			Value: cursor,
		},
	}
}

func (r repliesQueryReplyIDString) In(value []string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) InIfPresent(value []string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.In(value)
}

func (r repliesQueryReplyIDString) NotIn(value []string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) NotInIfPresent(value []string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r repliesQueryReplyIDString) Lt(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) LtIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r repliesQueryReplyIDString) Lte(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) LteIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r repliesQueryReplyIDString) Gt(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) GtIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r repliesQueryReplyIDString) Gte(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) GteIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r repliesQueryReplyIDString) Contains(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) ContainsIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r repliesQueryReplyIDString) StartsWith(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) StartsWithIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r repliesQueryReplyIDString) EndsWith(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) EndsWithIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r repliesQueryReplyIDString) Mode(value QueryMode) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) ModeIfPresent(value *QueryMode) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r repliesQueryReplyIDString) Not(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryReplyIDString) NotIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r repliesQueryReplyIDString) HasPrefix(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r repliesQueryReplyIDString) HasPrefixIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r repliesQueryReplyIDString) HasSuffix(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r repliesQueryReplyIDString) HasSuffixIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r repliesQueryReplyIDString) Field() repliesPrismaFields {
	return repliesFieldReplyID
}

// base struct
type repliesQueryContentString struct{}

// Set the required value of Content
func (r repliesQueryContentString) Set(value string) repliesWithPrismaContentSetParam {

	return repliesWithPrismaContentSetParam{
		data: builder.Field{
			Name:  "content",
			Value: value,
		},
	}

}

// Set the optional value of Content dynamically
func (r repliesQueryContentString) SetIfPresent(value *String) repliesWithPrismaContentSetParam {
	if value == nil {
		return repliesWithPrismaContentSetParam{}
	}

	return r.Set(*value)
}

func (r repliesQueryContentString) Equals(value string) repliesWithPrismaContentEqualsParam {

	return repliesWithPrismaContentEqualsParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryContentString) EqualsIfPresent(value *string) repliesWithPrismaContentEqualsParam {
	if value == nil {
		return repliesWithPrismaContentEqualsParam{}
	}
	return r.Equals(*value)
}

func (r repliesQueryContentString) Order(direction SortOrder) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name:  "content",
			Value: direction,
		},
	}
}

func (r repliesQueryContentString) Cursor(cursor string) repliesCursorParam {
	return repliesCursorParam{
		data: builder.Field{
			Name:  "content",
			Value: cursor,
		},
	}
}

func (r repliesQueryContentString) In(value []string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryContentString) InIfPresent(value []string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.In(value)
}

func (r repliesQueryContentString) NotIn(value []string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryContentString) NotInIfPresent(value []string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r repliesQueryContentString) Lt(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryContentString) LtIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r repliesQueryContentString) Lte(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryContentString) LteIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r repliesQueryContentString) Gt(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryContentString) GtIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r repliesQueryContentString) Gte(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryContentString) GteIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r repliesQueryContentString) Contains(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryContentString) ContainsIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r repliesQueryContentString) StartsWith(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryContentString) StartsWithIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r repliesQueryContentString) EndsWith(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryContentString) EndsWithIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r repliesQueryContentString) Mode(value QueryMode) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryContentString) ModeIfPresent(value *QueryMode) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r repliesQueryContentString) Not(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryContentString) NotIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r repliesQueryContentString) HasPrefix(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r repliesQueryContentString) HasPrefixIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r repliesQueryContentString) HasSuffix(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "content",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r repliesQueryContentString) HasSuffixIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r repliesQueryContentString) Field() repliesPrismaFields {
	return repliesFieldContent
}

// base struct
type repliesQueryLikesLikes struct{}

type repliesQueryLikesRelations struct{}

// Replies -> Likes
//
// @relation
// @required
func (repliesQueryLikesRelations) Some(
	params ...LikesWhereParam,
) repliesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return repliesDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Replies -> Likes
//
// @relation
// @required
func (repliesQueryLikesRelations) Every(
	params ...LikesWhereParam,
) repliesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return repliesDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Replies -> Likes
//
// @relation
// @required
func (repliesQueryLikesRelations) None(
	params ...LikesWhereParam,
) repliesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return repliesDefaultParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (repliesQueryLikesRelations) Fetch(

	params ...LikesWhereParam,

) repliesToLikesFindMany {
	var v repliesToLikesFindMany

	v.query.Operation = "query"
	v.query.Method = "likes"
	v.query.Outputs = likesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r repliesQueryLikesRelations) Link(
	params ...LikesWhereParam,
) repliesSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return repliesSetParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r repliesQueryLikesRelations) Unlink(
	params ...LikesWhereParam,
) repliesSetParam {
	var v repliesSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = repliesSetParam{
		data: builder.Field{
			Name: "likes",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r repliesQueryLikesLikes) Field() repliesPrismaFields {
	return repliesFieldLikes
}

// base struct
type repliesQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r repliesQueryCreatedAtDateTime) Set(value DateTime) repliesSetParam {

	return repliesSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r repliesQueryCreatedAtDateTime) SetIfPresent(value *DateTime) repliesSetParam {
	if value == nil {
		return repliesSetParam{}
	}

	return r.Set(*value)
}

func (r repliesQueryCreatedAtDateTime) Equals(value DateTime) repliesWithPrismaCreatedAtEqualsParam {

	return repliesWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) repliesWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return repliesWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r repliesQueryCreatedAtDateTime) Order(direction SortOrder) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r repliesQueryCreatedAtDateTime) Cursor(cursor DateTime) repliesCursorParam {
	return repliesCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r repliesQueryCreatedAtDateTime) In(value []DateTime) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCreatedAtDateTime) InIfPresent(value []DateTime) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.In(value)
}

func (r repliesQueryCreatedAtDateTime) NotIn(value []DateTime) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r repliesQueryCreatedAtDateTime) Lt(value DateTime) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCreatedAtDateTime) LtIfPresent(value *DateTime) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r repliesQueryCreatedAtDateTime) Lte(value DateTime) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCreatedAtDateTime) LteIfPresent(value *DateTime) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r repliesQueryCreatedAtDateTime) Gt(value DateTime) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCreatedAtDateTime) GtIfPresent(value *DateTime) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r repliesQueryCreatedAtDateTime) Gte(value DateTime) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCreatedAtDateTime) GteIfPresent(value *DateTime) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r repliesQueryCreatedAtDateTime) Not(value DateTime) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryCreatedAtDateTime) NotIfPresent(value *DateTime) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r repliesQueryCreatedAtDateTime) Before(value DateTime) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r repliesQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r repliesQueryCreatedAtDateTime) After(value DateTime) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r repliesQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r repliesQueryCreatedAtDateTime) BeforeEquals(value DateTime) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r repliesQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r repliesQueryCreatedAtDateTime) AfterEquals(value DateTime) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r repliesQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r repliesQueryCreatedAtDateTime) Field() repliesPrismaFields {
	return repliesFieldCreatedAt
}

// base struct
type repliesQueryVideoIDString struct{}

// Set the required value of VideoID
func (r repliesQueryVideoIDString) Set(value string) repliesWithPrismaVideoIDSetParam {

	return repliesWithPrismaVideoIDSetParam{
		data: builder.Field{
			Name:  "videoId",
			Value: value,
		},
	}

}

// Set the optional value of VideoID dynamically
func (r repliesQueryVideoIDString) SetIfPresent(value *String) repliesWithPrismaVideoIDSetParam {
	if value == nil {
		return repliesWithPrismaVideoIDSetParam{}
	}

	return r.Set(*value)
}

func (r repliesQueryVideoIDString) Equals(value string) repliesWithPrismaVideoIDEqualsParam {

	return repliesWithPrismaVideoIDEqualsParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryVideoIDString) EqualsIfPresent(value *string) repliesWithPrismaVideoIDEqualsParam {
	if value == nil {
		return repliesWithPrismaVideoIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r repliesQueryVideoIDString) Order(direction SortOrder) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name:  "videoId",
			Value: direction,
		},
	}
}

func (r repliesQueryVideoIDString) Cursor(cursor string) repliesCursorParam {
	return repliesCursorParam{
		data: builder.Field{
			Name:  "videoId",
			Value: cursor,
		},
	}
}

func (r repliesQueryVideoIDString) In(value []string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryVideoIDString) InIfPresent(value []string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.In(value)
}

func (r repliesQueryVideoIDString) NotIn(value []string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryVideoIDString) NotInIfPresent(value []string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r repliesQueryVideoIDString) Lt(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryVideoIDString) LtIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r repliesQueryVideoIDString) Lte(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryVideoIDString) LteIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r repliesQueryVideoIDString) Gt(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryVideoIDString) GtIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r repliesQueryVideoIDString) Gte(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryVideoIDString) GteIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r repliesQueryVideoIDString) Contains(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryVideoIDString) ContainsIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r repliesQueryVideoIDString) StartsWith(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryVideoIDString) StartsWithIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r repliesQueryVideoIDString) EndsWith(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryVideoIDString) EndsWithIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r repliesQueryVideoIDString) Mode(value QueryMode) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryVideoIDString) ModeIfPresent(value *QueryMode) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r repliesQueryVideoIDString) Not(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r repliesQueryVideoIDString) NotIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r repliesQueryVideoIDString) HasPrefix(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r repliesQueryVideoIDString) HasPrefixIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r repliesQueryVideoIDString) HasSuffix(value string) repliesDefaultParam {
	return repliesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r repliesQueryVideoIDString) HasSuffixIfPresent(value *string) repliesDefaultParam {
	if value == nil {
		return repliesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r repliesQueryVideoIDString) Field() repliesPrismaFields {
	return repliesFieldVideoID
}

// base struct
type repliesQueryOwnerUser struct{}

type repliesQueryOwnerRelations struct{}

// Replies -> Owner
//
// @relation
// @required
func (repliesQueryOwnerRelations) Where(
	params ...UserWhereParam,
) repliesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return repliesDefaultParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (repliesQueryOwnerRelations) Fetch() repliesToOwnerFindUnique {
	var v repliesToOwnerFindUnique

	v.query.Operation = "query"
	v.query.Method = "owner"
	v.query.Outputs = userOutput

	return v
}

func (r repliesQueryOwnerRelations) Link(
	params UserWhereParam,
) repliesWithPrismaOwnerSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return repliesWithPrismaOwnerSetParam{}
	}

	fields = append(fields, f)

	return repliesWithPrismaOwnerSetParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r repliesQueryOwnerRelations) Unlink() repliesWithPrismaOwnerSetParam {
	var v repliesWithPrismaOwnerSetParam

	v = repliesWithPrismaOwnerSetParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r repliesQueryOwnerUser) Field() repliesPrismaFields {
	return repliesFieldOwner
}

// Likes acts as a namespaces to access query methods for the Likes model
var Likes = likesQuery{}

// likesQuery exposes query functions for the likes model
type likesQuery struct {

	// ID
	//
	// @required
	ID likesQueryIDString

	// EntityType
	//
	// @required
	EntityType likesQueryEntityTypeENTITY

	// OwnerID
	//
	// @required
	OwnerID likesQueryOwnerIDString

	// VideoID
	//
	// @optional
	VideoID likesQueryVideoIDString

	// CommentID
	//
	// @optional
	CommentID likesQueryCommentIDString

	// ReplyID
	//
	// @optional
	ReplyID likesQueryReplyIDString

	Owner likesQueryOwnerRelations

	Video likesQueryVideoRelations

	Comment likesQueryCommentRelations

	Reply likesQueryReplyRelations
}

func (likesQuery) Not(params ...LikesWhereParam) likesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return likesDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (likesQuery) Or(params ...LikesWhereParam) likesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return likesDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (likesQuery) And(params ...LikesWhereParam) likesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return likesDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type likesQueryIDString struct{}

// Set the required value of ID
func (r likesQueryIDString) Set(value string) likesSetParam {

	return likesSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r likesQueryIDString) SetIfPresent(value *String) likesSetParam {
	if value == nil {
		return likesSetParam{}
	}

	return r.Set(*value)
}

func (r likesQueryIDString) Equals(value string) likesWithPrismaIDEqualsUniqueParam {

	return likesWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryIDString) EqualsIfPresent(value *string) likesWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return likesWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r likesQueryIDString) Order(direction SortOrder) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r likesQueryIDString) Cursor(cursor string) likesCursorParam {
	return likesCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r likesQueryIDString) In(value []string) likesParamUnique {
	return likesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryIDString) InIfPresent(value []string) likesParamUnique {
	if value == nil {
		return likesParamUnique{}
	}
	return r.In(value)
}

func (r likesQueryIDString) NotIn(value []string) likesParamUnique {
	return likesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryIDString) NotInIfPresent(value []string) likesParamUnique {
	if value == nil {
		return likesParamUnique{}
	}
	return r.NotIn(value)
}

func (r likesQueryIDString) Lt(value string) likesParamUnique {
	return likesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryIDString) LtIfPresent(value *string) likesParamUnique {
	if value == nil {
		return likesParamUnique{}
	}
	return r.Lt(*value)
}

func (r likesQueryIDString) Lte(value string) likesParamUnique {
	return likesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryIDString) LteIfPresent(value *string) likesParamUnique {
	if value == nil {
		return likesParamUnique{}
	}
	return r.Lte(*value)
}

func (r likesQueryIDString) Gt(value string) likesParamUnique {
	return likesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryIDString) GtIfPresent(value *string) likesParamUnique {
	if value == nil {
		return likesParamUnique{}
	}
	return r.Gt(*value)
}

func (r likesQueryIDString) Gte(value string) likesParamUnique {
	return likesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryIDString) GteIfPresent(value *string) likesParamUnique {
	if value == nil {
		return likesParamUnique{}
	}
	return r.Gte(*value)
}

func (r likesQueryIDString) Contains(value string) likesParamUnique {
	return likesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryIDString) ContainsIfPresent(value *string) likesParamUnique {
	if value == nil {
		return likesParamUnique{}
	}
	return r.Contains(*value)
}

func (r likesQueryIDString) StartsWith(value string) likesParamUnique {
	return likesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryIDString) StartsWithIfPresent(value *string) likesParamUnique {
	if value == nil {
		return likesParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r likesQueryIDString) EndsWith(value string) likesParamUnique {
	return likesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryIDString) EndsWithIfPresent(value *string) likesParamUnique {
	if value == nil {
		return likesParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r likesQueryIDString) Mode(value QueryMode) likesParamUnique {
	return likesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryIDString) ModeIfPresent(value *QueryMode) likesParamUnique {
	if value == nil {
		return likesParamUnique{}
	}
	return r.Mode(*value)
}

func (r likesQueryIDString) Not(value string) likesParamUnique {
	return likesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryIDString) NotIfPresent(value *string) likesParamUnique {
	if value == nil {
		return likesParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r likesQueryIDString) HasPrefix(value string) likesParamUnique {
	return likesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r likesQueryIDString) HasPrefixIfPresent(value *string) likesParamUnique {
	if value == nil {
		return likesParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r likesQueryIDString) HasSuffix(value string) likesParamUnique {
	return likesParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r likesQueryIDString) HasSuffixIfPresent(value *string) likesParamUnique {
	if value == nil {
		return likesParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r likesQueryIDString) Field() likesPrismaFields {
	return likesFieldID
}

// base struct
type likesQueryEntityTypeENTITY struct{}

// Set the required value of EntityType
func (r likesQueryEntityTypeENTITY) Set(value Entity) likesWithPrismaEntityTypeSetParam {

	return likesWithPrismaEntityTypeSetParam{
		data: builder.Field{
			Name:  "entityType",
			Value: value,
		},
	}

}

// Set the optional value of EntityType dynamically
func (r likesQueryEntityTypeENTITY) SetIfPresent(value *Entity) likesWithPrismaEntityTypeSetParam {
	if value == nil {
		return likesWithPrismaEntityTypeSetParam{}
	}

	return r.Set(*value)
}

func (r likesQueryEntityTypeENTITY) Equals(value Entity) likesWithPrismaEntityTypeEqualsParam {

	return likesWithPrismaEntityTypeEqualsParam{
		data: builder.Field{
			Name: "entityType",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryEntityTypeENTITY) EqualsIfPresent(value *Entity) likesWithPrismaEntityTypeEqualsParam {
	if value == nil {
		return likesWithPrismaEntityTypeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r likesQueryEntityTypeENTITY) Order(direction SortOrder) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name:  "entityType",
			Value: direction,
		},
	}
}

func (r likesQueryEntityTypeENTITY) Cursor(cursor Entity) likesCursorParam {
	return likesCursorParam{
		data: builder.Field{
			Name:  "entityType",
			Value: cursor,
		},
	}
}

func (r likesQueryEntityTypeENTITY) In(value []Entity) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "entityType",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryEntityTypeENTITY) InIfPresent(value []Entity) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.In(value)
}

func (r likesQueryEntityTypeENTITY) NotIn(value []Entity) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "entityType",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryEntityTypeENTITY) NotInIfPresent(value []Entity) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r likesQueryEntityTypeENTITY) Not(value Entity) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "entityType",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryEntityTypeENTITY) NotIfPresent(value *Entity) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Not(*value)
}

func (r likesQueryEntityTypeENTITY) Field() likesPrismaFields {
	return likesFieldEntityType
}

// base struct
type likesQueryOwnerIDString struct{}

// Set the required value of OwnerID
func (r likesQueryOwnerIDString) Set(value string) likesSetParam {

	return likesSetParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: value,
		},
	}

}

// Set the optional value of OwnerID dynamically
func (r likesQueryOwnerIDString) SetIfPresent(value *String) likesSetParam {
	if value == nil {
		return likesSetParam{}
	}

	return r.Set(*value)
}

func (r likesQueryOwnerIDString) Equals(value string) likesWithPrismaOwnerIDEqualsParam {

	return likesWithPrismaOwnerIDEqualsParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryOwnerIDString) EqualsIfPresent(value *string) likesWithPrismaOwnerIDEqualsParam {
	if value == nil {
		return likesWithPrismaOwnerIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r likesQueryOwnerIDString) Order(direction SortOrder) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: direction,
		},
	}
}

func (r likesQueryOwnerIDString) Cursor(cursor string) likesCursorParam {
	return likesCursorParam{
		data: builder.Field{
			Name:  "ownerId",
			Value: cursor,
		},
	}
}

func (r likesQueryOwnerIDString) In(value []string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryOwnerIDString) InIfPresent(value []string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.In(value)
}

func (r likesQueryOwnerIDString) NotIn(value []string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryOwnerIDString) NotInIfPresent(value []string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r likesQueryOwnerIDString) Lt(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryOwnerIDString) LtIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r likesQueryOwnerIDString) Lte(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryOwnerIDString) LteIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r likesQueryOwnerIDString) Gt(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryOwnerIDString) GtIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r likesQueryOwnerIDString) Gte(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryOwnerIDString) GteIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r likesQueryOwnerIDString) Contains(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryOwnerIDString) ContainsIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r likesQueryOwnerIDString) StartsWith(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryOwnerIDString) StartsWithIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r likesQueryOwnerIDString) EndsWith(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryOwnerIDString) EndsWithIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r likesQueryOwnerIDString) Mode(value QueryMode) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryOwnerIDString) ModeIfPresent(value *QueryMode) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r likesQueryOwnerIDString) Not(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryOwnerIDString) NotIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r likesQueryOwnerIDString) HasPrefix(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r likesQueryOwnerIDString) HasPrefixIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r likesQueryOwnerIDString) HasSuffix(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "ownerId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r likesQueryOwnerIDString) HasSuffixIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r likesQueryOwnerIDString) Field() likesPrismaFields {
	return likesFieldOwnerID
}

// base struct
type likesQueryVideoIDString struct{}

// Set the optional value of VideoID
func (r likesQueryVideoIDString) Set(value string) likesSetParam {

	return likesSetParam{
		data: builder.Field{
			Name:  "videoId",
			Value: value,
		},
	}

}

// Set the optional value of VideoID dynamically
func (r likesQueryVideoIDString) SetIfPresent(value *String) likesSetParam {
	if value == nil {
		return likesSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of VideoID dynamically
func (r likesQueryVideoIDString) SetOptional(value *String) likesSetParam {
	if value == nil {

		var v *string
		return likesSetParam{
			data: builder.Field{
				Name:  "videoId",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r likesQueryVideoIDString) Equals(value string) likesWithPrismaVideoIDEqualsParam {

	return likesWithPrismaVideoIDEqualsParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) EqualsIfPresent(value *string) likesWithPrismaVideoIDEqualsParam {
	if value == nil {
		return likesWithPrismaVideoIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r likesQueryVideoIDString) EqualsOptional(value *String) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) IsNull() likesDefaultParam {
	var str *string = nil
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) Order(direction SortOrder) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name:  "videoId",
			Value: direction,
		},
	}
}

func (r likesQueryVideoIDString) Cursor(cursor string) likesCursorParam {
	return likesCursorParam{
		data: builder.Field{
			Name:  "videoId",
			Value: cursor,
		},
	}
}

func (r likesQueryVideoIDString) In(value []string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) InIfPresent(value []string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.In(value)
}

func (r likesQueryVideoIDString) NotIn(value []string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) NotInIfPresent(value []string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r likesQueryVideoIDString) Lt(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) LtIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r likesQueryVideoIDString) Lte(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) LteIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r likesQueryVideoIDString) Gt(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) GtIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r likesQueryVideoIDString) Gte(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) GteIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r likesQueryVideoIDString) Contains(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) ContainsIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r likesQueryVideoIDString) StartsWith(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) StartsWithIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r likesQueryVideoIDString) EndsWith(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) EndsWithIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r likesQueryVideoIDString) Mode(value QueryMode) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) ModeIfPresent(value *QueryMode) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r likesQueryVideoIDString) Not(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryVideoIDString) NotIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r likesQueryVideoIDString) HasPrefix(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r likesQueryVideoIDString) HasPrefixIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r likesQueryVideoIDString) HasSuffix(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r likesQueryVideoIDString) HasSuffixIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r likesQueryVideoIDString) Field() likesPrismaFields {
	return likesFieldVideoID
}

// base struct
type likesQueryCommentIDString struct{}

// Set the optional value of CommentID
func (r likesQueryCommentIDString) Set(value string) likesSetParam {

	return likesSetParam{
		data: builder.Field{
			Name:  "commentId",
			Value: value,
		},
	}

}

// Set the optional value of CommentID dynamically
func (r likesQueryCommentIDString) SetIfPresent(value *String) likesSetParam {
	if value == nil {
		return likesSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of CommentID dynamically
func (r likesQueryCommentIDString) SetOptional(value *String) likesSetParam {
	if value == nil {

		var v *string
		return likesSetParam{
			data: builder.Field{
				Name:  "commentId",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r likesQueryCommentIDString) Equals(value string) likesWithPrismaCommentIDEqualsParam {

	return likesWithPrismaCommentIDEqualsParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) EqualsIfPresent(value *string) likesWithPrismaCommentIDEqualsParam {
	if value == nil {
		return likesWithPrismaCommentIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r likesQueryCommentIDString) EqualsOptional(value *String) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) IsNull() likesDefaultParam {
	var str *string = nil
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) Order(direction SortOrder) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name:  "commentId",
			Value: direction,
		},
	}
}

func (r likesQueryCommentIDString) Cursor(cursor string) likesCursorParam {
	return likesCursorParam{
		data: builder.Field{
			Name:  "commentId",
			Value: cursor,
		},
	}
}

func (r likesQueryCommentIDString) In(value []string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) InIfPresent(value []string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.In(value)
}

func (r likesQueryCommentIDString) NotIn(value []string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) NotInIfPresent(value []string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r likesQueryCommentIDString) Lt(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) LtIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r likesQueryCommentIDString) Lte(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) LteIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r likesQueryCommentIDString) Gt(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) GtIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r likesQueryCommentIDString) Gte(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) GteIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r likesQueryCommentIDString) Contains(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) ContainsIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r likesQueryCommentIDString) StartsWith(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) StartsWithIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r likesQueryCommentIDString) EndsWith(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) EndsWithIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r likesQueryCommentIDString) Mode(value QueryMode) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) ModeIfPresent(value *QueryMode) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r likesQueryCommentIDString) Not(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryCommentIDString) NotIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r likesQueryCommentIDString) HasPrefix(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r likesQueryCommentIDString) HasPrefixIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r likesQueryCommentIDString) HasSuffix(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "commentId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r likesQueryCommentIDString) HasSuffixIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r likesQueryCommentIDString) Field() likesPrismaFields {
	return likesFieldCommentID
}

// base struct
type likesQueryReplyIDString struct{}

// Set the optional value of ReplyID
func (r likesQueryReplyIDString) Set(value string) likesSetParam {

	return likesSetParam{
		data: builder.Field{
			Name:  "replyId",
			Value: value,
		},
	}

}

// Set the optional value of ReplyID dynamically
func (r likesQueryReplyIDString) SetIfPresent(value *String) likesSetParam {
	if value == nil {
		return likesSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of ReplyID dynamically
func (r likesQueryReplyIDString) SetOptional(value *String) likesSetParam {
	if value == nil {

		var v *string
		return likesSetParam{
			data: builder.Field{
				Name:  "replyId",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r likesQueryReplyIDString) Equals(value string) likesWithPrismaReplyIDEqualsParam {

	return likesWithPrismaReplyIDEqualsParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) EqualsIfPresent(value *string) likesWithPrismaReplyIDEqualsParam {
	if value == nil {
		return likesWithPrismaReplyIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r likesQueryReplyIDString) EqualsOptional(value *String) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) IsNull() likesDefaultParam {
	var str *string = nil
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) Order(direction SortOrder) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name:  "replyId",
			Value: direction,
		},
	}
}

func (r likesQueryReplyIDString) Cursor(cursor string) likesCursorParam {
	return likesCursorParam{
		data: builder.Field{
			Name:  "replyId",
			Value: cursor,
		},
	}
}

func (r likesQueryReplyIDString) In(value []string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) InIfPresent(value []string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.In(value)
}

func (r likesQueryReplyIDString) NotIn(value []string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) NotInIfPresent(value []string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r likesQueryReplyIDString) Lt(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) LtIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r likesQueryReplyIDString) Lte(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) LteIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r likesQueryReplyIDString) Gt(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) GtIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r likesQueryReplyIDString) Gte(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) GteIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r likesQueryReplyIDString) Contains(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) ContainsIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r likesQueryReplyIDString) StartsWith(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) StartsWithIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r likesQueryReplyIDString) EndsWith(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) EndsWithIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r likesQueryReplyIDString) Mode(value QueryMode) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) ModeIfPresent(value *QueryMode) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r likesQueryReplyIDString) Not(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r likesQueryReplyIDString) NotIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r likesQueryReplyIDString) HasPrefix(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r likesQueryReplyIDString) HasPrefixIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r likesQueryReplyIDString) HasSuffix(value string) likesDefaultParam {
	return likesDefaultParam{
		data: builder.Field{
			Name: "replyId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r likesQueryReplyIDString) HasSuffixIfPresent(value *string) likesDefaultParam {
	if value == nil {
		return likesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r likesQueryReplyIDString) Field() likesPrismaFields {
	return likesFieldReplyID
}

// base struct
type likesQueryOwnerUser struct{}

type likesQueryOwnerRelations struct{}

// Likes -> Owner
//
// @relation
// @required
func (likesQueryOwnerRelations) Where(
	params ...UserWhereParam,
) likesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return likesDefaultParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (likesQueryOwnerRelations) Fetch() likesToOwnerFindUnique {
	var v likesToOwnerFindUnique

	v.query.Operation = "query"
	v.query.Method = "owner"
	v.query.Outputs = userOutput

	return v
}

func (r likesQueryOwnerRelations) Link(
	params UserWhereParam,
) likesWithPrismaOwnerSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return likesWithPrismaOwnerSetParam{}
	}

	fields = append(fields, f)

	return likesWithPrismaOwnerSetParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r likesQueryOwnerRelations) Unlink() likesWithPrismaOwnerSetParam {
	var v likesWithPrismaOwnerSetParam

	v = likesWithPrismaOwnerSetParam{
		data: builder.Field{
			Name: "owner",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r likesQueryOwnerUser) Field() likesPrismaFields {
	return likesFieldOwner
}

// base struct
type likesQueryVideoVideos struct{}

type likesQueryVideoRelations struct{}

// Likes -> Video
//
// @relation
// @optional
func (likesQueryVideoRelations) Where(
	params ...VideosWhereParam,
) likesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return likesDefaultParam{
		data: builder.Field{
			Name: "video",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (likesQueryVideoRelations) Fetch() likesToVideoFindUnique {
	var v likesToVideoFindUnique

	v.query.Operation = "query"
	v.query.Method = "video"
	v.query.Outputs = videosOutput

	return v
}

func (r likesQueryVideoRelations) Link(
	params VideosWhereParam,
) likesSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return likesSetParam{}
	}

	fields = append(fields, f)

	return likesSetParam{
		data: builder.Field{
			Name: "video",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r likesQueryVideoRelations) Unlink() likesSetParam {
	var v likesSetParam

	v = likesSetParam{
		data: builder.Field{
			Name: "video",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r likesQueryVideoVideos) Field() likesPrismaFields {
	return likesFieldVideo
}

// base struct
type likesQueryCommentComments struct{}

type likesQueryCommentRelations struct{}

// Likes -> Comment
//
// @relation
// @optional
func (likesQueryCommentRelations) Where(
	params ...CommentsWhereParam,
) likesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return likesDefaultParam{
		data: builder.Field{
			Name: "comment",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (likesQueryCommentRelations) Fetch() likesToCommentFindUnique {
	var v likesToCommentFindUnique

	v.query.Operation = "query"
	v.query.Method = "comment"
	v.query.Outputs = commentsOutput

	return v
}

func (r likesQueryCommentRelations) Link(
	params CommentsWhereParam,
) likesSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return likesSetParam{}
	}

	fields = append(fields, f)

	return likesSetParam{
		data: builder.Field{
			Name: "comment",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r likesQueryCommentRelations) Unlink() likesSetParam {
	var v likesSetParam

	v = likesSetParam{
		data: builder.Field{
			Name: "comment",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r likesQueryCommentComments) Field() likesPrismaFields {
	return likesFieldComment
}

// base struct
type likesQueryReplyReplies struct{}

type likesQueryReplyRelations struct{}

// Likes -> Reply
//
// @relation
// @optional
func (likesQueryReplyRelations) Where(
	params ...RepliesWhereParam,
) likesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return likesDefaultParam{
		data: builder.Field{
			Name: "reply",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (likesQueryReplyRelations) Fetch() likesToReplyFindUnique {
	var v likesToReplyFindUnique

	v.query.Operation = "query"
	v.query.Method = "reply"
	v.query.Outputs = repliesOutput

	return v
}

func (r likesQueryReplyRelations) Link(
	params RepliesWhereParam,
) likesSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return likesSetParam{}
	}

	fields = append(fields, f)

	return likesSetParam{
		data: builder.Field{
			Name: "reply",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r likesQueryReplyRelations) Unlink() likesSetParam {
	var v likesSetParam

	v = likesSetParam{
		data: builder.Field{
			Name: "reply",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r likesQueryReplyReplies) Field() likesPrismaFields {
	return likesFieldReply
}

// History acts as a namespaces to access query methods for the History model
var History = historyQuery{}

// historyQuery exposes query functions for the history model
type historyQuery struct {

	// ID
	//
	// @required
	ID historyQueryIDString

	// UserID
	//
	// @required
	UserID historyQueryUserIDString

	// VideoID
	//
	// @required
	VideoID historyQueryVideoIDString

	Video historyQueryVideoRelations

	// ViewedAt
	//
	// @required
	ViewedAt historyQueryViewedAtDateTime
}

func (historyQuery) Not(params ...HistoryWhereParam) historyDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return historyDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (historyQuery) Or(params ...HistoryWhereParam) historyDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return historyDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (historyQuery) And(params ...HistoryWhereParam) historyDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return historyDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type historyQueryIDString struct{}

// Set the required value of ID
func (r historyQueryIDString) Set(value string) historySetParam {

	return historySetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r historyQueryIDString) SetIfPresent(value *String) historySetParam {
	if value == nil {
		return historySetParam{}
	}

	return r.Set(*value)
}

func (r historyQueryIDString) Equals(value string) historyWithPrismaIDEqualsUniqueParam {

	return historyWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryIDString) EqualsIfPresent(value *string) historyWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return historyWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r historyQueryIDString) Order(direction SortOrder) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r historyQueryIDString) Cursor(cursor string) historyCursorParam {
	return historyCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r historyQueryIDString) In(value []string) historyParamUnique {
	return historyParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryIDString) InIfPresent(value []string) historyParamUnique {
	if value == nil {
		return historyParamUnique{}
	}
	return r.In(value)
}

func (r historyQueryIDString) NotIn(value []string) historyParamUnique {
	return historyParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryIDString) NotInIfPresent(value []string) historyParamUnique {
	if value == nil {
		return historyParamUnique{}
	}
	return r.NotIn(value)
}

func (r historyQueryIDString) Lt(value string) historyParamUnique {
	return historyParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryIDString) LtIfPresent(value *string) historyParamUnique {
	if value == nil {
		return historyParamUnique{}
	}
	return r.Lt(*value)
}

func (r historyQueryIDString) Lte(value string) historyParamUnique {
	return historyParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryIDString) LteIfPresent(value *string) historyParamUnique {
	if value == nil {
		return historyParamUnique{}
	}
	return r.Lte(*value)
}

func (r historyQueryIDString) Gt(value string) historyParamUnique {
	return historyParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryIDString) GtIfPresent(value *string) historyParamUnique {
	if value == nil {
		return historyParamUnique{}
	}
	return r.Gt(*value)
}

func (r historyQueryIDString) Gte(value string) historyParamUnique {
	return historyParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryIDString) GteIfPresent(value *string) historyParamUnique {
	if value == nil {
		return historyParamUnique{}
	}
	return r.Gte(*value)
}

func (r historyQueryIDString) Contains(value string) historyParamUnique {
	return historyParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryIDString) ContainsIfPresent(value *string) historyParamUnique {
	if value == nil {
		return historyParamUnique{}
	}
	return r.Contains(*value)
}

func (r historyQueryIDString) StartsWith(value string) historyParamUnique {
	return historyParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryIDString) StartsWithIfPresent(value *string) historyParamUnique {
	if value == nil {
		return historyParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r historyQueryIDString) EndsWith(value string) historyParamUnique {
	return historyParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryIDString) EndsWithIfPresent(value *string) historyParamUnique {
	if value == nil {
		return historyParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r historyQueryIDString) Mode(value QueryMode) historyParamUnique {
	return historyParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryIDString) ModeIfPresent(value *QueryMode) historyParamUnique {
	if value == nil {
		return historyParamUnique{}
	}
	return r.Mode(*value)
}

func (r historyQueryIDString) Not(value string) historyParamUnique {
	return historyParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryIDString) NotIfPresent(value *string) historyParamUnique {
	if value == nil {
		return historyParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r historyQueryIDString) HasPrefix(value string) historyParamUnique {
	return historyParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r historyQueryIDString) HasPrefixIfPresent(value *string) historyParamUnique {
	if value == nil {
		return historyParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r historyQueryIDString) HasSuffix(value string) historyParamUnique {
	return historyParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r historyQueryIDString) HasSuffixIfPresent(value *string) historyParamUnique {
	if value == nil {
		return historyParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r historyQueryIDString) Field() historyPrismaFields {
	return historyFieldID
}

// base struct
type historyQueryUserIDString struct{}

// Set the required value of UserID
func (r historyQueryUserIDString) Set(value string) historyWithPrismaUserIDSetParam {

	return historyWithPrismaUserIDSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r historyQueryUserIDString) SetIfPresent(value *String) historyWithPrismaUserIDSetParam {
	if value == nil {
		return historyWithPrismaUserIDSetParam{}
	}

	return r.Set(*value)
}

func (r historyQueryUserIDString) Equals(value string) historyWithPrismaUserIDEqualsParam {

	return historyWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryUserIDString) EqualsIfPresent(value *string) historyWithPrismaUserIDEqualsParam {
	if value == nil {
		return historyWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r historyQueryUserIDString) Order(direction SortOrder) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r historyQueryUserIDString) Cursor(cursor string) historyCursorParam {
	return historyCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r historyQueryUserIDString) In(value []string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryUserIDString) InIfPresent(value []string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.In(value)
}

func (r historyQueryUserIDString) NotIn(value []string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryUserIDString) NotInIfPresent(value []string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.NotIn(value)
}

func (r historyQueryUserIDString) Lt(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryUserIDString) LtIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Lt(*value)
}

func (r historyQueryUserIDString) Lte(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryUserIDString) LteIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Lte(*value)
}

func (r historyQueryUserIDString) Gt(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryUserIDString) GtIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Gt(*value)
}

func (r historyQueryUserIDString) Gte(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryUserIDString) GteIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Gte(*value)
}

func (r historyQueryUserIDString) Contains(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryUserIDString) ContainsIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Contains(*value)
}

func (r historyQueryUserIDString) StartsWith(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryUserIDString) StartsWithIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r historyQueryUserIDString) EndsWith(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryUserIDString) EndsWithIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r historyQueryUserIDString) Mode(value QueryMode) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryUserIDString) ModeIfPresent(value *QueryMode) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Mode(*value)
}

func (r historyQueryUserIDString) Not(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryUserIDString) NotIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r historyQueryUserIDString) HasPrefix(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r historyQueryUserIDString) HasPrefixIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r historyQueryUserIDString) HasSuffix(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r historyQueryUserIDString) HasSuffixIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r historyQueryUserIDString) Field() historyPrismaFields {
	return historyFieldUserID
}

// base struct
type historyQueryVideoIDString struct{}

// Set the required value of VideoID
func (r historyQueryVideoIDString) Set(value string) historySetParam {

	return historySetParam{
		data: builder.Field{
			Name:  "videoId",
			Value: value,
		},
	}

}

// Set the optional value of VideoID dynamically
func (r historyQueryVideoIDString) SetIfPresent(value *String) historySetParam {
	if value == nil {
		return historySetParam{}
	}

	return r.Set(*value)
}

func (r historyQueryVideoIDString) Equals(value string) historyWithPrismaVideoIDEqualsParam {

	return historyWithPrismaVideoIDEqualsParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryVideoIDString) EqualsIfPresent(value *string) historyWithPrismaVideoIDEqualsParam {
	if value == nil {
		return historyWithPrismaVideoIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r historyQueryVideoIDString) Order(direction SortOrder) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name:  "videoId",
			Value: direction,
		},
	}
}

func (r historyQueryVideoIDString) Cursor(cursor string) historyCursorParam {
	return historyCursorParam{
		data: builder.Field{
			Name:  "videoId",
			Value: cursor,
		},
	}
}

func (r historyQueryVideoIDString) In(value []string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryVideoIDString) InIfPresent(value []string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.In(value)
}

func (r historyQueryVideoIDString) NotIn(value []string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryVideoIDString) NotInIfPresent(value []string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.NotIn(value)
}

func (r historyQueryVideoIDString) Lt(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryVideoIDString) LtIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Lt(*value)
}

func (r historyQueryVideoIDString) Lte(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryVideoIDString) LteIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Lte(*value)
}

func (r historyQueryVideoIDString) Gt(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryVideoIDString) GtIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Gt(*value)
}

func (r historyQueryVideoIDString) Gte(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryVideoIDString) GteIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Gte(*value)
}

func (r historyQueryVideoIDString) Contains(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryVideoIDString) ContainsIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Contains(*value)
}

func (r historyQueryVideoIDString) StartsWith(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryVideoIDString) StartsWithIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r historyQueryVideoIDString) EndsWith(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryVideoIDString) EndsWithIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r historyQueryVideoIDString) Mode(value QueryMode) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryVideoIDString) ModeIfPresent(value *QueryMode) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Mode(*value)
}

func (r historyQueryVideoIDString) Not(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryVideoIDString) NotIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r historyQueryVideoIDString) HasPrefix(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r historyQueryVideoIDString) HasPrefixIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r historyQueryVideoIDString) HasSuffix(value string) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r historyQueryVideoIDString) HasSuffixIfPresent(value *string) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r historyQueryVideoIDString) Field() historyPrismaFields {
	return historyFieldVideoID
}

// base struct
type historyQueryVideoVideos struct{}

type historyQueryVideoRelations struct{}

// History -> Video
//
// @relation
// @required
func (historyQueryVideoRelations) Where(
	params ...VideosWhereParam,
) historyDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return historyDefaultParam{
		data: builder.Field{
			Name: "video",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (historyQueryVideoRelations) Fetch() historyToVideoFindUnique {
	var v historyToVideoFindUnique

	v.query.Operation = "query"
	v.query.Method = "video"
	v.query.Outputs = videosOutput

	return v
}

func (r historyQueryVideoRelations) Link(
	params VideosWhereParam,
) historyWithPrismaVideoSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return historyWithPrismaVideoSetParam{}
	}

	fields = append(fields, f)

	return historyWithPrismaVideoSetParam{
		data: builder.Field{
			Name: "video",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r historyQueryVideoRelations) Unlink() historyWithPrismaVideoSetParam {
	var v historyWithPrismaVideoSetParam

	v = historyWithPrismaVideoSetParam{
		data: builder.Field{
			Name: "video",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r historyQueryVideoVideos) Field() historyPrismaFields {
	return historyFieldVideo
}

// base struct
type historyQueryViewedAtDateTime struct{}

// Set the required value of ViewedAt
func (r historyQueryViewedAtDateTime) Set(value DateTime) historySetParam {

	return historySetParam{
		data: builder.Field{
			Name:  "viewedAt",
			Value: value,
		},
	}

}

// Set the optional value of ViewedAt dynamically
func (r historyQueryViewedAtDateTime) SetIfPresent(value *DateTime) historySetParam {
	if value == nil {
		return historySetParam{}
	}

	return r.Set(*value)
}

func (r historyQueryViewedAtDateTime) Equals(value DateTime) historyWithPrismaViewedAtEqualsParam {

	return historyWithPrismaViewedAtEqualsParam{
		data: builder.Field{
			Name: "viewedAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryViewedAtDateTime) EqualsIfPresent(value *DateTime) historyWithPrismaViewedAtEqualsParam {
	if value == nil {
		return historyWithPrismaViewedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r historyQueryViewedAtDateTime) Order(direction SortOrder) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name:  "viewedAt",
			Value: direction,
		},
	}
}

func (r historyQueryViewedAtDateTime) Cursor(cursor DateTime) historyCursorParam {
	return historyCursorParam{
		data: builder.Field{
			Name:  "viewedAt",
			Value: cursor,
		},
	}
}

func (r historyQueryViewedAtDateTime) In(value []DateTime) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "viewedAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryViewedAtDateTime) InIfPresent(value []DateTime) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.In(value)
}

func (r historyQueryViewedAtDateTime) NotIn(value []DateTime) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "viewedAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryViewedAtDateTime) NotInIfPresent(value []DateTime) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.NotIn(value)
}

func (r historyQueryViewedAtDateTime) Lt(value DateTime) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "viewedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryViewedAtDateTime) LtIfPresent(value *DateTime) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Lt(*value)
}

func (r historyQueryViewedAtDateTime) Lte(value DateTime) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "viewedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryViewedAtDateTime) LteIfPresent(value *DateTime) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Lte(*value)
}

func (r historyQueryViewedAtDateTime) Gt(value DateTime) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "viewedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryViewedAtDateTime) GtIfPresent(value *DateTime) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Gt(*value)
}

func (r historyQueryViewedAtDateTime) Gte(value DateTime) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "viewedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryViewedAtDateTime) GteIfPresent(value *DateTime) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Gte(*value)
}

func (r historyQueryViewedAtDateTime) Not(value DateTime) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "viewedAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r historyQueryViewedAtDateTime) NotIfPresent(value *DateTime) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r historyQueryViewedAtDateTime) Before(value DateTime) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "viewedAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r historyQueryViewedAtDateTime) BeforeIfPresent(value *DateTime) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r historyQueryViewedAtDateTime) After(value DateTime) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "viewedAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r historyQueryViewedAtDateTime) AfterIfPresent(value *DateTime) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r historyQueryViewedAtDateTime) BeforeEquals(value DateTime) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "viewedAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r historyQueryViewedAtDateTime) BeforeEqualsIfPresent(value *DateTime) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r historyQueryViewedAtDateTime) AfterEquals(value DateTime) historyDefaultParam {
	return historyDefaultParam{
		data: builder.Field{
			Name: "viewedAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r historyQueryViewedAtDateTime) AfterEqualsIfPresent(value *DateTime) historyDefaultParam {
	if value == nil {
		return historyDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r historyQueryViewedAtDateTime) Field() historyPrismaFields {
	return historyFieldViewedAt
}

// WatchLater acts as a namespaces to access query methods for the WatchLater model
var WatchLater = watchLaterQuery{}

// watchLaterQuery exposes query functions for the watchLater model
type watchLaterQuery struct {

	// ID
	//
	// @required
	ID watchLaterQueryIDString

	// UserID
	//
	// @required
	UserID watchLaterQueryUserIDString

	// VideoID
	//
	// @required
	VideoID watchLaterQueryVideoIDString

	Video watchLaterQueryVideoRelations

	// CreatedAt
	//
	// @required
	CreatedAt watchLaterQueryCreatedAtDateTime
}

func (watchLaterQuery) Not(params ...WatchLaterWhereParam) watchLaterDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return watchLaterDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (watchLaterQuery) Or(params ...WatchLaterWhereParam) watchLaterDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return watchLaterDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (watchLaterQuery) And(params ...WatchLaterWhereParam) watchLaterDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return watchLaterDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type watchLaterQueryIDString struct{}

// Set the required value of ID
func (r watchLaterQueryIDString) Set(value string) watchLaterSetParam {

	return watchLaterSetParam{
		data: builder.Field{
			Name:  "id",
			Value: value,
		},
	}

}

// Set the optional value of ID dynamically
func (r watchLaterQueryIDString) SetIfPresent(value *String) watchLaterSetParam {
	if value == nil {
		return watchLaterSetParam{}
	}

	return r.Set(*value)
}

func (r watchLaterQueryIDString) Equals(value string) watchLaterWithPrismaIDEqualsUniqueParam {

	return watchLaterWithPrismaIDEqualsUniqueParam{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryIDString) EqualsIfPresent(value *string) watchLaterWithPrismaIDEqualsUniqueParam {
	if value == nil {
		return watchLaterWithPrismaIDEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r watchLaterQueryIDString) Order(direction SortOrder) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name:  "id",
			Value: direction,
		},
	}
}

func (r watchLaterQueryIDString) Cursor(cursor string) watchLaterCursorParam {
	return watchLaterCursorParam{
		data: builder.Field{
			Name:  "id",
			Value: cursor,
		},
	}
}

func (r watchLaterQueryIDString) In(value []string) watchLaterParamUnique {
	return watchLaterParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryIDString) InIfPresent(value []string) watchLaterParamUnique {
	if value == nil {
		return watchLaterParamUnique{}
	}
	return r.In(value)
}

func (r watchLaterQueryIDString) NotIn(value []string) watchLaterParamUnique {
	return watchLaterParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryIDString) NotInIfPresent(value []string) watchLaterParamUnique {
	if value == nil {
		return watchLaterParamUnique{}
	}
	return r.NotIn(value)
}

func (r watchLaterQueryIDString) Lt(value string) watchLaterParamUnique {
	return watchLaterParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryIDString) LtIfPresent(value *string) watchLaterParamUnique {
	if value == nil {
		return watchLaterParamUnique{}
	}
	return r.Lt(*value)
}

func (r watchLaterQueryIDString) Lte(value string) watchLaterParamUnique {
	return watchLaterParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryIDString) LteIfPresent(value *string) watchLaterParamUnique {
	if value == nil {
		return watchLaterParamUnique{}
	}
	return r.Lte(*value)
}

func (r watchLaterQueryIDString) Gt(value string) watchLaterParamUnique {
	return watchLaterParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryIDString) GtIfPresent(value *string) watchLaterParamUnique {
	if value == nil {
		return watchLaterParamUnique{}
	}
	return r.Gt(*value)
}

func (r watchLaterQueryIDString) Gte(value string) watchLaterParamUnique {
	return watchLaterParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryIDString) GteIfPresent(value *string) watchLaterParamUnique {
	if value == nil {
		return watchLaterParamUnique{}
	}
	return r.Gte(*value)
}

func (r watchLaterQueryIDString) Contains(value string) watchLaterParamUnique {
	return watchLaterParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryIDString) ContainsIfPresent(value *string) watchLaterParamUnique {
	if value == nil {
		return watchLaterParamUnique{}
	}
	return r.Contains(*value)
}

func (r watchLaterQueryIDString) StartsWith(value string) watchLaterParamUnique {
	return watchLaterParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryIDString) StartsWithIfPresent(value *string) watchLaterParamUnique {
	if value == nil {
		return watchLaterParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r watchLaterQueryIDString) EndsWith(value string) watchLaterParamUnique {
	return watchLaterParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryIDString) EndsWithIfPresent(value *string) watchLaterParamUnique {
	if value == nil {
		return watchLaterParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r watchLaterQueryIDString) Mode(value QueryMode) watchLaterParamUnique {
	return watchLaterParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryIDString) ModeIfPresent(value *QueryMode) watchLaterParamUnique {
	if value == nil {
		return watchLaterParamUnique{}
	}
	return r.Mode(*value)
}

func (r watchLaterQueryIDString) Not(value string) watchLaterParamUnique {
	return watchLaterParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryIDString) NotIfPresent(value *string) watchLaterParamUnique {
	if value == nil {
		return watchLaterParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r watchLaterQueryIDString) HasPrefix(value string) watchLaterParamUnique {
	return watchLaterParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r watchLaterQueryIDString) HasPrefixIfPresent(value *string) watchLaterParamUnique {
	if value == nil {
		return watchLaterParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r watchLaterQueryIDString) HasSuffix(value string) watchLaterParamUnique {
	return watchLaterParamUnique{
		data: builder.Field{
			Name: "id",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r watchLaterQueryIDString) HasSuffixIfPresent(value *string) watchLaterParamUnique {
	if value == nil {
		return watchLaterParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r watchLaterQueryIDString) Field() watchLaterPrismaFields {
	return watchLaterFieldID
}

// base struct
type watchLaterQueryUserIDString struct{}

// Set the required value of UserID
func (r watchLaterQueryUserIDString) Set(value string) watchLaterWithPrismaUserIDSetParam {

	return watchLaterWithPrismaUserIDSetParam{
		data: builder.Field{
			Name:  "userId",
			Value: value,
		},
	}

}

// Set the optional value of UserID dynamically
func (r watchLaterQueryUserIDString) SetIfPresent(value *String) watchLaterWithPrismaUserIDSetParam {
	if value == nil {
		return watchLaterWithPrismaUserIDSetParam{}
	}

	return r.Set(*value)
}

func (r watchLaterQueryUserIDString) Equals(value string) watchLaterWithPrismaUserIDEqualsParam {

	return watchLaterWithPrismaUserIDEqualsParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryUserIDString) EqualsIfPresent(value *string) watchLaterWithPrismaUserIDEqualsParam {
	if value == nil {
		return watchLaterWithPrismaUserIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r watchLaterQueryUserIDString) Order(direction SortOrder) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name:  "userId",
			Value: direction,
		},
	}
}

func (r watchLaterQueryUserIDString) Cursor(cursor string) watchLaterCursorParam {
	return watchLaterCursorParam{
		data: builder.Field{
			Name:  "userId",
			Value: cursor,
		},
	}
}

func (r watchLaterQueryUserIDString) In(value []string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryUserIDString) InIfPresent(value []string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.In(value)
}

func (r watchLaterQueryUserIDString) NotIn(value []string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryUserIDString) NotInIfPresent(value []string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.NotIn(value)
}

func (r watchLaterQueryUserIDString) Lt(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryUserIDString) LtIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Lt(*value)
}

func (r watchLaterQueryUserIDString) Lte(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryUserIDString) LteIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Lte(*value)
}

func (r watchLaterQueryUserIDString) Gt(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryUserIDString) GtIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Gt(*value)
}

func (r watchLaterQueryUserIDString) Gte(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryUserIDString) GteIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Gte(*value)
}

func (r watchLaterQueryUserIDString) Contains(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryUserIDString) ContainsIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Contains(*value)
}

func (r watchLaterQueryUserIDString) StartsWith(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryUserIDString) StartsWithIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r watchLaterQueryUserIDString) EndsWith(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryUserIDString) EndsWithIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r watchLaterQueryUserIDString) Mode(value QueryMode) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryUserIDString) ModeIfPresent(value *QueryMode) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Mode(*value)
}

func (r watchLaterQueryUserIDString) Not(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryUserIDString) NotIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r watchLaterQueryUserIDString) HasPrefix(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r watchLaterQueryUserIDString) HasPrefixIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r watchLaterQueryUserIDString) HasSuffix(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "userId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r watchLaterQueryUserIDString) HasSuffixIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r watchLaterQueryUserIDString) Field() watchLaterPrismaFields {
	return watchLaterFieldUserID
}

// base struct
type watchLaterQueryVideoIDString struct{}

// Set the required value of VideoID
func (r watchLaterQueryVideoIDString) Set(value string) watchLaterSetParam {

	return watchLaterSetParam{
		data: builder.Field{
			Name:  "videoId",
			Value: value,
		},
	}

}

// Set the optional value of VideoID dynamically
func (r watchLaterQueryVideoIDString) SetIfPresent(value *String) watchLaterSetParam {
	if value == nil {
		return watchLaterSetParam{}
	}

	return r.Set(*value)
}

func (r watchLaterQueryVideoIDString) Equals(value string) watchLaterWithPrismaVideoIDEqualsParam {

	return watchLaterWithPrismaVideoIDEqualsParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryVideoIDString) EqualsIfPresent(value *string) watchLaterWithPrismaVideoIDEqualsParam {
	if value == nil {
		return watchLaterWithPrismaVideoIDEqualsParam{}
	}
	return r.Equals(*value)
}

func (r watchLaterQueryVideoIDString) Order(direction SortOrder) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name:  "videoId",
			Value: direction,
		},
	}
}

func (r watchLaterQueryVideoIDString) Cursor(cursor string) watchLaterCursorParam {
	return watchLaterCursorParam{
		data: builder.Field{
			Name:  "videoId",
			Value: cursor,
		},
	}
}

func (r watchLaterQueryVideoIDString) In(value []string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryVideoIDString) InIfPresent(value []string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.In(value)
}

func (r watchLaterQueryVideoIDString) NotIn(value []string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryVideoIDString) NotInIfPresent(value []string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.NotIn(value)
}

func (r watchLaterQueryVideoIDString) Lt(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryVideoIDString) LtIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Lt(*value)
}

func (r watchLaterQueryVideoIDString) Lte(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryVideoIDString) LteIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Lte(*value)
}

func (r watchLaterQueryVideoIDString) Gt(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryVideoIDString) GtIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Gt(*value)
}

func (r watchLaterQueryVideoIDString) Gte(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryVideoIDString) GteIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Gte(*value)
}

func (r watchLaterQueryVideoIDString) Contains(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryVideoIDString) ContainsIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Contains(*value)
}

func (r watchLaterQueryVideoIDString) StartsWith(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryVideoIDString) StartsWithIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r watchLaterQueryVideoIDString) EndsWith(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryVideoIDString) EndsWithIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r watchLaterQueryVideoIDString) Mode(value QueryMode) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryVideoIDString) ModeIfPresent(value *QueryMode) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Mode(*value)
}

func (r watchLaterQueryVideoIDString) Not(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryVideoIDString) NotIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r watchLaterQueryVideoIDString) HasPrefix(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r watchLaterQueryVideoIDString) HasPrefixIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r watchLaterQueryVideoIDString) HasSuffix(value string) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "videoId",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r watchLaterQueryVideoIDString) HasSuffixIfPresent(value *string) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r watchLaterQueryVideoIDString) Field() watchLaterPrismaFields {
	return watchLaterFieldVideoID
}

// base struct
type watchLaterQueryVideoVideos struct{}

type watchLaterQueryVideoRelations struct{}

// WatchLater -> Video
//
// @relation
// @required
func (watchLaterQueryVideoRelations) Where(
	params ...VideosWhereParam,
) watchLaterDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "video",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (watchLaterQueryVideoRelations) Fetch() watchLaterToVideoFindUnique {
	var v watchLaterToVideoFindUnique

	v.query.Operation = "query"
	v.query.Method = "video"
	v.query.Outputs = videosOutput

	return v
}

func (r watchLaterQueryVideoRelations) Link(
	params VideosWhereParam,
) watchLaterWithPrismaVideoSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return watchLaterWithPrismaVideoSetParam{}
	}

	fields = append(fields, f)

	return watchLaterWithPrismaVideoSetParam{
		data: builder.Field{
			Name: "video",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r watchLaterQueryVideoRelations) Unlink() watchLaterWithPrismaVideoSetParam {
	var v watchLaterWithPrismaVideoSetParam

	v = watchLaterWithPrismaVideoSetParam{
		data: builder.Field{
			Name: "video",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r watchLaterQueryVideoVideos) Field() watchLaterPrismaFields {
	return watchLaterFieldVideo
}

// base struct
type watchLaterQueryCreatedAtDateTime struct{}

// Set the required value of CreatedAt
func (r watchLaterQueryCreatedAtDateTime) Set(value DateTime) watchLaterSetParam {

	return watchLaterSetParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: value,
		},
	}

}

// Set the optional value of CreatedAt dynamically
func (r watchLaterQueryCreatedAtDateTime) SetIfPresent(value *DateTime) watchLaterSetParam {
	if value == nil {
		return watchLaterSetParam{}
	}

	return r.Set(*value)
}

func (r watchLaterQueryCreatedAtDateTime) Equals(value DateTime) watchLaterWithPrismaCreatedAtEqualsParam {

	return watchLaterWithPrismaCreatedAtEqualsParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryCreatedAtDateTime) EqualsIfPresent(value *DateTime) watchLaterWithPrismaCreatedAtEqualsParam {
	if value == nil {
		return watchLaterWithPrismaCreatedAtEqualsParam{}
	}
	return r.Equals(*value)
}

func (r watchLaterQueryCreatedAtDateTime) Order(direction SortOrder) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: direction,
		},
	}
}

func (r watchLaterQueryCreatedAtDateTime) Cursor(cursor DateTime) watchLaterCursorParam {
	return watchLaterCursorParam{
		data: builder.Field{
			Name:  "createdAt",
			Value: cursor,
		},
	}
}

func (r watchLaterQueryCreatedAtDateTime) In(value []DateTime) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryCreatedAtDateTime) InIfPresent(value []DateTime) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.In(value)
}

func (r watchLaterQueryCreatedAtDateTime) NotIn(value []DateTime) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryCreatedAtDateTime) NotInIfPresent(value []DateTime) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.NotIn(value)
}

func (r watchLaterQueryCreatedAtDateTime) Lt(value DateTime) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryCreatedAtDateTime) LtIfPresent(value *DateTime) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Lt(*value)
}

func (r watchLaterQueryCreatedAtDateTime) Lte(value DateTime) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryCreatedAtDateTime) LteIfPresent(value *DateTime) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Lte(*value)
}

func (r watchLaterQueryCreatedAtDateTime) Gt(value DateTime) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryCreatedAtDateTime) GtIfPresent(value *DateTime) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Gt(*value)
}

func (r watchLaterQueryCreatedAtDateTime) Gte(value DateTime) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryCreatedAtDateTime) GteIfPresent(value *DateTime) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Gte(*value)
}

func (r watchLaterQueryCreatedAtDateTime) Not(value DateTime) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r watchLaterQueryCreatedAtDateTime) NotIfPresent(value *DateTime) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use Lt instead.

func (r watchLaterQueryCreatedAtDateTime) Before(value DateTime) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LtIfPresent instead.
func (r watchLaterQueryCreatedAtDateTime) BeforeIfPresent(value *DateTime) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.Before(*value)
}

// deprecated: Use Gt instead.

func (r watchLaterQueryCreatedAtDateTime) After(value DateTime) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GtIfPresent instead.
func (r watchLaterQueryCreatedAtDateTime) AfterIfPresent(value *DateTime) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.After(*value)
}

// deprecated: Use Lte instead.

func (r watchLaterQueryCreatedAtDateTime) BeforeEquals(value DateTime) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use LteIfPresent instead.
func (r watchLaterQueryCreatedAtDateTime) BeforeEqualsIfPresent(value *DateTime) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.BeforeEquals(*value)
}

// deprecated: Use Gte instead.

func (r watchLaterQueryCreatedAtDateTime) AfterEquals(value DateTime) watchLaterDefaultParam {
	return watchLaterDefaultParam{
		data: builder.Field{
			Name: "createdAt",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use GteIfPresent instead.
func (r watchLaterQueryCreatedAtDateTime) AfterEqualsIfPresent(value *DateTime) watchLaterDefaultParam {
	if value == nil {
		return watchLaterDefaultParam{}
	}
	return r.AfterEquals(*value)
}

func (r watchLaterQueryCreatedAtDateTime) Field() watchLaterPrismaFields {
	return watchLaterFieldCreatedAt
}

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type userActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var userOutput = []builder.Output{
	{Name: "id"},
	{Name: "fullname"},
	{Name: "email"},
	{Name: "password"},
	{Name: "dob"},
	{Name: "avatar"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
	{Name: "isVerified"},
}

type UserRelationWith interface {
	getQuery() builder.Query
	with()
	userRelation()
}

type UserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p userDefaultParam) field() builder.Field {
	return p.data
}

func (p userDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p userDefaultParam) userModel() {}

type UserOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
}

type userOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p userOrderByParam) field() builder.Field {
	return p.data
}

func (p userOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p userOrderByParam) userModel() {}

type UserCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	isCursor()
}

type userCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p userCursorParam) field() builder.Field {
	return p.data
}

func (p userCursorParam) isCursor() {}

func (p userCursorParam) getQuery() builder.Query {
	return p.query
}

func (p userCursorParam) userModel() {}

type UserParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	userModel()
}

type userParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p userParamUnique) userModel() {}

func (userParamUnique) unique() {}

func (p userParamUnique) field() builder.Field {
	return p.data
}

func (p userParamUnique) getQuery() builder.Query {
	return p.query
}

type UserEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
}

type userEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsParam) userModel() {}

func (userEqualsParam) equals() {}

func (p userEqualsParam) field() builder.Field {
	return p.data
}

func (p userEqualsParam) getQuery() builder.Query {
	return p.query
}

type UserEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	userModel()
}

type userEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userEqualsUniqueParam) userModel() {}

func (userEqualsUniqueParam) unique() {}
func (userEqualsUniqueParam) equals() {}

func (p userEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UserSetParam interface {
	field() builder.Field
	settable()
	userModel()
}

type userSetParam struct {
	data builder.Field
}

func (userSetParam) settable() {}

func (p userSetParam) field() builder.Field {
	return p.data
}

func (p userSetParam) userModel() {}

type UserWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	idField()
}

type UserWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDSetParam) userModel() {}

func (p userWithPrismaIDSetParam) idField() {}

type UserWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	idField()
}

type userWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsParam) userModel() {}

func (p userWithPrismaIDEqualsParam) idField() {}

func (userWithPrismaIDSetParam) settable()  {}
func (userWithPrismaIDEqualsParam) equals() {}

type userWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIDEqualsUniqueParam) userModel() {}
func (p userWithPrismaIDEqualsUniqueParam) idField()   {}

func (userWithPrismaIDEqualsUniqueParam) unique() {}
func (userWithPrismaIDEqualsUniqueParam) equals() {}

type UserWithPrismaFullnameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	fullnameField()
}

type UserWithPrismaFullnameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	fullnameField()
}

type userWithPrismaFullnameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFullnameSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFullnameSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFullnameSetParam) userModel() {}

func (p userWithPrismaFullnameSetParam) fullnameField() {}

type UserWithPrismaFullnameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	fullnameField()
}

type userWithPrismaFullnameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFullnameEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFullnameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFullnameEqualsParam) userModel() {}

func (p userWithPrismaFullnameEqualsParam) fullnameField() {}

func (userWithPrismaFullnameSetParam) settable()  {}
func (userWithPrismaFullnameEqualsParam) equals() {}

type userWithPrismaFullnameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaFullnameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaFullnameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaFullnameEqualsUniqueParam) userModel()     {}
func (p userWithPrismaFullnameEqualsUniqueParam) fullnameField() {}

func (userWithPrismaFullnameEqualsUniqueParam) unique() {}
func (userWithPrismaFullnameEqualsUniqueParam) equals() {}

type UserWithPrismaEmailEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	emailField()
}

type UserWithPrismaEmailSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	emailField()
}

type userWithPrismaEmailSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailSetParam) userModel() {}

func (p userWithPrismaEmailSetParam) emailField() {}

type UserWithPrismaEmailWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	emailField()
}

type userWithPrismaEmailEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailEqualsParam) userModel() {}

func (p userWithPrismaEmailEqualsParam) emailField() {}

func (userWithPrismaEmailSetParam) settable()  {}
func (userWithPrismaEmailEqualsParam) equals() {}

type userWithPrismaEmailEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaEmailEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaEmailEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaEmailEqualsUniqueParam) userModel()  {}
func (p userWithPrismaEmailEqualsUniqueParam) emailField() {}

func (userWithPrismaEmailEqualsUniqueParam) unique() {}
func (userWithPrismaEmailEqualsUniqueParam) equals() {}

type UserWithPrismaPasswordEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	passwordField()
}

type UserWithPrismaPasswordSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	passwordField()
}

type userWithPrismaPasswordSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordSetParam) userModel() {}

func (p userWithPrismaPasswordSetParam) passwordField() {}

type UserWithPrismaPasswordWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	passwordField()
}

type userWithPrismaPasswordEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordEqualsParam) userModel() {}

func (p userWithPrismaPasswordEqualsParam) passwordField() {}

func (userWithPrismaPasswordSetParam) settable()  {}
func (userWithPrismaPasswordEqualsParam) equals() {}

type userWithPrismaPasswordEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaPasswordEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaPasswordEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaPasswordEqualsUniqueParam) userModel()     {}
func (p userWithPrismaPasswordEqualsUniqueParam) passwordField() {}

func (userWithPrismaPasswordEqualsUniqueParam) unique() {}
func (userWithPrismaPasswordEqualsUniqueParam) equals() {}

type UserWithPrismaDobEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	dobField()
}

type UserWithPrismaDobSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	dobField()
}

type userWithPrismaDobSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDobSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDobSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDobSetParam) userModel() {}

func (p userWithPrismaDobSetParam) dobField() {}

type UserWithPrismaDobWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	dobField()
}

type userWithPrismaDobEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDobEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDobEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDobEqualsParam) userModel() {}

func (p userWithPrismaDobEqualsParam) dobField() {}

func (userWithPrismaDobSetParam) settable()  {}
func (userWithPrismaDobEqualsParam) equals() {}

type userWithPrismaDobEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaDobEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaDobEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaDobEqualsUniqueParam) userModel() {}
func (p userWithPrismaDobEqualsUniqueParam) dobField()  {}

func (userWithPrismaDobEqualsUniqueParam) unique() {}
func (userWithPrismaDobEqualsUniqueParam) equals() {}

type UserWithPrismaAvatarEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	avatarField()
}

type UserWithPrismaAvatarSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	avatarField()
}

type userWithPrismaAvatarSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaAvatarSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaAvatarSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaAvatarSetParam) userModel() {}

func (p userWithPrismaAvatarSetParam) avatarField() {}

type UserWithPrismaAvatarWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	avatarField()
}

type userWithPrismaAvatarEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaAvatarEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaAvatarEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaAvatarEqualsParam) userModel() {}

func (p userWithPrismaAvatarEqualsParam) avatarField() {}

func (userWithPrismaAvatarSetParam) settable()  {}
func (userWithPrismaAvatarEqualsParam) equals() {}

type userWithPrismaAvatarEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaAvatarEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaAvatarEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaAvatarEqualsUniqueParam) userModel()   {}
func (p userWithPrismaAvatarEqualsUniqueParam) avatarField() {}

func (userWithPrismaAvatarEqualsUniqueParam) unique() {}
func (userWithPrismaAvatarEqualsUniqueParam) equals() {}

type UserWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	createdAtField()
}

type UserWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtSetParam) userModel() {}

func (p userWithPrismaCreatedAtSetParam) createdAtField() {}

type UserWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	createdAtField()
}

type userWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsParam) userModel() {}

func (p userWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (userWithPrismaCreatedAtSetParam) settable()  {}
func (userWithPrismaCreatedAtEqualsParam) equals() {}

type userWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCreatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (userWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type UserWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	updatedAtField()
}

type UserWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtSetParam) userModel() {}

func (p userWithPrismaUpdatedAtSetParam) updatedAtField() {}

type UserWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	updatedAtField()
}

type userWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsParam) userModel() {}

func (p userWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (userWithPrismaUpdatedAtSetParam) settable()  {}
func (userWithPrismaUpdatedAtEqualsParam) equals() {}

type userWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaUpdatedAtEqualsUniqueParam) userModel()      {}
func (p userWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (userWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (userWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type UserWithPrismaIsVerifiedEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	isVerifiedField()
}

type UserWithPrismaIsVerifiedSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	isVerifiedField()
}

type userWithPrismaIsVerifiedSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIsVerifiedSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIsVerifiedSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIsVerifiedSetParam) userModel() {}

func (p userWithPrismaIsVerifiedSetParam) isVerifiedField() {}

type UserWithPrismaIsVerifiedWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	isVerifiedField()
}

type userWithPrismaIsVerifiedEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIsVerifiedEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIsVerifiedEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIsVerifiedEqualsParam) userModel() {}

func (p userWithPrismaIsVerifiedEqualsParam) isVerifiedField() {}

func (userWithPrismaIsVerifiedSetParam) settable()  {}
func (userWithPrismaIsVerifiedEqualsParam) equals() {}

type userWithPrismaIsVerifiedEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaIsVerifiedEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaIsVerifiedEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaIsVerifiedEqualsUniqueParam) userModel()       {}
func (p userWithPrismaIsVerifiedEqualsUniqueParam) isVerifiedField() {}

func (userWithPrismaIsVerifiedEqualsUniqueParam) unique() {}
func (userWithPrismaIsVerifiedEqualsUniqueParam) equals() {}

type UserWithPrismaGuildsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	guildsField()
}

type UserWithPrismaGuildsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	guildsField()
}

type userWithPrismaGuildsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaGuildsSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaGuildsSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaGuildsSetParam) userModel() {}

func (p userWithPrismaGuildsSetParam) guildsField() {}

type UserWithPrismaGuildsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	guildsField()
}

type userWithPrismaGuildsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaGuildsEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaGuildsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaGuildsEqualsParam) userModel() {}

func (p userWithPrismaGuildsEqualsParam) guildsField() {}

func (userWithPrismaGuildsSetParam) settable()  {}
func (userWithPrismaGuildsEqualsParam) equals() {}

type userWithPrismaGuildsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaGuildsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaGuildsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaGuildsEqualsUniqueParam) userModel()   {}
func (p userWithPrismaGuildsEqualsUniqueParam) guildsField() {}

func (userWithPrismaGuildsEqualsUniqueParam) unique() {}
func (userWithPrismaGuildsEqualsUniqueParam) equals() {}

type UserWithPrismaVideosEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	videosField()
}

type UserWithPrismaVideosSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	videosField()
}

type userWithPrismaVideosSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaVideosSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaVideosSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaVideosSetParam) userModel() {}

func (p userWithPrismaVideosSetParam) videosField() {}

type UserWithPrismaVideosWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	videosField()
}

type userWithPrismaVideosEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaVideosEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaVideosEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaVideosEqualsParam) userModel() {}

func (p userWithPrismaVideosEqualsParam) videosField() {}

func (userWithPrismaVideosSetParam) settable()  {}
func (userWithPrismaVideosEqualsParam) equals() {}

type userWithPrismaVideosEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaVideosEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaVideosEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaVideosEqualsUniqueParam) userModel()   {}
func (p userWithPrismaVideosEqualsUniqueParam) videosField() {}

func (userWithPrismaVideosEqualsUniqueParam) unique() {}
func (userWithPrismaVideosEqualsUniqueParam) equals() {}

type UserWithPrismaOwnedGuildEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	ownedGuildField()
}

type UserWithPrismaOwnedGuildSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	ownedGuildField()
}

type userWithPrismaOwnedGuildSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaOwnedGuildSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaOwnedGuildSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaOwnedGuildSetParam) userModel() {}

func (p userWithPrismaOwnedGuildSetParam) ownedGuildField() {}

type UserWithPrismaOwnedGuildWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	ownedGuildField()
}

type userWithPrismaOwnedGuildEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaOwnedGuildEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaOwnedGuildEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaOwnedGuildEqualsParam) userModel() {}

func (p userWithPrismaOwnedGuildEqualsParam) ownedGuildField() {}

func (userWithPrismaOwnedGuildSetParam) settable()  {}
func (userWithPrismaOwnedGuildEqualsParam) equals() {}

type userWithPrismaOwnedGuildEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaOwnedGuildEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaOwnedGuildEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaOwnedGuildEqualsUniqueParam) userModel()       {}
func (p userWithPrismaOwnedGuildEqualsUniqueParam) ownedGuildField() {}

func (userWithPrismaOwnedGuildEqualsUniqueParam) unique() {}
func (userWithPrismaOwnedGuildEqualsUniqueParam) equals() {}

type UserWithPrismaCommentsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	commentsField()
}

type UserWithPrismaCommentsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	commentsField()
}

type userWithPrismaCommentsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCommentsSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCommentsSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCommentsSetParam) userModel() {}

func (p userWithPrismaCommentsSetParam) commentsField() {}

type UserWithPrismaCommentsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	commentsField()
}

type userWithPrismaCommentsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCommentsEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCommentsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCommentsEqualsParam) userModel() {}

func (p userWithPrismaCommentsEqualsParam) commentsField() {}

func (userWithPrismaCommentsSetParam) settable()  {}
func (userWithPrismaCommentsEqualsParam) equals() {}

type userWithPrismaCommentsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaCommentsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaCommentsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaCommentsEqualsUniqueParam) userModel()     {}
func (p userWithPrismaCommentsEqualsUniqueParam) commentsField() {}

func (userWithPrismaCommentsEqualsUniqueParam) unique() {}
func (userWithPrismaCommentsEqualsUniqueParam) equals() {}

type UserWithPrismaRepliesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	repliesField()
}

type UserWithPrismaRepliesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	repliesField()
}

type userWithPrismaRepliesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaRepliesSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaRepliesSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaRepliesSetParam) userModel() {}

func (p userWithPrismaRepliesSetParam) repliesField() {}

type UserWithPrismaRepliesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	repliesField()
}

type userWithPrismaRepliesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaRepliesEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaRepliesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaRepliesEqualsParam) userModel() {}

func (p userWithPrismaRepliesEqualsParam) repliesField() {}

func (userWithPrismaRepliesSetParam) settable()  {}
func (userWithPrismaRepliesEqualsParam) equals() {}

type userWithPrismaRepliesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaRepliesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaRepliesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaRepliesEqualsUniqueParam) userModel()    {}
func (p userWithPrismaRepliesEqualsUniqueParam) repliesField() {}

func (userWithPrismaRepliesEqualsUniqueParam) unique() {}
func (userWithPrismaRepliesEqualsUniqueParam) equals() {}

type UserWithPrismaLikesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	userModel()
	likesField()
}

type UserWithPrismaLikesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	likesField()
}

type userWithPrismaLikesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLikesSetParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLikesSetParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLikesSetParam) userModel() {}

func (p userWithPrismaLikesSetParam) likesField() {}

type UserWithPrismaLikesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	userModel()
	likesField()
}

type userWithPrismaLikesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLikesEqualsParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLikesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLikesEqualsParam) userModel() {}

func (p userWithPrismaLikesEqualsParam) likesField() {}

func (userWithPrismaLikesSetParam) settable()  {}
func (userWithPrismaLikesEqualsParam) equals() {}

type userWithPrismaLikesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p userWithPrismaLikesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p userWithPrismaLikesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p userWithPrismaLikesEqualsUniqueParam) userModel()  {}
func (p userWithPrismaLikesEqualsUniqueParam) likesField() {}

func (userWithPrismaLikesEqualsUniqueParam) unique() {}
func (userWithPrismaLikesEqualsUniqueParam) equals() {}

type guildActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var guildOutput = []builder.Output{
	{Name: "id"},
	{Name: "ownerId"},
	{Name: "name"},
	{Name: "description"},
	{Name: "avatar"},
	{Name: "coverImage"},
	{Name: "isPrivate"},
	{Name: "createdAt"},
	{Name: "updatedAt"},
}

type GuildRelationWith interface {
	getQuery() builder.Query
	with()
	guildRelation()
}

type GuildWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
}

type guildDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildDefaultParam) field() builder.Field {
	return p.data
}

func (p guildDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p guildDefaultParam) guildModel() {}

type GuildOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
}

type guildOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildOrderByParam) field() builder.Field {
	return p.data
}

func (p guildOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p guildOrderByParam) guildModel() {}

type GuildCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	isCursor()
}

type guildCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildCursorParam) field() builder.Field {
	return p.data
}

func (p guildCursorParam) isCursor() {}

func (p guildCursorParam) getQuery() builder.Query {
	return p.query
}

func (p guildCursorParam) guildModel() {}

type GuildParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	guildModel()
}

type guildParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p guildParamUnique) guildModel() {}

func (guildParamUnique) unique() {}

func (p guildParamUnique) field() builder.Field {
	return p.data
}

func (p guildParamUnique) getQuery() builder.Query {
	return p.query
}

type GuildEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
}

type guildEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildEqualsParam) guildModel() {}

func (guildEqualsParam) equals() {}

func (p guildEqualsParam) field() builder.Field {
	return p.data
}

func (p guildEqualsParam) getQuery() builder.Query {
	return p.query
}

type GuildEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	guildModel()
}

type guildEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildEqualsUniqueParam) guildModel() {}

func (guildEqualsUniqueParam) unique() {}
func (guildEqualsUniqueParam) equals() {}

func (p guildEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type GuildSetParam interface {
	field() builder.Field
	settable()
	guildModel()
}

type guildSetParam struct {
	data builder.Field
}

func (guildSetParam) settable() {}

func (p guildSetParam) field() builder.Field {
	return p.data
}

func (p guildSetParam) guildModel() {}

type GuildWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
	idField()
}

type GuildWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	idField()
}

type guildWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaIDSetParam) guildModel() {}

func (p guildWithPrismaIDSetParam) idField() {}

type GuildWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	idField()
}

type guildWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaIDEqualsParam) guildModel() {}

func (p guildWithPrismaIDEqualsParam) idField() {}

func (guildWithPrismaIDSetParam) settable()  {}
func (guildWithPrismaIDEqualsParam) equals() {}

type guildWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaIDEqualsUniqueParam) guildModel() {}
func (p guildWithPrismaIDEqualsUniqueParam) idField()    {}

func (guildWithPrismaIDEqualsUniqueParam) unique() {}
func (guildWithPrismaIDEqualsUniqueParam) equals() {}

type GuildWithPrismaOwnerIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
	ownerIDField()
}

type GuildWithPrismaOwnerIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	ownerIDField()
}

type guildWithPrismaOwnerIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaOwnerIDSetParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaOwnerIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaOwnerIDSetParam) guildModel() {}

func (p guildWithPrismaOwnerIDSetParam) ownerIDField() {}

type GuildWithPrismaOwnerIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	ownerIDField()
}

type guildWithPrismaOwnerIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaOwnerIDEqualsParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaOwnerIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaOwnerIDEqualsParam) guildModel() {}

func (p guildWithPrismaOwnerIDEqualsParam) ownerIDField() {}

func (guildWithPrismaOwnerIDSetParam) settable()  {}
func (guildWithPrismaOwnerIDEqualsParam) equals() {}

type guildWithPrismaOwnerIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaOwnerIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaOwnerIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaOwnerIDEqualsUniqueParam) guildModel()   {}
func (p guildWithPrismaOwnerIDEqualsUniqueParam) ownerIDField() {}

func (guildWithPrismaOwnerIDEqualsUniqueParam) unique() {}
func (guildWithPrismaOwnerIDEqualsUniqueParam) equals() {}

type GuildWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
	nameField()
}

type GuildWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	nameField()
}

type guildWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaNameSetParam) guildModel() {}

func (p guildWithPrismaNameSetParam) nameField() {}

type GuildWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	nameField()
}

type guildWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaNameEqualsParam) guildModel() {}

func (p guildWithPrismaNameEqualsParam) nameField() {}

func (guildWithPrismaNameSetParam) settable()  {}
func (guildWithPrismaNameEqualsParam) equals() {}

type guildWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaNameEqualsUniqueParam) guildModel() {}
func (p guildWithPrismaNameEqualsUniqueParam) nameField()  {}

func (guildWithPrismaNameEqualsUniqueParam) unique() {}
func (guildWithPrismaNameEqualsUniqueParam) equals() {}

type GuildWithPrismaDescriptionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
	descriptionField()
}

type GuildWithPrismaDescriptionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	descriptionField()
}

type guildWithPrismaDescriptionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaDescriptionSetParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaDescriptionSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaDescriptionSetParam) guildModel() {}

func (p guildWithPrismaDescriptionSetParam) descriptionField() {}

type GuildWithPrismaDescriptionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	descriptionField()
}

type guildWithPrismaDescriptionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaDescriptionEqualsParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaDescriptionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaDescriptionEqualsParam) guildModel() {}

func (p guildWithPrismaDescriptionEqualsParam) descriptionField() {}

func (guildWithPrismaDescriptionSetParam) settable()  {}
func (guildWithPrismaDescriptionEqualsParam) equals() {}

type guildWithPrismaDescriptionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaDescriptionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaDescriptionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaDescriptionEqualsUniqueParam) guildModel()       {}
func (p guildWithPrismaDescriptionEqualsUniqueParam) descriptionField() {}

func (guildWithPrismaDescriptionEqualsUniqueParam) unique() {}
func (guildWithPrismaDescriptionEqualsUniqueParam) equals() {}

type GuildWithPrismaAvatarEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
	avatarField()
}

type GuildWithPrismaAvatarSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	avatarField()
}

type guildWithPrismaAvatarSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaAvatarSetParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaAvatarSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaAvatarSetParam) guildModel() {}

func (p guildWithPrismaAvatarSetParam) avatarField() {}

type GuildWithPrismaAvatarWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	avatarField()
}

type guildWithPrismaAvatarEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaAvatarEqualsParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaAvatarEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaAvatarEqualsParam) guildModel() {}

func (p guildWithPrismaAvatarEqualsParam) avatarField() {}

func (guildWithPrismaAvatarSetParam) settable()  {}
func (guildWithPrismaAvatarEqualsParam) equals() {}

type guildWithPrismaAvatarEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaAvatarEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaAvatarEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaAvatarEqualsUniqueParam) guildModel()  {}
func (p guildWithPrismaAvatarEqualsUniqueParam) avatarField() {}

func (guildWithPrismaAvatarEqualsUniqueParam) unique() {}
func (guildWithPrismaAvatarEqualsUniqueParam) equals() {}

type GuildWithPrismaCoverImageEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
	coverImageField()
}

type GuildWithPrismaCoverImageSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	coverImageField()
}

type guildWithPrismaCoverImageSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaCoverImageSetParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaCoverImageSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaCoverImageSetParam) guildModel() {}

func (p guildWithPrismaCoverImageSetParam) coverImageField() {}

type GuildWithPrismaCoverImageWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	coverImageField()
}

type guildWithPrismaCoverImageEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaCoverImageEqualsParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaCoverImageEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaCoverImageEqualsParam) guildModel() {}

func (p guildWithPrismaCoverImageEqualsParam) coverImageField() {}

func (guildWithPrismaCoverImageSetParam) settable()  {}
func (guildWithPrismaCoverImageEqualsParam) equals() {}

type guildWithPrismaCoverImageEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaCoverImageEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaCoverImageEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaCoverImageEqualsUniqueParam) guildModel()      {}
func (p guildWithPrismaCoverImageEqualsUniqueParam) coverImageField() {}

func (guildWithPrismaCoverImageEqualsUniqueParam) unique() {}
func (guildWithPrismaCoverImageEqualsUniqueParam) equals() {}

type GuildWithPrismaIsPrivateEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
	isPrivateField()
}

type GuildWithPrismaIsPrivateSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	isPrivateField()
}

type guildWithPrismaIsPrivateSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaIsPrivateSetParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaIsPrivateSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaIsPrivateSetParam) guildModel() {}

func (p guildWithPrismaIsPrivateSetParam) isPrivateField() {}

type GuildWithPrismaIsPrivateWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	isPrivateField()
}

type guildWithPrismaIsPrivateEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaIsPrivateEqualsParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaIsPrivateEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaIsPrivateEqualsParam) guildModel() {}

func (p guildWithPrismaIsPrivateEqualsParam) isPrivateField() {}

func (guildWithPrismaIsPrivateSetParam) settable()  {}
func (guildWithPrismaIsPrivateEqualsParam) equals() {}

type guildWithPrismaIsPrivateEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaIsPrivateEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaIsPrivateEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaIsPrivateEqualsUniqueParam) guildModel()     {}
func (p guildWithPrismaIsPrivateEqualsUniqueParam) isPrivateField() {}

func (guildWithPrismaIsPrivateEqualsUniqueParam) unique() {}
func (guildWithPrismaIsPrivateEqualsUniqueParam) equals() {}

type GuildWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
	createdAtField()
}

type GuildWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	createdAtField()
}

type guildWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaCreatedAtSetParam) guildModel() {}

func (p guildWithPrismaCreatedAtSetParam) createdAtField() {}

type GuildWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	createdAtField()
}

type guildWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaCreatedAtEqualsParam) guildModel() {}

func (p guildWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (guildWithPrismaCreatedAtSetParam) settable()  {}
func (guildWithPrismaCreatedAtEqualsParam) equals() {}

type guildWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaCreatedAtEqualsUniqueParam) guildModel()     {}
func (p guildWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (guildWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (guildWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type GuildWithPrismaUpdatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
	updatedAtField()
}

type GuildWithPrismaUpdatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	updatedAtField()
}

type guildWithPrismaUpdatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaUpdatedAtSetParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaUpdatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaUpdatedAtSetParam) guildModel() {}

func (p guildWithPrismaUpdatedAtSetParam) updatedAtField() {}

type GuildWithPrismaUpdatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	updatedAtField()
}

type guildWithPrismaUpdatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaUpdatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaUpdatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaUpdatedAtEqualsParam) guildModel() {}

func (p guildWithPrismaUpdatedAtEqualsParam) updatedAtField() {}

func (guildWithPrismaUpdatedAtSetParam) settable()  {}
func (guildWithPrismaUpdatedAtEqualsParam) equals() {}

type guildWithPrismaUpdatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaUpdatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaUpdatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaUpdatedAtEqualsUniqueParam) guildModel()     {}
func (p guildWithPrismaUpdatedAtEqualsUniqueParam) updatedAtField() {}

func (guildWithPrismaUpdatedAtEqualsUniqueParam) unique() {}
func (guildWithPrismaUpdatedAtEqualsUniqueParam) equals() {}

type GuildWithPrismaOwnerEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
	ownerField()
}

type GuildWithPrismaOwnerSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	ownerField()
}

type guildWithPrismaOwnerSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaOwnerSetParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaOwnerSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaOwnerSetParam) guildModel() {}

func (p guildWithPrismaOwnerSetParam) ownerField() {}

type GuildWithPrismaOwnerWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	ownerField()
}

type guildWithPrismaOwnerEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaOwnerEqualsParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaOwnerEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaOwnerEqualsParam) guildModel() {}

func (p guildWithPrismaOwnerEqualsParam) ownerField() {}

func (guildWithPrismaOwnerSetParam) settable()  {}
func (guildWithPrismaOwnerEqualsParam) equals() {}

type guildWithPrismaOwnerEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaOwnerEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaOwnerEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaOwnerEqualsUniqueParam) guildModel() {}
func (p guildWithPrismaOwnerEqualsUniqueParam) ownerField() {}

func (guildWithPrismaOwnerEqualsUniqueParam) unique() {}
func (guildWithPrismaOwnerEqualsUniqueParam) equals() {}

type GuildWithPrismaMembersEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
	membersField()
}

type GuildWithPrismaMembersSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	membersField()
}

type guildWithPrismaMembersSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaMembersSetParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaMembersSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaMembersSetParam) guildModel() {}

func (p guildWithPrismaMembersSetParam) membersField() {}

type GuildWithPrismaMembersWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	membersField()
}

type guildWithPrismaMembersEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaMembersEqualsParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaMembersEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaMembersEqualsParam) guildModel() {}

func (p guildWithPrismaMembersEqualsParam) membersField() {}

func (guildWithPrismaMembersSetParam) settable()  {}
func (guildWithPrismaMembersEqualsParam) equals() {}

type guildWithPrismaMembersEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaMembersEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaMembersEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaMembersEqualsUniqueParam) guildModel()   {}
func (p guildWithPrismaMembersEqualsUniqueParam) membersField() {}

func (guildWithPrismaMembersEqualsUniqueParam) unique() {}
func (guildWithPrismaMembersEqualsUniqueParam) equals() {}

type GuildWithPrismaVideosEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
	videosField()
}

type GuildWithPrismaVideosSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	videosField()
}

type guildWithPrismaVideosSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaVideosSetParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaVideosSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaVideosSetParam) guildModel() {}

func (p guildWithPrismaVideosSetParam) videosField() {}

type GuildWithPrismaVideosWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	videosField()
}

type guildWithPrismaVideosEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaVideosEqualsParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaVideosEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaVideosEqualsParam) guildModel() {}

func (p guildWithPrismaVideosEqualsParam) videosField() {}

func (guildWithPrismaVideosSetParam) settable()  {}
func (guildWithPrismaVideosEqualsParam) equals() {}

type guildWithPrismaVideosEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaVideosEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaVideosEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaVideosEqualsUniqueParam) guildModel()  {}
func (p guildWithPrismaVideosEqualsUniqueParam) videosField() {}

func (guildWithPrismaVideosEqualsUniqueParam) unique() {}
func (guildWithPrismaVideosEqualsUniqueParam) equals() {}

type GuildWithPrismaTagsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildModel()
	tagsField()
}

type GuildWithPrismaTagsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	tagsField()
}

type guildWithPrismaTagsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaTagsSetParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaTagsSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaTagsSetParam) guildModel() {}

func (p guildWithPrismaTagsSetParam) tagsField() {}

type GuildWithPrismaTagsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildModel()
	tagsField()
}

type guildWithPrismaTagsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaTagsEqualsParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaTagsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaTagsEqualsParam) guildModel() {}

func (p guildWithPrismaTagsEqualsParam) tagsField() {}

func (guildWithPrismaTagsSetParam) settable()  {}
func (guildWithPrismaTagsEqualsParam) equals() {}

type guildWithPrismaTagsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildWithPrismaTagsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildWithPrismaTagsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildWithPrismaTagsEqualsUniqueParam) guildModel() {}
func (p guildWithPrismaTagsEqualsUniqueParam) tagsField()  {}

func (guildWithPrismaTagsEqualsUniqueParam) unique() {}
func (guildWithPrismaTagsEqualsUniqueParam) equals() {}

type guildMemberActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var guildMemberOutput = []builder.Output{
	{Name: "id"},
	{Name: "userId"},
	{Name: "guildId"},
	{Name: "role"},
	{Name: "joinedAt"},
	{Name: "status"},
}

type GuildMemberRelationWith interface {
	getQuery() builder.Query
	with()
	guildMemberRelation()
}

type GuildMemberWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
}

type guildMemberDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberDefaultParam) field() builder.Field {
	return p.data
}

func (p guildMemberDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberDefaultParam) guildMemberModel() {}

type GuildMemberOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
}

type guildMemberOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberOrderByParam) field() builder.Field {
	return p.data
}

func (p guildMemberOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberOrderByParam) guildMemberModel() {}

type GuildMemberCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	isCursor()
}

type guildMemberCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberCursorParam) field() builder.Field {
	return p.data
}

func (p guildMemberCursorParam) isCursor() {}

func (p guildMemberCursorParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberCursorParam) guildMemberModel() {}

type GuildMemberParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	guildMemberModel()
}

type guildMemberParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberParamUnique) guildMemberModel() {}

func (guildMemberParamUnique) unique() {}

func (p guildMemberParamUnique) field() builder.Field {
	return p.data
}

func (p guildMemberParamUnique) getQuery() builder.Query {
	return p.query
}

type GuildMemberEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildMemberModel()
}

type guildMemberEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberEqualsParam) guildMemberModel() {}

func (guildMemberEqualsParam) equals() {}

func (p guildMemberEqualsParam) field() builder.Field {
	return p.data
}

func (p guildMemberEqualsParam) getQuery() builder.Query {
	return p.query
}

type GuildMemberEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	guildMemberModel()
}

type guildMemberEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberEqualsUniqueParam) guildMemberModel() {}

func (guildMemberEqualsUniqueParam) unique() {}
func (guildMemberEqualsUniqueParam) equals() {}

func (p guildMemberEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildMemberEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type GuildMemberSetParam interface {
	field() builder.Field
	settable()
	guildMemberModel()
}

type guildMemberSetParam struct {
	data builder.Field
}

func (guildMemberSetParam) settable() {}

func (p guildMemberSetParam) field() builder.Field {
	return p.data
}

func (p guildMemberSetParam) guildMemberModel() {}

type GuildMemberWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildMemberModel()
	idField()
}

type GuildMemberWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	idField()
}

type guildMemberWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaIDSetParam) guildMemberModel() {}

func (p guildMemberWithPrismaIDSetParam) idField() {}

type GuildMemberWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	idField()
}

type guildMemberWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaIDEqualsParam) guildMemberModel() {}

func (p guildMemberWithPrismaIDEqualsParam) idField() {}

func (guildMemberWithPrismaIDSetParam) settable()  {}
func (guildMemberWithPrismaIDEqualsParam) equals() {}

type guildMemberWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaIDEqualsUniqueParam) guildMemberModel() {}
func (p guildMemberWithPrismaIDEqualsUniqueParam) idField()          {}

func (guildMemberWithPrismaIDEqualsUniqueParam) unique() {}
func (guildMemberWithPrismaIDEqualsUniqueParam) equals() {}

type GuildMemberWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildMemberModel()
	userIDField()
}

type GuildMemberWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	userIDField()
}

type guildMemberWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaUserIDSetParam) guildMemberModel() {}

func (p guildMemberWithPrismaUserIDSetParam) userIDField() {}

type GuildMemberWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	userIDField()
}

type guildMemberWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaUserIDEqualsParam) guildMemberModel() {}

func (p guildMemberWithPrismaUserIDEqualsParam) userIDField() {}

func (guildMemberWithPrismaUserIDSetParam) settable()  {}
func (guildMemberWithPrismaUserIDEqualsParam) equals() {}

type guildMemberWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaUserIDEqualsUniqueParam) guildMemberModel() {}
func (p guildMemberWithPrismaUserIDEqualsUniqueParam) userIDField()      {}

func (guildMemberWithPrismaUserIDEqualsUniqueParam) unique() {}
func (guildMemberWithPrismaUserIDEqualsUniqueParam) equals() {}

type GuildMemberWithPrismaGuildIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildMemberModel()
	guildIDField()
}

type GuildMemberWithPrismaGuildIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	guildIDField()
}

type guildMemberWithPrismaGuildIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaGuildIDSetParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaGuildIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaGuildIDSetParam) guildMemberModel() {}

func (p guildMemberWithPrismaGuildIDSetParam) guildIDField() {}

type GuildMemberWithPrismaGuildIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	guildIDField()
}

type guildMemberWithPrismaGuildIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaGuildIDEqualsParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaGuildIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaGuildIDEqualsParam) guildMemberModel() {}

func (p guildMemberWithPrismaGuildIDEqualsParam) guildIDField() {}

func (guildMemberWithPrismaGuildIDSetParam) settable()  {}
func (guildMemberWithPrismaGuildIDEqualsParam) equals() {}

type guildMemberWithPrismaGuildIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaGuildIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaGuildIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaGuildIDEqualsUniqueParam) guildMemberModel() {}
func (p guildMemberWithPrismaGuildIDEqualsUniqueParam) guildIDField()     {}

func (guildMemberWithPrismaGuildIDEqualsUniqueParam) unique() {}
func (guildMemberWithPrismaGuildIDEqualsUniqueParam) equals() {}

type GuildMemberWithPrismaRoleEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildMemberModel()
	roleField()
}

type GuildMemberWithPrismaRoleSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	roleField()
}

type guildMemberWithPrismaRoleSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaRoleSetParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaRoleSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaRoleSetParam) guildMemberModel() {}

func (p guildMemberWithPrismaRoleSetParam) roleField() {}

type GuildMemberWithPrismaRoleWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	roleField()
}

type guildMemberWithPrismaRoleEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaRoleEqualsParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaRoleEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaRoleEqualsParam) guildMemberModel() {}

func (p guildMemberWithPrismaRoleEqualsParam) roleField() {}

func (guildMemberWithPrismaRoleSetParam) settable()  {}
func (guildMemberWithPrismaRoleEqualsParam) equals() {}

type guildMemberWithPrismaRoleEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaRoleEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaRoleEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaRoleEqualsUniqueParam) guildMemberModel() {}
func (p guildMemberWithPrismaRoleEqualsUniqueParam) roleField()        {}

func (guildMemberWithPrismaRoleEqualsUniqueParam) unique() {}
func (guildMemberWithPrismaRoleEqualsUniqueParam) equals() {}

type GuildMemberWithPrismaJoinedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildMemberModel()
	joinedAtField()
}

type GuildMemberWithPrismaJoinedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	joinedAtField()
}

type guildMemberWithPrismaJoinedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaJoinedAtSetParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaJoinedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaJoinedAtSetParam) guildMemberModel() {}

func (p guildMemberWithPrismaJoinedAtSetParam) joinedAtField() {}

type GuildMemberWithPrismaJoinedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	joinedAtField()
}

type guildMemberWithPrismaJoinedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaJoinedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaJoinedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaJoinedAtEqualsParam) guildMemberModel() {}

func (p guildMemberWithPrismaJoinedAtEqualsParam) joinedAtField() {}

func (guildMemberWithPrismaJoinedAtSetParam) settable()  {}
func (guildMemberWithPrismaJoinedAtEqualsParam) equals() {}

type guildMemberWithPrismaJoinedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaJoinedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaJoinedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaJoinedAtEqualsUniqueParam) guildMemberModel() {}
func (p guildMemberWithPrismaJoinedAtEqualsUniqueParam) joinedAtField()    {}

func (guildMemberWithPrismaJoinedAtEqualsUniqueParam) unique() {}
func (guildMemberWithPrismaJoinedAtEqualsUniqueParam) equals() {}

type GuildMemberWithPrismaStatusEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildMemberModel()
	statusField()
}

type GuildMemberWithPrismaStatusSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	statusField()
}

type guildMemberWithPrismaStatusSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaStatusSetParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaStatusSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaStatusSetParam) guildMemberModel() {}

func (p guildMemberWithPrismaStatusSetParam) statusField() {}

type GuildMemberWithPrismaStatusWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	statusField()
}

type guildMemberWithPrismaStatusEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaStatusEqualsParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaStatusEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaStatusEqualsParam) guildMemberModel() {}

func (p guildMemberWithPrismaStatusEqualsParam) statusField() {}

func (guildMemberWithPrismaStatusSetParam) settable()  {}
func (guildMemberWithPrismaStatusEqualsParam) equals() {}

type guildMemberWithPrismaStatusEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaStatusEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaStatusEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaStatusEqualsUniqueParam) guildMemberModel() {}
func (p guildMemberWithPrismaStatusEqualsUniqueParam) statusField()      {}

func (guildMemberWithPrismaStatusEqualsUniqueParam) unique() {}
func (guildMemberWithPrismaStatusEqualsUniqueParam) equals() {}

type GuildMemberWithPrismaUserEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildMemberModel()
	userField()
}

type GuildMemberWithPrismaUserSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	userField()
}

type guildMemberWithPrismaUserSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaUserSetParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaUserSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaUserSetParam) guildMemberModel() {}

func (p guildMemberWithPrismaUserSetParam) userField() {}

type GuildMemberWithPrismaUserWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	userField()
}

type guildMemberWithPrismaUserEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaUserEqualsParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaUserEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaUserEqualsParam) guildMemberModel() {}

func (p guildMemberWithPrismaUserEqualsParam) userField() {}

func (guildMemberWithPrismaUserSetParam) settable()  {}
func (guildMemberWithPrismaUserEqualsParam) equals() {}

type guildMemberWithPrismaUserEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaUserEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaUserEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaUserEqualsUniqueParam) guildMemberModel() {}
func (p guildMemberWithPrismaUserEqualsUniqueParam) userField()        {}

func (guildMemberWithPrismaUserEqualsUniqueParam) unique() {}
func (guildMemberWithPrismaUserEqualsUniqueParam) equals() {}

type GuildMemberWithPrismaGuildEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	guildMemberModel()
	guildField()
}

type GuildMemberWithPrismaGuildSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	guildField()
}

type guildMemberWithPrismaGuildSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaGuildSetParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaGuildSetParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaGuildSetParam) guildMemberModel() {}

func (p guildMemberWithPrismaGuildSetParam) guildField() {}

type GuildMemberWithPrismaGuildWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	guildMemberModel()
	guildField()
}

type guildMemberWithPrismaGuildEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaGuildEqualsParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaGuildEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaGuildEqualsParam) guildMemberModel() {}

func (p guildMemberWithPrismaGuildEqualsParam) guildField() {}

func (guildMemberWithPrismaGuildSetParam) settable()  {}
func (guildMemberWithPrismaGuildEqualsParam) equals() {}

type guildMemberWithPrismaGuildEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p guildMemberWithPrismaGuildEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p guildMemberWithPrismaGuildEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p guildMemberWithPrismaGuildEqualsUniqueParam) guildMemberModel() {}
func (p guildMemberWithPrismaGuildEqualsUniqueParam) guildField()       {}

func (guildMemberWithPrismaGuildEqualsUniqueParam) unique() {}
func (guildMemberWithPrismaGuildEqualsUniqueParam) equals() {}

type videosActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var videosOutput = []builder.Output{
	{Name: "id"},
	{Name: "title"},
	{Name: "description"},
	{Name: "thumbnail"},
	{Name: "videoUrl"},
	{Name: "duration"},
	{Name: "ownerId"},
	{Name: "guildId"},
	{Name: "createdAt"},
	{Name: "isPrivate"},
	{Name: "views"},
}

type VideosRelationWith interface {
	getQuery() builder.Query
	with()
	videosRelation()
}

type VideosWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
}

type videosDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosDefaultParam) field() builder.Field {
	return p.data
}

func (p videosDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p videosDefaultParam) videosModel() {}

type VideosOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
}

type videosOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosOrderByParam) field() builder.Field {
	return p.data
}

func (p videosOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p videosOrderByParam) videosModel() {}

type VideosCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	isCursor()
}

type videosCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosCursorParam) field() builder.Field {
	return p.data
}

func (p videosCursorParam) isCursor() {}

func (p videosCursorParam) getQuery() builder.Query {
	return p.query
}

func (p videosCursorParam) videosModel() {}

type VideosParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	videosModel()
}

type videosParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p videosParamUnique) videosModel() {}

func (videosParamUnique) unique() {}

func (p videosParamUnique) field() builder.Field {
	return p.data
}

func (p videosParamUnique) getQuery() builder.Query {
	return p.query
}

type VideosEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
}

type videosEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosEqualsParam) videosModel() {}

func (videosEqualsParam) equals() {}

func (p videosEqualsParam) field() builder.Field {
	return p.data
}

func (p videosEqualsParam) getQuery() builder.Query {
	return p.query
}

type VideosEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	videosModel()
}

type videosEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosEqualsUniqueParam) videosModel() {}

func (videosEqualsUniqueParam) unique() {}
func (videosEqualsUniqueParam) equals() {}

func (p videosEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type VideosSetParam interface {
	field() builder.Field
	settable()
	videosModel()
}

type videosSetParam struct {
	data builder.Field
}

func (videosSetParam) settable() {}

func (p videosSetParam) field() builder.Field {
	return p.data
}

func (p videosSetParam) videosModel() {}

type VideosWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	idField()
}

type VideosWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	idField()
}

type videosWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaIDSetParam) videosModel() {}

func (p videosWithPrismaIDSetParam) idField() {}

type VideosWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	idField()
}

type videosWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaIDEqualsParam) videosModel() {}

func (p videosWithPrismaIDEqualsParam) idField() {}

func (videosWithPrismaIDSetParam) settable()  {}
func (videosWithPrismaIDEqualsParam) equals() {}

type videosWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaIDEqualsUniqueParam) videosModel() {}
func (p videosWithPrismaIDEqualsUniqueParam) idField()     {}

func (videosWithPrismaIDEqualsUniqueParam) unique() {}
func (videosWithPrismaIDEqualsUniqueParam) equals() {}

type VideosWithPrismaTitleEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	titleField()
}

type VideosWithPrismaTitleSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	titleField()
}

type videosWithPrismaTitleSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaTitleSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaTitleSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaTitleSetParam) videosModel() {}

func (p videosWithPrismaTitleSetParam) titleField() {}

type VideosWithPrismaTitleWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	titleField()
}

type videosWithPrismaTitleEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaTitleEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaTitleEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaTitleEqualsParam) videosModel() {}

func (p videosWithPrismaTitleEqualsParam) titleField() {}

func (videosWithPrismaTitleSetParam) settable()  {}
func (videosWithPrismaTitleEqualsParam) equals() {}

type videosWithPrismaTitleEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaTitleEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaTitleEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaTitleEqualsUniqueParam) videosModel() {}
func (p videosWithPrismaTitleEqualsUniqueParam) titleField()  {}

func (videosWithPrismaTitleEqualsUniqueParam) unique() {}
func (videosWithPrismaTitleEqualsUniqueParam) equals() {}

type VideosWithPrismaDescriptionEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	descriptionField()
}

type VideosWithPrismaDescriptionSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	descriptionField()
}

type videosWithPrismaDescriptionSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaDescriptionSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaDescriptionSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaDescriptionSetParam) videosModel() {}

func (p videosWithPrismaDescriptionSetParam) descriptionField() {}

type VideosWithPrismaDescriptionWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	descriptionField()
}

type videosWithPrismaDescriptionEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaDescriptionEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaDescriptionEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaDescriptionEqualsParam) videosModel() {}

func (p videosWithPrismaDescriptionEqualsParam) descriptionField() {}

func (videosWithPrismaDescriptionSetParam) settable()  {}
func (videosWithPrismaDescriptionEqualsParam) equals() {}

type videosWithPrismaDescriptionEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaDescriptionEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaDescriptionEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaDescriptionEqualsUniqueParam) videosModel()      {}
func (p videosWithPrismaDescriptionEqualsUniqueParam) descriptionField() {}

func (videosWithPrismaDescriptionEqualsUniqueParam) unique() {}
func (videosWithPrismaDescriptionEqualsUniqueParam) equals() {}

type VideosWithPrismaThumbnailEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	thumbnailField()
}

type VideosWithPrismaThumbnailSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	thumbnailField()
}

type videosWithPrismaThumbnailSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaThumbnailSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaThumbnailSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaThumbnailSetParam) videosModel() {}

func (p videosWithPrismaThumbnailSetParam) thumbnailField() {}

type VideosWithPrismaThumbnailWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	thumbnailField()
}

type videosWithPrismaThumbnailEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaThumbnailEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaThumbnailEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaThumbnailEqualsParam) videosModel() {}

func (p videosWithPrismaThumbnailEqualsParam) thumbnailField() {}

func (videosWithPrismaThumbnailSetParam) settable()  {}
func (videosWithPrismaThumbnailEqualsParam) equals() {}

type videosWithPrismaThumbnailEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaThumbnailEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaThumbnailEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaThumbnailEqualsUniqueParam) videosModel()    {}
func (p videosWithPrismaThumbnailEqualsUniqueParam) thumbnailField() {}

func (videosWithPrismaThumbnailEqualsUniqueParam) unique() {}
func (videosWithPrismaThumbnailEqualsUniqueParam) equals() {}

type VideosWithPrismaVideoURLEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	videoURLField()
}

type VideosWithPrismaVideoURLSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	videoURLField()
}

type videosWithPrismaVideoURLSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaVideoURLSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaVideoURLSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaVideoURLSetParam) videosModel() {}

func (p videosWithPrismaVideoURLSetParam) videoURLField() {}

type VideosWithPrismaVideoURLWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	videoURLField()
}

type videosWithPrismaVideoURLEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaVideoURLEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaVideoURLEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaVideoURLEqualsParam) videosModel() {}

func (p videosWithPrismaVideoURLEqualsParam) videoURLField() {}

func (videosWithPrismaVideoURLSetParam) settable()  {}
func (videosWithPrismaVideoURLEqualsParam) equals() {}

type videosWithPrismaVideoURLEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaVideoURLEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaVideoURLEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaVideoURLEqualsUniqueParam) videosModel()   {}
func (p videosWithPrismaVideoURLEqualsUniqueParam) videoURLField() {}

func (videosWithPrismaVideoURLEqualsUniqueParam) unique() {}
func (videosWithPrismaVideoURLEqualsUniqueParam) equals() {}

type VideosWithPrismaDurationEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	durationField()
}

type VideosWithPrismaDurationSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	durationField()
}

type videosWithPrismaDurationSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaDurationSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaDurationSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaDurationSetParam) videosModel() {}

func (p videosWithPrismaDurationSetParam) durationField() {}

type VideosWithPrismaDurationWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	durationField()
}

type videosWithPrismaDurationEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaDurationEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaDurationEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaDurationEqualsParam) videosModel() {}

func (p videosWithPrismaDurationEqualsParam) durationField() {}

func (videosWithPrismaDurationSetParam) settable()  {}
func (videosWithPrismaDurationEqualsParam) equals() {}

type videosWithPrismaDurationEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaDurationEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaDurationEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaDurationEqualsUniqueParam) videosModel()   {}
func (p videosWithPrismaDurationEqualsUniqueParam) durationField() {}

func (videosWithPrismaDurationEqualsUniqueParam) unique() {}
func (videosWithPrismaDurationEqualsUniqueParam) equals() {}

type VideosWithPrismaOwnerIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	ownerIDField()
}

type VideosWithPrismaOwnerIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	ownerIDField()
}

type videosWithPrismaOwnerIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaOwnerIDSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaOwnerIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaOwnerIDSetParam) videosModel() {}

func (p videosWithPrismaOwnerIDSetParam) ownerIDField() {}

type VideosWithPrismaOwnerIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	ownerIDField()
}

type videosWithPrismaOwnerIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaOwnerIDEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaOwnerIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaOwnerIDEqualsParam) videosModel() {}

func (p videosWithPrismaOwnerIDEqualsParam) ownerIDField() {}

func (videosWithPrismaOwnerIDSetParam) settable()  {}
func (videosWithPrismaOwnerIDEqualsParam) equals() {}

type videosWithPrismaOwnerIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaOwnerIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaOwnerIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaOwnerIDEqualsUniqueParam) videosModel()  {}
func (p videosWithPrismaOwnerIDEqualsUniqueParam) ownerIDField() {}

func (videosWithPrismaOwnerIDEqualsUniqueParam) unique() {}
func (videosWithPrismaOwnerIDEqualsUniqueParam) equals() {}

type VideosWithPrismaGuildIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	guildIDField()
}

type VideosWithPrismaGuildIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	guildIDField()
}

type videosWithPrismaGuildIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaGuildIDSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaGuildIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaGuildIDSetParam) videosModel() {}

func (p videosWithPrismaGuildIDSetParam) guildIDField() {}

type VideosWithPrismaGuildIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	guildIDField()
}

type videosWithPrismaGuildIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaGuildIDEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaGuildIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaGuildIDEqualsParam) videosModel() {}

func (p videosWithPrismaGuildIDEqualsParam) guildIDField() {}

func (videosWithPrismaGuildIDSetParam) settable()  {}
func (videosWithPrismaGuildIDEqualsParam) equals() {}

type videosWithPrismaGuildIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaGuildIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaGuildIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaGuildIDEqualsUniqueParam) videosModel()  {}
func (p videosWithPrismaGuildIDEqualsUniqueParam) guildIDField() {}

func (videosWithPrismaGuildIDEqualsUniqueParam) unique() {}
func (videosWithPrismaGuildIDEqualsUniqueParam) equals() {}

type VideosWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	createdAtField()
}

type VideosWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	createdAtField()
}

type videosWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaCreatedAtSetParam) videosModel() {}

func (p videosWithPrismaCreatedAtSetParam) createdAtField() {}

type VideosWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	createdAtField()
}

type videosWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaCreatedAtEqualsParam) videosModel() {}

func (p videosWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (videosWithPrismaCreatedAtSetParam) settable()  {}
func (videosWithPrismaCreatedAtEqualsParam) equals() {}

type videosWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaCreatedAtEqualsUniqueParam) videosModel()    {}
func (p videosWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (videosWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (videosWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type VideosWithPrismaOwnerEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	ownerField()
}

type VideosWithPrismaOwnerSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	ownerField()
}

type videosWithPrismaOwnerSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaOwnerSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaOwnerSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaOwnerSetParam) videosModel() {}

func (p videosWithPrismaOwnerSetParam) ownerField() {}

type VideosWithPrismaOwnerWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	ownerField()
}

type videosWithPrismaOwnerEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaOwnerEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaOwnerEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaOwnerEqualsParam) videosModel() {}

func (p videosWithPrismaOwnerEqualsParam) ownerField() {}

func (videosWithPrismaOwnerSetParam) settable()  {}
func (videosWithPrismaOwnerEqualsParam) equals() {}

type videosWithPrismaOwnerEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaOwnerEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaOwnerEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaOwnerEqualsUniqueParam) videosModel() {}
func (p videosWithPrismaOwnerEqualsUniqueParam) ownerField()  {}

func (videosWithPrismaOwnerEqualsUniqueParam) unique() {}
func (videosWithPrismaOwnerEqualsUniqueParam) equals() {}

type VideosWithPrismaGuildEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	guildField()
}

type VideosWithPrismaGuildSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	guildField()
}

type videosWithPrismaGuildSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaGuildSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaGuildSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaGuildSetParam) videosModel() {}

func (p videosWithPrismaGuildSetParam) guildField() {}

type VideosWithPrismaGuildWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	guildField()
}

type videosWithPrismaGuildEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaGuildEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaGuildEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaGuildEqualsParam) videosModel() {}

func (p videosWithPrismaGuildEqualsParam) guildField() {}

func (videosWithPrismaGuildSetParam) settable()  {}
func (videosWithPrismaGuildEqualsParam) equals() {}

type videosWithPrismaGuildEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaGuildEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaGuildEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaGuildEqualsUniqueParam) videosModel() {}
func (p videosWithPrismaGuildEqualsUniqueParam) guildField()  {}

func (videosWithPrismaGuildEqualsUniqueParam) unique() {}
func (videosWithPrismaGuildEqualsUniqueParam) equals() {}

type VideosWithPrismaTagsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	tagsField()
}

type VideosWithPrismaTagsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	tagsField()
}

type videosWithPrismaTagsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaTagsSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaTagsSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaTagsSetParam) videosModel() {}

func (p videosWithPrismaTagsSetParam) tagsField() {}

type VideosWithPrismaTagsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	tagsField()
}

type videosWithPrismaTagsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaTagsEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaTagsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaTagsEqualsParam) videosModel() {}

func (p videosWithPrismaTagsEqualsParam) tagsField() {}

func (videosWithPrismaTagsSetParam) settable()  {}
func (videosWithPrismaTagsEqualsParam) equals() {}

type videosWithPrismaTagsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaTagsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaTagsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaTagsEqualsUniqueParam) videosModel() {}
func (p videosWithPrismaTagsEqualsUniqueParam) tagsField()   {}

func (videosWithPrismaTagsEqualsUniqueParam) unique() {}
func (videosWithPrismaTagsEqualsUniqueParam) equals() {}

type VideosWithPrismaIsPrivateEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	isPrivateField()
}

type VideosWithPrismaIsPrivateSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	isPrivateField()
}

type videosWithPrismaIsPrivateSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaIsPrivateSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaIsPrivateSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaIsPrivateSetParam) videosModel() {}

func (p videosWithPrismaIsPrivateSetParam) isPrivateField() {}

type VideosWithPrismaIsPrivateWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	isPrivateField()
}

type videosWithPrismaIsPrivateEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaIsPrivateEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaIsPrivateEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaIsPrivateEqualsParam) videosModel() {}

func (p videosWithPrismaIsPrivateEqualsParam) isPrivateField() {}

func (videosWithPrismaIsPrivateSetParam) settable()  {}
func (videosWithPrismaIsPrivateEqualsParam) equals() {}

type videosWithPrismaIsPrivateEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaIsPrivateEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaIsPrivateEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaIsPrivateEqualsUniqueParam) videosModel()    {}
func (p videosWithPrismaIsPrivateEqualsUniqueParam) isPrivateField() {}

func (videosWithPrismaIsPrivateEqualsUniqueParam) unique() {}
func (videosWithPrismaIsPrivateEqualsUniqueParam) equals() {}

type VideosWithPrismaLikesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	likesField()
}

type VideosWithPrismaLikesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	likesField()
}

type videosWithPrismaLikesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaLikesSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaLikesSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaLikesSetParam) videosModel() {}

func (p videosWithPrismaLikesSetParam) likesField() {}

type VideosWithPrismaLikesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	likesField()
}

type videosWithPrismaLikesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaLikesEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaLikesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaLikesEqualsParam) videosModel() {}

func (p videosWithPrismaLikesEqualsParam) likesField() {}

func (videosWithPrismaLikesSetParam) settable()  {}
func (videosWithPrismaLikesEqualsParam) equals() {}

type videosWithPrismaLikesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaLikesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaLikesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaLikesEqualsUniqueParam) videosModel() {}
func (p videosWithPrismaLikesEqualsUniqueParam) likesField()  {}

func (videosWithPrismaLikesEqualsUniqueParam) unique() {}
func (videosWithPrismaLikesEqualsUniqueParam) equals() {}

type VideosWithPrismaViewsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	viewsField()
}

type VideosWithPrismaViewsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	viewsField()
}

type videosWithPrismaViewsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaViewsSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaViewsSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaViewsSetParam) videosModel() {}

func (p videosWithPrismaViewsSetParam) viewsField() {}

type VideosWithPrismaViewsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	viewsField()
}

type videosWithPrismaViewsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaViewsEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaViewsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaViewsEqualsParam) videosModel() {}

func (p videosWithPrismaViewsEqualsParam) viewsField() {}

func (videosWithPrismaViewsSetParam) settable()  {}
func (videosWithPrismaViewsEqualsParam) equals() {}

type videosWithPrismaViewsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaViewsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaViewsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaViewsEqualsUniqueParam) videosModel() {}
func (p videosWithPrismaViewsEqualsUniqueParam) viewsField()  {}

func (videosWithPrismaViewsEqualsUniqueParam) unique() {}
func (videosWithPrismaViewsEqualsUniqueParam) equals() {}

type VideosWithPrismaHistoryEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	historyField()
}

type VideosWithPrismaHistorySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	historyField()
}

type videosWithPrismaHistorySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaHistorySetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaHistorySetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaHistorySetParam) videosModel() {}

func (p videosWithPrismaHistorySetParam) historyField() {}

type VideosWithPrismaHistoryWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	historyField()
}

type videosWithPrismaHistoryEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaHistoryEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaHistoryEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaHistoryEqualsParam) videosModel() {}

func (p videosWithPrismaHistoryEqualsParam) historyField() {}

func (videosWithPrismaHistorySetParam) settable()  {}
func (videosWithPrismaHistoryEqualsParam) equals() {}

type videosWithPrismaHistoryEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaHistoryEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaHistoryEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaHistoryEqualsUniqueParam) videosModel()  {}
func (p videosWithPrismaHistoryEqualsUniqueParam) historyField() {}

func (videosWithPrismaHistoryEqualsUniqueParam) unique() {}
func (videosWithPrismaHistoryEqualsUniqueParam) equals() {}

type VideosWithPrismaWatchLaterEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	videosModel()
	watchLaterField()
}

type VideosWithPrismaWatchLaterSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	watchLaterField()
}

type videosWithPrismaWatchLaterSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaWatchLaterSetParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaWatchLaterSetParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaWatchLaterSetParam) videosModel() {}

func (p videosWithPrismaWatchLaterSetParam) watchLaterField() {}

type VideosWithPrismaWatchLaterWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	videosModel()
	watchLaterField()
}

type videosWithPrismaWatchLaterEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaWatchLaterEqualsParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaWatchLaterEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaWatchLaterEqualsParam) videosModel() {}

func (p videosWithPrismaWatchLaterEqualsParam) watchLaterField() {}

func (videosWithPrismaWatchLaterSetParam) settable()  {}
func (videosWithPrismaWatchLaterEqualsParam) equals() {}

type videosWithPrismaWatchLaterEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p videosWithPrismaWatchLaterEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p videosWithPrismaWatchLaterEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p videosWithPrismaWatchLaterEqualsUniqueParam) videosModel()     {}
func (p videosWithPrismaWatchLaterEqualsUniqueParam) watchLaterField() {}

func (videosWithPrismaWatchLaterEqualsUniqueParam) unique() {}
func (videosWithPrismaWatchLaterEqualsUniqueParam) equals() {}

type tagsActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var tagsOutput = []builder.Output{
	{Name: "id"},
	{Name: "name"},
	{Name: "guildId"},
}

type TagsRelationWith interface {
	getQuery() builder.Query
	with()
	tagsRelation()
}

type TagsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsModel()
}

type tagsDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsDefaultParam) field() builder.Field {
	return p.data
}

func (p tagsDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p tagsDefaultParam) tagsModel() {}

type TagsOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsModel()
}

type tagsOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOrderByParam) field() builder.Field {
	return p.data
}

func (p tagsOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOrderByParam) tagsModel() {}

type TagsCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsModel()
	isCursor()
}

type tagsCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsCursorParam) field() builder.Field {
	return p.data
}

func (p tagsCursorParam) isCursor() {}

func (p tagsCursorParam) getQuery() builder.Query {
	return p.query
}

func (p tagsCursorParam) tagsModel() {}

type TagsParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	tagsModel()
}

type tagsParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p tagsParamUnique) tagsModel() {}

func (tagsParamUnique) unique() {}

func (p tagsParamUnique) field() builder.Field {
	return p.data
}

func (p tagsParamUnique) getQuery() builder.Query {
	return p.query
}

type TagsEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagsModel()
}

type tagsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsEqualsParam) tagsModel() {}

func (tagsEqualsParam) equals() {}

func (p tagsEqualsParam) field() builder.Field {
	return p.data
}

func (p tagsEqualsParam) getQuery() builder.Query {
	return p.query
}

type TagsEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	tagsModel()
}

type tagsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsEqualsUniqueParam) tagsModel() {}

func (tagsEqualsUniqueParam) unique() {}
func (tagsEqualsUniqueParam) equals() {}

func (p tagsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type TagsSetParam interface {
	field() builder.Field
	settable()
	tagsModel()
}

type tagsSetParam struct {
	data builder.Field
}

func (tagsSetParam) settable() {}

func (p tagsSetParam) field() builder.Field {
	return p.data
}

func (p tagsSetParam) tagsModel() {}

type TagsWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagsModel()
	idField()
}

type TagsWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsModel()
	idField()
}

type tagsWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaIDSetParam) tagsModel() {}

func (p tagsWithPrismaIDSetParam) idField() {}

type TagsWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsModel()
	idField()
}

type tagsWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaIDEqualsParam) tagsModel() {}

func (p tagsWithPrismaIDEqualsParam) idField() {}

func (tagsWithPrismaIDSetParam) settable()  {}
func (tagsWithPrismaIDEqualsParam) equals() {}

type tagsWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaIDEqualsUniqueParam) tagsModel() {}
func (p tagsWithPrismaIDEqualsUniqueParam) idField()   {}

func (tagsWithPrismaIDEqualsUniqueParam) unique() {}
func (tagsWithPrismaIDEqualsUniqueParam) equals() {}

type TagsWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagsModel()
	nameField()
}

type TagsWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsModel()
	nameField()
}

type tagsWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaNameSetParam) tagsModel() {}

func (p tagsWithPrismaNameSetParam) nameField() {}

type TagsWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsModel()
	nameField()
}

type tagsWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaNameEqualsParam) tagsModel() {}

func (p tagsWithPrismaNameEqualsParam) nameField() {}

func (tagsWithPrismaNameSetParam) settable()  {}
func (tagsWithPrismaNameEqualsParam) equals() {}

type tagsWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaNameEqualsUniqueParam) tagsModel() {}
func (p tagsWithPrismaNameEqualsUniqueParam) nameField() {}

func (tagsWithPrismaNameEqualsUniqueParam) unique() {}
func (tagsWithPrismaNameEqualsUniqueParam) equals() {}

type TagsWithPrismaGuildIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagsModel()
	guildIDField()
}

type TagsWithPrismaGuildIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsModel()
	guildIDField()
}

type tagsWithPrismaGuildIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaGuildIDSetParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaGuildIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaGuildIDSetParam) tagsModel() {}

func (p tagsWithPrismaGuildIDSetParam) guildIDField() {}

type TagsWithPrismaGuildIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsModel()
	guildIDField()
}

type tagsWithPrismaGuildIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaGuildIDEqualsParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaGuildIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaGuildIDEqualsParam) tagsModel() {}

func (p tagsWithPrismaGuildIDEqualsParam) guildIDField() {}

func (tagsWithPrismaGuildIDSetParam) settable()  {}
func (tagsWithPrismaGuildIDEqualsParam) equals() {}

type tagsWithPrismaGuildIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaGuildIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaGuildIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaGuildIDEqualsUniqueParam) tagsModel()    {}
func (p tagsWithPrismaGuildIDEqualsUniqueParam) guildIDField() {}

func (tagsWithPrismaGuildIDEqualsUniqueParam) unique() {}
func (tagsWithPrismaGuildIDEqualsUniqueParam) equals() {}

type TagsWithPrismaGuildEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagsModel()
	guildField()
}

type TagsWithPrismaGuildSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsModel()
	guildField()
}

type tagsWithPrismaGuildSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaGuildSetParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaGuildSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaGuildSetParam) tagsModel() {}

func (p tagsWithPrismaGuildSetParam) guildField() {}

type TagsWithPrismaGuildWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsModel()
	guildField()
}

type tagsWithPrismaGuildEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaGuildEqualsParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaGuildEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaGuildEqualsParam) tagsModel() {}

func (p tagsWithPrismaGuildEqualsParam) guildField() {}

func (tagsWithPrismaGuildSetParam) settable()  {}
func (tagsWithPrismaGuildEqualsParam) equals() {}

type tagsWithPrismaGuildEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaGuildEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaGuildEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaGuildEqualsUniqueParam) tagsModel()  {}
func (p tagsWithPrismaGuildEqualsUniqueParam) guildField() {}

func (tagsWithPrismaGuildEqualsUniqueParam) unique() {}
func (tagsWithPrismaGuildEqualsUniqueParam) equals() {}

type TagsWithPrismaVideosEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagsModel()
	videosField()
}

type TagsWithPrismaVideosSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsModel()
	videosField()
}

type tagsWithPrismaVideosSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaVideosSetParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaVideosSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaVideosSetParam) tagsModel() {}

func (p tagsWithPrismaVideosSetParam) videosField() {}

type TagsWithPrismaVideosWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsModel()
	videosField()
}

type tagsWithPrismaVideosEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaVideosEqualsParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaVideosEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaVideosEqualsParam) tagsModel() {}

func (p tagsWithPrismaVideosEqualsParam) videosField() {}

func (tagsWithPrismaVideosSetParam) settable()  {}
func (tagsWithPrismaVideosEqualsParam) equals() {}

type tagsWithPrismaVideosEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsWithPrismaVideosEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagsWithPrismaVideosEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagsWithPrismaVideosEqualsUniqueParam) tagsModel()   {}
func (p tagsWithPrismaVideosEqualsUniqueParam) videosField() {}

func (tagsWithPrismaVideosEqualsUniqueParam) unique() {}
func (tagsWithPrismaVideosEqualsUniqueParam) equals() {}

type tagsOnVideosActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var tagsOnVideosOutput = []builder.Output{
	{Name: "id"},
	{Name: "videoId"},
	{Name: "tagId"},
}

type TagsOnVideosRelationWith interface {
	getQuery() builder.Query
	with()
	tagsOnVideosRelation()
}

type TagsOnVideosWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsOnVideosModel()
}

type tagsOnVideosDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosDefaultParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosDefaultParam) tagsOnVideosModel() {}

type TagsOnVideosOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsOnVideosModel()
}

type tagsOnVideosOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosOrderByParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosOrderByParam) tagsOnVideosModel() {}

type TagsOnVideosCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsOnVideosModel()
	isCursor()
}

type tagsOnVideosCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosCursorParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosCursorParam) isCursor() {}

func (p tagsOnVideosCursorParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosCursorParam) tagsOnVideosModel() {}

type TagsOnVideosParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	tagsOnVideosModel()
}

type tagsOnVideosParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosParamUnique) tagsOnVideosModel() {}

func (tagsOnVideosParamUnique) unique() {}

func (p tagsOnVideosParamUnique) field() builder.Field {
	return p.data
}

func (p tagsOnVideosParamUnique) getQuery() builder.Query {
	return p.query
}

type TagsOnVideosEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagsOnVideosModel()
}

type tagsOnVideosEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosEqualsParam) tagsOnVideosModel() {}

func (tagsOnVideosEqualsParam) equals() {}

func (p tagsOnVideosEqualsParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosEqualsParam) getQuery() builder.Query {
	return p.query
}

type TagsOnVideosEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	tagsOnVideosModel()
}

type tagsOnVideosEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosEqualsUniqueParam) tagsOnVideosModel() {}

func (tagsOnVideosEqualsUniqueParam) unique() {}
func (tagsOnVideosEqualsUniqueParam) equals() {}

func (p tagsOnVideosEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type TagsOnVideosSetParam interface {
	field() builder.Field
	settable()
	tagsOnVideosModel()
}

type tagsOnVideosSetParam struct {
	data builder.Field
}

func (tagsOnVideosSetParam) settable() {}

func (p tagsOnVideosSetParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosSetParam) tagsOnVideosModel() {}

type TagsOnVideosWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagsOnVideosModel()
	idField()
}

type TagsOnVideosWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsOnVideosModel()
	idField()
}

type tagsOnVideosWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaIDSetParam) tagsOnVideosModel() {}

func (p tagsOnVideosWithPrismaIDSetParam) idField() {}

type TagsOnVideosWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsOnVideosModel()
	idField()
}

type tagsOnVideosWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaIDEqualsParam) tagsOnVideosModel() {}

func (p tagsOnVideosWithPrismaIDEqualsParam) idField() {}

func (tagsOnVideosWithPrismaIDSetParam) settable()  {}
func (tagsOnVideosWithPrismaIDEqualsParam) equals() {}

type tagsOnVideosWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaIDEqualsUniqueParam) tagsOnVideosModel() {}
func (p tagsOnVideosWithPrismaIDEqualsUniqueParam) idField()           {}

func (tagsOnVideosWithPrismaIDEqualsUniqueParam) unique() {}
func (tagsOnVideosWithPrismaIDEqualsUniqueParam) equals() {}

type TagsOnVideosWithPrismaVideoIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagsOnVideosModel()
	videoIDField()
}

type TagsOnVideosWithPrismaVideoIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsOnVideosModel()
	videoIDField()
}

type tagsOnVideosWithPrismaVideoIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaVideoIDSetParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaVideoIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaVideoIDSetParam) tagsOnVideosModel() {}

func (p tagsOnVideosWithPrismaVideoIDSetParam) videoIDField() {}

type TagsOnVideosWithPrismaVideoIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsOnVideosModel()
	videoIDField()
}

type tagsOnVideosWithPrismaVideoIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaVideoIDEqualsParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaVideoIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaVideoIDEqualsParam) tagsOnVideosModel() {}

func (p tagsOnVideosWithPrismaVideoIDEqualsParam) videoIDField() {}

func (tagsOnVideosWithPrismaVideoIDSetParam) settable()  {}
func (tagsOnVideosWithPrismaVideoIDEqualsParam) equals() {}

type tagsOnVideosWithPrismaVideoIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaVideoIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaVideoIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaVideoIDEqualsUniqueParam) tagsOnVideosModel() {}
func (p tagsOnVideosWithPrismaVideoIDEqualsUniqueParam) videoIDField()      {}

func (tagsOnVideosWithPrismaVideoIDEqualsUniqueParam) unique() {}
func (tagsOnVideosWithPrismaVideoIDEqualsUniqueParam) equals() {}

type TagsOnVideosWithPrismaTagIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagsOnVideosModel()
	tagIDField()
}

type TagsOnVideosWithPrismaTagIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsOnVideosModel()
	tagIDField()
}

type tagsOnVideosWithPrismaTagIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaTagIDSetParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaTagIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaTagIDSetParam) tagsOnVideosModel() {}

func (p tagsOnVideosWithPrismaTagIDSetParam) tagIDField() {}

type TagsOnVideosWithPrismaTagIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsOnVideosModel()
	tagIDField()
}

type tagsOnVideosWithPrismaTagIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaTagIDEqualsParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaTagIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaTagIDEqualsParam) tagsOnVideosModel() {}

func (p tagsOnVideosWithPrismaTagIDEqualsParam) tagIDField() {}

func (tagsOnVideosWithPrismaTagIDSetParam) settable()  {}
func (tagsOnVideosWithPrismaTagIDEqualsParam) equals() {}

type tagsOnVideosWithPrismaTagIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaTagIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaTagIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaTagIDEqualsUniqueParam) tagsOnVideosModel() {}
func (p tagsOnVideosWithPrismaTagIDEqualsUniqueParam) tagIDField()        {}

func (tagsOnVideosWithPrismaTagIDEqualsUniqueParam) unique() {}
func (tagsOnVideosWithPrismaTagIDEqualsUniqueParam) equals() {}

type TagsOnVideosWithPrismaVideoEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagsOnVideosModel()
	videoField()
}

type TagsOnVideosWithPrismaVideoSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsOnVideosModel()
	videoField()
}

type tagsOnVideosWithPrismaVideoSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaVideoSetParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaVideoSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaVideoSetParam) tagsOnVideosModel() {}

func (p tagsOnVideosWithPrismaVideoSetParam) videoField() {}

type TagsOnVideosWithPrismaVideoWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsOnVideosModel()
	videoField()
}

type tagsOnVideosWithPrismaVideoEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaVideoEqualsParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaVideoEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaVideoEqualsParam) tagsOnVideosModel() {}

func (p tagsOnVideosWithPrismaVideoEqualsParam) videoField() {}

func (tagsOnVideosWithPrismaVideoSetParam) settable()  {}
func (tagsOnVideosWithPrismaVideoEqualsParam) equals() {}

type tagsOnVideosWithPrismaVideoEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaVideoEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaVideoEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaVideoEqualsUniqueParam) tagsOnVideosModel() {}
func (p tagsOnVideosWithPrismaVideoEqualsUniqueParam) videoField()        {}

func (tagsOnVideosWithPrismaVideoEqualsUniqueParam) unique() {}
func (tagsOnVideosWithPrismaVideoEqualsUniqueParam) equals() {}

type TagsOnVideosWithPrismaTagEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	tagsOnVideosModel()
	tagField()
}

type TagsOnVideosWithPrismaTagSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsOnVideosModel()
	tagField()
}

type tagsOnVideosWithPrismaTagSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaTagSetParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaTagSetParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaTagSetParam) tagsOnVideosModel() {}

func (p tagsOnVideosWithPrismaTagSetParam) tagField() {}

type TagsOnVideosWithPrismaTagWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	tagsOnVideosModel()
	tagField()
}

type tagsOnVideosWithPrismaTagEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaTagEqualsParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaTagEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaTagEqualsParam) tagsOnVideosModel() {}

func (p tagsOnVideosWithPrismaTagEqualsParam) tagField() {}

func (tagsOnVideosWithPrismaTagSetParam) settable()  {}
func (tagsOnVideosWithPrismaTagEqualsParam) equals() {}

type tagsOnVideosWithPrismaTagEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p tagsOnVideosWithPrismaTagEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p tagsOnVideosWithPrismaTagEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosWithPrismaTagEqualsUniqueParam) tagsOnVideosModel() {}
func (p tagsOnVideosWithPrismaTagEqualsUniqueParam) tagField()          {}

func (tagsOnVideosWithPrismaTagEqualsUniqueParam) unique() {}
func (tagsOnVideosWithPrismaTagEqualsUniqueParam) equals() {}

type commentsActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var commentsOutput = []builder.Output{
	{Name: "id"},
	{Name: "ownerId"},
	{Name: "role"},
	{Name: "videoId"},
	{Name: "content"},
	{Name: "createdAt"},
}

type CommentsRelationWith interface {
	getQuery() builder.Query
	with()
	commentsRelation()
}

type CommentsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
}

type commentsDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsDefaultParam) field() builder.Field {
	return p.data
}

func (p commentsDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p commentsDefaultParam) commentsModel() {}

type CommentsOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
}

type commentsOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsOrderByParam) field() builder.Field {
	return p.data
}

func (p commentsOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p commentsOrderByParam) commentsModel() {}

type CommentsCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	isCursor()
}

type commentsCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsCursorParam) field() builder.Field {
	return p.data
}

func (p commentsCursorParam) isCursor() {}

func (p commentsCursorParam) getQuery() builder.Query {
	return p.query
}

func (p commentsCursorParam) commentsModel() {}

type CommentsParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	commentsModel()
}

type commentsParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p commentsParamUnique) commentsModel() {}

func (commentsParamUnique) unique() {}

func (p commentsParamUnique) field() builder.Field {
	return p.data
}

func (p commentsParamUnique) getQuery() builder.Query {
	return p.query
}

type CommentsEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentsModel()
}

type commentsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsEqualsParam) commentsModel() {}

func (commentsEqualsParam) equals() {}

func (p commentsEqualsParam) field() builder.Field {
	return p.data
}

func (p commentsEqualsParam) getQuery() builder.Query {
	return p.query
}

type CommentsEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	commentsModel()
}

type commentsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsEqualsUniqueParam) commentsModel() {}

func (commentsEqualsUniqueParam) unique() {}
func (commentsEqualsUniqueParam) equals() {}

func (p commentsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type CommentsSetParam interface {
	field() builder.Field
	settable()
	commentsModel()
}

type commentsSetParam struct {
	data builder.Field
}

func (commentsSetParam) settable() {}

func (p commentsSetParam) field() builder.Field {
	return p.data
}

func (p commentsSetParam) commentsModel() {}

type CommentsWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentsModel()
	idField()
}

type CommentsWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	idField()
}

type commentsWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaIDSetParam) commentsModel() {}

func (p commentsWithPrismaIDSetParam) idField() {}

type CommentsWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	idField()
}

type commentsWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaIDEqualsParam) commentsModel() {}

func (p commentsWithPrismaIDEqualsParam) idField() {}

func (commentsWithPrismaIDSetParam) settable()  {}
func (commentsWithPrismaIDEqualsParam) equals() {}

type commentsWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaIDEqualsUniqueParam) commentsModel() {}
func (p commentsWithPrismaIDEqualsUniqueParam) idField()       {}

func (commentsWithPrismaIDEqualsUniqueParam) unique() {}
func (commentsWithPrismaIDEqualsUniqueParam) equals() {}

type CommentsWithPrismaOwnerIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentsModel()
	ownerIDField()
}

type CommentsWithPrismaOwnerIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	ownerIDField()
}

type commentsWithPrismaOwnerIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaOwnerIDSetParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaOwnerIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaOwnerIDSetParam) commentsModel() {}

func (p commentsWithPrismaOwnerIDSetParam) ownerIDField() {}

type CommentsWithPrismaOwnerIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	ownerIDField()
}

type commentsWithPrismaOwnerIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaOwnerIDEqualsParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaOwnerIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaOwnerIDEqualsParam) commentsModel() {}

func (p commentsWithPrismaOwnerIDEqualsParam) ownerIDField() {}

func (commentsWithPrismaOwnerIDSetParam) settable()  {}
func (commentsWithPrismaOwnerIDEqualsParam) equals() {}

type commentsWithPrismaOwnerIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaOwnerIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaOwnerIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaOwnerIDEqualsUniqueParam) commentsModel() {}
func (p commentsWithPrismaOwnerIDEqualsUniqueParam) ownerIDField()  {}

func (commentsWithPrismaOwnerIDEqualsUniqueParam) unique() {}
func (commentsWithPrismaOwnerIDEqualsUniqueParam) equals() {}

type CommentsWithPrismaRoleEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentsModel()
	roleField()
}

type CommentsWithPrismaRoleSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	roleField()
}

type commentsWithPrismaRoleSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaRoleSetParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaRoleSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaRoleSetParam) commentsModel() {}

func (p commentsWithPrismaRoleSetParam) roleField() {}

type CommentsWithPrismaRoleWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	roleField()
}

type commentsWithPrismaRoleEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaRoleEqualsParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaRoleEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaRoleEqualsParam) commentsModel() {}

func (p commentsWithPrismaRoleEqualsParam) roleField() {}

func (commentsWithPrismaRoleSetParam) settable()  {}
func (commentsWithPrismaRoleEqualsParam) equals() {}

type commentsWithPrismaRoleEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaRoleEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaRoleEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaRoleEqualsUniqueParam) commentsModel() {}
func (p commentsWithPrismaRoleEqualsUniqueParam) roleField()     {}

func (commentsWithPrismaRoleEqualsUniqueParam) unique() {}
func (commentsWithPrismaRoleEqualsUniqueParam) equals() {}

type CommentsWithPrismaVideoIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentsModel()
	videoIDField()
}

type CommentsWithPrismaVideoIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	videoIDField()
}

type commentsWithPrismaVideoIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaVideoIDSetParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaVideoIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaVideoIDSetParam) commentsModel() {}

func (p commentsWithPrismaVideoIDSetParam) videoIDField() {}

type CommentsWithPrismaVideoIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	videoIDField()
}

type commentsWithPrismaVideoIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaVideoIDEqualsParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaVideoIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaVideoIDEqualsParam) commentsModel() {}

func (p commentsWithPrismaVideoIDEqualsParam) videoIDField() {}

func (commentsWithPrismaVideoIDSetParam) settable()  {}
func (commentsWithPrismaVideoIDEqualsParam) equals() {}

type commentsWithPrismaVideoIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaVideoIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaVideoIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaVideoIDEqualsUniqueParam) commentsModel() {}
func (p commentsWithPrismaVideoIDEqualsUniqueParam) videoIDField()  {}

func (commentsWithPrismaVideoIDEqualsUniqueParam) unique() {}
func (commentsWithPrismaVideoIDEqualsUniqueParam) equals() {}

type CommentsWithPrismaContentEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentsModel()
	contentField()
}

type CommentsWithPrismaContentSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	contentField()
}

type commentsWithPrismaContentSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaContentSetParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaContentSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaContentSetParam) commentsModel() {}

func (p commentsWithPrismaContentSetParam) contentField() {}

type CommentsWithPrismaContentWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	contentField()
}

type commentsWithPrismaContentEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaContentEqualsParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaContentEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaContentEqualsParam) commentsModel() {}

func (p commentsWithPrismaContentEqualsParam) contentField() {}

func (commentsWithPrismaContentSetParam) settable()  {}
func (commentsWithPrismaContentEqualsParam) equals() {}

type commentsWithPrismaContentEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaContentEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaContentEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaContentEqualsUniqueParam) commentsModel() {}
func (p commentsWithPrismaContentEqualsUniqueParam) contentField()  {}

func (commentsWithPrismaContentEqualsUniqueParam) unique() {}
func (commentsWithPrismaContentEqualsUniqueParam) equals() {}

type CommentsWithPrismaLikesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentsModel()
	likesField()
}

type CommentsWithPrismaLikesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	likesField()
}

type commentsWithPrismaLikesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaLikesSetParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaLikesSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaLikesSetParam) commentsModel() {}

func (p commentsWithPrismaLikesSetParam) likesField() {}

type CommentsWithPrismaLikesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	likesField()
}

type commentsWithPrismaLikesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaLikesEqualsParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaLikesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaLikesEqualsParam) commentsModel() {}

func (p commentsWithPrismaLikesEqualsParam) likesField() {}

func (commentsWithPrismaLikesSetParam) settable()  {}
func (commentsWithPrismaLikesEqualsParam) equals() {}

type commentsWithPrismaLikesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaLikesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaLikesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaLikesEqualsUniqueParam) commentsModel() {}
func (p commentsWithPrismaLikesEqualsUniqueParam) likesField()    {}

func (commentsWithPrismaLikesEqualsUniqueParam) unique() {}
func (commentsWithPrismaLikesEqualsUniqueParam) equals() {}

type CommentsWithPrismaOwnerEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentsModel()
	ownerField()
}

type CommentsWithPrismaOwnerSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	ownerField()
}

type commentsWithPrismaOwnerSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaOwnerSetParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaOwnerSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaOwnerSetParam) commentsModel() {}

func (p commentsWithPrismaOwnerSetParam) ownerField() {}

type CommentsWithPrismaOwnerWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	ownerField()
}

type commentsWithPrismaOwnerEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaOwnerEqualsParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaOwnerEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaOwnerEqualsParam) commentsModel() {}

func (p commentsWithPrismaOwnerEqualsParam) ownerField() {}

func (commentsWithPrismaOwnerSetParam) settable()  {}
func (commentsWithPrismaOwnerEqualsParam) equals() {}

type commentsWithPrismaOwnerEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaOwnerEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaOwnerEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaOwnerEqualsUniqueParam) commentsModel() {}
func (p commentsWithPrismaOwnerEqualsUniqueParam) ownerField()    {}

func (commentsWithPrismaOwnerEqualsUniqueParam) unique() {}
func (commentsWithPrismaOwnerEqualsUniqueParam) equals() {}

type CommentsWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	commentsModel()
	createdAtField()
}

type CommentsWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	createdAtField()
}

type commentsWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaCreatedAtSetParam) commentsModel() {}

func (p commentsWithPrismaCreatedAtSetParam) createdAtField() {}

type CommentsWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	commentsModel()
	createdAtField()
}

type commentsWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaCreatedAtEqualsParam) commentsModel() {}

func (p commentsWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (commentsWithPrismaCreatedAtSetParam) settable()  {}
func (commentsWithPrismaCreatedAtEqualsParam) equals() {}

type commentsWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p commentsWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p commentsWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p commentsWithPrismaCreatedAtEqualsUniqueParam) commentsModel()  {}
func (p commentsWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (commentsWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (commentsWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type repliesActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var repliesOutput = []builder.Output{
	{Name: "id"},
	{Name: "ownerId"},
	{Name: "role"},
	{Name: "commentId"},
	{Name: "replyId"},
	{Name: "content"},
	{Name: "createdAt"},
	{Name: "videoId"},
}

type RepliesRelationWith interface {
	getQuery() builder.Query
	with()
	repliesRelation()
}

type RepliesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
}

type repliesDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesDefaultParam) field() builder.Field {
	return p.data
}

func (p repliesDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p repliesDefaultParam) repliesModel() {}

type RepliesOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
}

type repliesOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesOrderByParam) field() builder.Field {
	return p.data
}

func (p repliesOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p repliesOrderByParam) repliesModel() {}

type RepliesCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	isCursor()
}

type repliesCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesCursorParam) field() builder.Field {
	return p.data
}

func (p repliesCursorParam) isCursor() {}

func (p repliesCursorParam) getQuery() builder.Query {
	return p.query
}

func (p repliesCursorParam) repliesModel() {}

type RepliesParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	repliesModel()
}

type repliesParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p repliesParamUnique) repliesModel() {}

func (repliesParamUnique) unique() {}

func (p repliesParamUnique) field() builder.Field {
	return p.data
}

func (p repliesParamUnique) getQuery() builder.Query {
	return p.query
}

type RepliesEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	repliesModel()
}

type repliesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesEqualsParam) repliesModel() {}

func (repliesEqualsParam) equals() {}

func (p repliesEqualsParam) field() builder.Field {
	return p.data
}

func (p repliesEqualsParam) getQuery() builder.Query {
	return p.query
}

type RepliesEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	repliesModel()
}

type repliesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesEqualsUniqueParam) repliesModel() {}

func (repliesEqualsUniqueParam) unique() {}
func (repliesEqualsUniqueParam) equals() {}

func (p repliesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p repliesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type RepliesSetParam interface {
	field() builder.Field
	settable()
	repliesModel()
}

type repliesSetParam struct {
	data builder.Field
}

func (repliesSetParam) settable() {}

func (p repliesSetParam) field() builder.Field {
	return p.data
}

func (p repliesSetParam) repliesModel() {}

type RepliesWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	repliesModel()
	idField()
}

type RepliesWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	idField()
}

type repliesWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaIDSetParam) repliesModel() {}

func (p repliesWithPrismaIDSetParam) idField() {}

type RepliesWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	idField()
}

type repliesWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaIDEqualsParam) repliesModel() {}

func (p repliesWithPrismaIDEqualsParam) idField() {}

func (repliesWithPrismaIDSetParam) settable()  {}
func (repliesWithPrismaIDEqualsParam) equals() {}

type repliesWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaIDEqualsUniqueParam) repliesModel() {}
func (p repliesWithPrismaIDEqualsUniqueParam) idField()      {}

func (repliesWithPrismaIDEqualsUniqueParam) unique() {}
func (repliesWithPrismaIDEqualsUniqueParam) equals() {}

type RepliesWithPrismaOwnerIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	repliesModel()
	ownerIDField()
}

type RepliesWithPrismaOwnerIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	ownerIDField()
}

type repliesWithPrismaOwnerIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaOwnerIDSetParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaOwnerIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaOwnerIDSetParam) repliesModel() {}

func (p repliesWithPrismaOwnerIDSetParam) ownerIDField() {}

type RepliesWithPrismaOwnerIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	ownerIDField()
}

type repliesWithPrismaOwnerIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaOwnerIDEqualsParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaOwnerIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaOwnerIDEqualsParam) repliesModel() {}

func (p repliesWithPrismaOwnerIDEqualsParam) ownerIDField() {}

func (repliesWithPrismaOwnerIDSetParam) settable()  {}
func (repliesWithPrismaOwnerIDEqualsParam) equals() {}

type repliesWithPrismaOwnerIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaOwnerIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaOwnerIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaOwnerIDEqualsUniqueParam) repliesModel() {}
func (p repliesWithPrismaOwnerIDEqualsUniqueParam) ownerIDField() {}

func (repliesWithPrismaOwnerIDEqualsUniqueParam) unique() {}
func (repliesWithPrismaOwnerIDEqualsUniqueParam) equals() {}

type RepliesWithPrismaRoleEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	repliesModel()
	roleField()
}

type RepliesWithPrismaRoleSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	roleField()
}

type repliesWithPrismaRoleSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaRoleSetParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaRoleSetParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaRoleSetParam) repliesModel() {}

func (p repliesWithPrismaRoleSetParam) roleField() {}

type RepliesWithPrismaRoleWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	roleField()
}

type repliesWithPrismaRoleEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaRoleEqualsParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaRoleEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaRoleEqualsParam) repliesModel() {}

func (p repliesWithPrismaRoleEqualsParam) roleField() {}

func (repliesWithPrismaRoleSetParam) settable()  {}
func (repliesWithPrismaRoleEqualsParam) equals() {}

type repliesWithPrismaRoleEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaRoleEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaRoleEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaRoleEqualsUniqueParam) repliesModel() {}
func (p repliesWithPrismaRoleEqualsUniqueParam) roleField()    {}

func (repliesWithPrismaRoleEqualsUniqueParam) unique() {}
func (repliesWithPrismaRoleEqualsUniqueParam) equals() {}

type RepliesWithPrismaCommentIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	repliesModel()
	commentIDField()
}

type RepliesWithPrismaCommentIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	commentIDField()
}

type repliesWithPrismaCommentIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaCommentIDSetParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaCommentIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaCommentIDSetParam) repliesModel() {}

func (p repliesWithPrismaCommentIDSetParam) commentIDField() {}

type RepliesWithPrismaCommentIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	commentIDField()
}

type repliesWithPrismaCommentIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaCommentIDEqualsParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaCommentIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaCommentIDEqualsParam) repliesModel() {}

func (p repliesWithPrismaCommentIDEqualsParam) commentIDField() {}

func (repliesWithPrismaCommentIDSetParam) settable()  {}
func (repliesWithPrismaCommentIDEqualsParam) equals() {}

type repliesWithPrismaCommentIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaCommentIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaCommentIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaCommentIDEqualsUniqueParam) repliesModel()   {}
func (p repliesWithPrismaCommentIDEqualsUniqueParam) commentIDField() {}

func (repliesWithPrismaCommentIDEqualsUniqueParam) unique() {}
func (repliesWithPrismaCommentIDEqualsUniqueParam) equals() {}

type RepliesWithPrismaReplyIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	repliesModel()
	replyIDField()
}

type RepliesWithPrismaReplyIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	replyIDField()
}

type repliesWithPrismaReplyIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaReplyIDSetParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaReplyIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaReplyIDSetParam) repliesModel() {}

func (p repliesWithPrismaReplyIDSetParam) replyIDField() {}

type RepliesWithPrismaReplyIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	replyIDField()
}

type repliesWithPrismaReplyIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaReplyIDEqualsParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaReplyIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaReplyIDEqualsParam) repliesModel() {}

func (p repliesWithPrismaReplyIDEqualsParam) replyIDField() {}

func (repliesWithPrismaReplyIDSetParam) settable()  {}
func (repliesWithPrismaReplyIDEqualsParam) equals() {}

type repliesWithPrismaReplyIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaReplyIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaReplyIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaReplyIDEqualsUniqueParam) repliesModel() {}
func (p repliesWithPrismaReplyIDEqualsUniqueParam) replyIDField() {}

func (repliesWithPrismaReplyIDEqualsUniqueParam) unique() {}
func (repliesWithPrismaReplyIDEqualsUniqueParam) equals() {}

type RepliesWithPrismaContentEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	repliesModel()
	contentField()
}

type RepliesWithPrismaContentSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	contentField()
}

type repliesWithPrismaContentSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaContentSetParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaContentSetParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaContentSetParam) repliesModel() {}

func (p repliesWithPrismaContentSetParam) contentField() {}

type RepliesWithPrismaContentWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	contentField()
}

type repliesWithPrismaContentEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaContentEqualsParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaContentEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaContentEqualsParam) repliesModel() {}

func (p repliesWithPrismaContentEqualsParam) contentField() {}

func (repliesWithPrismaContentSetParam) settable()  {}
func (repliesWithPrismaContentEqualsParam) equals() {}

type repliesWithPrismaContentEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaContentEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaContentEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaContentEqualsUniqueParam) repliesModel() {}
func (p repliesWithPrismaContentEqualsUniqueParam) contentField() {}

func (repliesWithPrismaContentEqualsUniqueParam) unique() {}
func (repliesWithPrismaContentEqualsUniqueParam) equals() {}

type RepliesWithPrismaLikesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	repliesModel()
	likesField()
}

type RepliesWithPrismaLikesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	likesField()
}

type repliesWithPrismaLikesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaLikesSetParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaLikesSetParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaLikesSetParam) repliesModel() {}

func (p repliesWithPrismaLikesSetParam) likesField() {}

type RepliesWithPrismaLikesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	likesField()
}

type repliesWithPrismaLikesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaLikesEqualsParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaLikesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaLikesEqualsParam) repliesModel() {}

func (p repliesWithPrismaLikesEqualsParam) likesField() {}

func (repliesWithPrismaLikesSetParam) settable()  {}
func (repliesWithPrismaLikesEqualsParam) equals() {}

type repliesWithPrismaLikesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaLikesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaLikesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaLikesEqualsUniqueParam) repliesModel() {}
func (p repliesWithPrismaLikesEqualsUniqueParam) likesField()   {}

func (repliesWithPrismaLikesEqualsUniqueParam) unique() {}
func (repliesWithPrismaLikesEqualsUniqueParam) equals() {}

type RepliesWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	repliesModel()
	createdAtField()
}

type RepliesWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	createdAtField()
}

type repliesWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaCreatedAtSetParam) repliesModel() {}

func (p repliesWithPrismaCreatedAtSetParam) createdAtField() {}

type RepliesWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	createdAtField()
}

type repliesWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaCreatedAtEqualsParam) repliesModel() {}

func (p repliesWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (repliesWithPrismaCreatedAtSetParam) settable()  {}
func (repliesWithPrismaCreatedAtEqualsParam) equals() {}

type repliesWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaCreatedAtEqualsUniqueParam) repliesModel()   {}
func (p repliesWithPrismaCreatedAtEqualsUniqueParam) createdAtField() {}

func (repliesWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (repliesWithPrismaCreatedAtEqualsUniqueParam) equals() {}

type RepliesWithPrismaVideoIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	repliesModel()
	videoIDField()
}

type RepliesWithPrismaVideoIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	videoIDField()
}

type repliesWithPrismaVideoIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaVideoIDSetParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaVideoIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaVideoIDSetParam) repliesModel() {}

func (p repliesWithPrismaVideoIDSetParam) videoIDField() {}

type RepliesWithPrismaVideoIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	videoIDField()
}

type repliesWithPrismaVideoIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaVideoIDEqualsParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaVideoIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaVideoIDEqualsParam) repliesModel() {}

func (p repliesWithPrismaVideoIDEqualsParam) videoIDField() {}

func (repliesWithPrismaVideoIDSetParam) settable()  {}
func (repliesWithPrismaVideoIDEqualsParam) equals() {}

type repliesWithPrismaVideoIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaVideoIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaVideoIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaVideoIDEqualsUniqueParam) repliesModel() {}
func (p repliesWithPrismaVideoIDEqualsUniqueParam) videoIDField() {}

func (repliesWithPrismaVideoIDEqualsUniqueParam) unique() {}
func (repliesWithPrismaVideoIDEqualsUniqueParam) equals() {}

type RepliesWithPrismaOwnerEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	repliesModel()
	ownerField()
}

type RepliesWithPrismaOwnerSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	ownerField()
}

type repliesWithPrismaOwnerSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaOwnerSetParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaOwnerSetParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaOwnerSetParam) repliesModel() {}

func (p repliesWithPrismaOwnerSetParam) ownerField() {}

type RepliesWithPrismaOwnerWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	repliesModel()
	ownerField()
}

type repliesWithPrismaOwnerEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaOwnerEqualsParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaOwnerEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaOwnerEqualsParam) repliesModel() {}

func (p repliesWithPrismaOwnerEqualsParam) ownerField() {}

func (repliesWithPrismaOwnerSetParam) settable()  {}
func (repliesWithPrismaOwnerEqualsParam) equals() {}

type repliesWithPrismaOwnerEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p repliesWithPrismaOwnerEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p repliesWithPrismaOwnerEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p repliesWithPrismaOwnerEqualsUniqueParam) repliesModel() {}
func (p repliesWithPrismaOwnerEqualsUniqueParam) ownerField()   {}

func (repliesWithPrismaOwnerEqualsUniqueParam) unique() {}
func (repliesWithPrismaOwnerEqualsUniqueParam) equals() {}

type likesActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var likesOutput = []builder.Output{
	{Name: "id"},
	{Name: "entityType"},
	{Name: "ownerId"},
	{Name: "videoId"},
	{Name: "commentId"},
	{Name: "replyId"},
}

type LikesRelationWith interface {
	getQuery() builder.Query
	with()
	likesRelation()
}

type LikesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
}

type likesDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesDefaultParam) field() builder.Field {
	return p.data
}

func (p likesDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p likesDefaultParam) likesModel() {}

type LikesOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
}

type likesOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesOrderByParam) field() builder.Field {
	return p.data
}

func (p likesOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p likesOrderByParam) likesModel() {}

type LikesCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	isCursor()
}

type likesCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesCursorParam) field() builder.Field {
	return p.data
}

func (p likesCursorParam) isCursor() {}

func (p likesCursorParam) getQuery() builder.Query {
	return p.query
}

func (p likesCursorParam) likesModel() {}

type LikesParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	likesModel()
}

type likesParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p likesParamUnique) likesModel() {}

func (likesParamUnique) unique() {}

func (p likesParamUnique) field() builder.Field {
	return p.data
}

func (p likesParamUnique) getQuery() builder.Query {
	return p.query
}

type LikesEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likesModel()
}

type likesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesEqualsParam) likesModel() {}

func (likesEqualsParam) equals() {}

func (p likesEqualsParam) field() builder.Field {
	return p.data
}

func (p likesEqualsParam) getQuery() builder.Query {
	return p.query
}

type LikesEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	likesModel()
}

type likesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesEqualsUniqueParam) likesModel() {}

func (likesEqualsUniqueParam) unique() {}
func (likesEqualsUniqueParam) equals() {}

func (p likesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type LikesSetParam interface {
	field() builder.Field
	settable()
	likesModel()
}

type likesSetParam struct {
	data builder.Field
}

func (likesSetParam) settable() {}

func (p likesSetParam) field() builder.Field {
	return p.data
}

func (p likesSetParam) likesModel() {}

type LikesWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likesModel()
	idField()
}

type LikesWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	idField()
}

type likesWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaIDSetParam) likesModel() {}

func (p likesWithPrismaIDSetParam) idField() {}

type LikesWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	idField()
}

type likesWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaIDEqualsParam) likesModel() {}

func (p likesWithPrismaIDEqualsParam) idField() {}

func (likesWithPrismaIDSetParam) settable()  {}
func (likesWithPrismaIDEqualsParam) equals() {}

type likesWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaIDEqualsUniqueParam) likesModel() {}
func (p likesWithPrismaIDEqualsUniqueParam) idField()    {}

func (likesWithPrismaIDEqualsUniqueParam) unique() {}
func (likesWithPrismaIDEqualsUniqueParam) equals() {}

type LikesWithPrismaEntityTypeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likesModel()
	entityTypeField()
}

type LikesWithPrismaEntityTypeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	entityTypeField()
}

type likesWithPrismaEntityTypeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaEntityTypeSetParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaEntityTypeSetParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaEntityTypeSetParam) likesModel() {}

func (p likesWithPrismaEntityTypeSetParam) entityTypeField() {}

type LikesWithPrismaEntityTypeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	entityTypeField()
}

type likesWithPrismaEntityTypeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaEntityTypeEqualsParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaEntityTypeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaEntityTypeEqualsParam) likesModel() {}

func (p likesWithPrismaEntityTypeEqualsParam) entityTypeField() {}

func (likesWithPrismaEntityTypeSetParam) settable()  {}
func (likesWithPrismaEntityTypeEqualsParam) equals() {}

type likesWithPrismaEntityTypeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaEntityTypeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaEntityTypeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaEntityTypeEqualsUniqueParam) likesModel()      {}
func (p likesWithPrismaEntityTypeEqualsUniqueParam) entityTypeField() {}

func (likesWithPrismaEntityTypeEqualsUniqueParam) unique() {}
func (likesWithPrismaEntityTypeEqualsUniqueParam) equals() {}

type LikesWithPrismaOwnerIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likesModel()
	ownerIDField()
}

type LikesWithPrismaOwnerIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	ownerIDField()
}

type likesWithPrismaOwnerIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaOwnerIDSetParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaOwnerIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaOwnerIDSetParam) likesModel() {}

func (p likesWithPrismaOwnerIDSetParam) ownerIDField() {}

type LikesWithPrismaOwnerIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	ownerIDField()
}

type likesWithPrismaOwnerIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaOwnerIDEqualsParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaOwnerIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaOwnerIDEqualsParam) likesModel() {}

func (p likesWithPrismaOwnerIDEqualsParam) ownerIDField() {}

func (likesWithPrismaOwnerIDSetParam) settable()  {}
func (likesWithPrismaOwnerIDEqualsParam) equals() {}

type likesWithPrismaOwnerIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaOwnerIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaOwnerIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaOwnerIDEqualsUniqueParam) likesModel()   {}
func (p likesWithPrismaOwnerIDEqualsUniqueParam) ownerIDField() {}

func (likesWithPrismaOwnerIDEqualsUniqueParam) unique() {}
func (likesWithPrismaOwnerIDEqualsUniqueParam) equals() {}

type LikesWithPrismaVideoIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likesModel()
	videoIDField()
}

type LikesWithPrismaVideoIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	videoIDField()
}

type likesWithPrismaVideoIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaVideoIDSetParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaVideoIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaVideoIDSetParam) likesModel() {}

func (p likesWithPrismaVideoIDSetParam) videoIDField() {}

type LikesWithPrismaVideoIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	videoIDField()
}

type likesWithPrismaVideoIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaVideoIDEqualsParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaVideoIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaVideoIDEqualsParam) likesModel() {}

func (p likesWithPrismaVideoIDEqualsParam) videoIDField() {}

func (likesWithPrismaVideoIDSetParam) settable()  {}
func (likesWithPrismaVideoIDEqualsParam) equals() {}

type likesWithPrismaVideoIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaVideoIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaVideoIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaVideoIDEqualsUniqueParam) likesModel()   {}
func (p likesWithPrismaVideoIDEqualsUniqueParam) videoIDField() {}

func (likesWithPrismaVideoIDEqualsUniqueParam) unique() {}
func (likesWithPrismaVideoIDEqualsUniqueParam) equals() {}

type LikesWithPrismaCommentIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likesModel()
	commentIDField()
}

type LikesWithPrismaCommentIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	commentIDField()
}

type likesWithPrismaCommentIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaCommentIDSetParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaCommentIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaCommentIDSetParam) likesModel() {}

func (p likesWithPrismaCommentIDSetParam) commentIDField() {}

type LikesWithPrismaCommentIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	commentIDField()
}

type likesWithPrismaCommentIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaCommentIDEqualsParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaCommentIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaCommentIDEqualsParam) likesModel() {}

func (p likesWithPrismaCommentIDEqualsParam) commentIDField() {}

func (likesWithPrismaCommentIDSetParam) settable()  {}
func (likesWithPrismaCommentIDEqualsParam) equals() {}

type likesWithPrismaCommentIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaCommentIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaCommentIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaCommentIDEqualsUniqueParam) likesModel()     {}
func (p likesWithPrismaCommentIDEqualsUniqueParam) commentIDField() {}

func (likesWithPrismaCommentIDEqualsUniqueParam) unique() {}
func (likesWithPrismaCommentIDEqualsUniqueParam) equals() {}

type LikesWithPrismaReplyIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likesModel()
	replyIDField()
}

type LikesWithPrismaReplyIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	replyIDField()
}

type likesWithPrismaReplyIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaReplyIDSetParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaReplyIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaReplyIDSetParam) likesModel() {}

func (p likesWithPrismaReplyIDSetParam) replyIDField() {}

type LikesWithPrismaReplyIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	replyIDField()
}

type likesWithPrismaReplyIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaReplyIDEqualsParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaReplyIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaReplyIDEqualsParam) likesModel() {}

func (p likesWithPrismaReplyIDEqualsParam) replyIDField() {}

func (likesWithPrismaReplyIDSetParam) settable()  {}
func (likesWithPrismaReplyIDEqualsParam) equals() {}

type likesWithPrismaReplyIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaReplyIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaReplyIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaReplyIDEqualsUniqueParam) likesModel()   {}
func (p likesWithPrismaReplyIDEqualsUniqueParam) replyIDField() {}

func (likesWithPrismaReplyIDEqualsUniqueParam) unique() {}
func (likesWithPrismaReplyIDEqualsUniqueParam) equals() {}

type LikesWithPrismaOwnerEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likesModel()
	ownerField()
}

type LikesWithPrismaOwnerSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	ownerField()
}

type likesWithPrismaOwnerSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaOwnerSetParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaOwnerSetParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaOwnerSetParam) likesModel() {}

func (p likesWithPrismaOwnerSetParam) ownerField() {}

type LikesWithPrismaOwnerWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	ownerField()
}

type likesWithPrismaOwnerEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaOwnerEqualsParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaOwnerEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaOwnerEqualsParam) likesModel() {}

func (p likesWithPrismaOwnerEqualsParam) ownerField() {}

func (likesWithPrismaOwnerSetParam) settable()  {}
func (likesWithPrismaOwnerEqualsParam) equals() {}

type likesWithPrismaOwnerEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaOwnerEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaOwnerEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaOwnerEqualsUniqueParam) likesModel() {}
func (p likesWithPrismaOwnerEqualsUniqueParam) ownerField() {}

func (likesWithPrismaOwnerEqualsUniqueParam) unique() {}
func (likesWithPrismaOwnerEqualsUniqueParam) equals() {}

type LikesWithPrismaVideoEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likesModel()
	videoField()
}

type LikesWithPrismaVideoSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	videoField()
}

type likesWithPrismaVideoSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaVideoSetParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaVideoSetParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaVideoSetParam) likesModel() {}

func (p likesWithPrismaVideoSetParam) videoField() {}

type LikesWithPrismaVideoWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	videoField()
}

type likesWithPrismaVideoEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaVideoEqualsParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaVideoEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaVideoEqualsParam) likesModel() {}

func (p likesWithPrismaVideoEqualsParam) videoField() {}

func (likesWithPrismaVideoSetParam) settable()  {}
func (likesWithPrismaVideoEqualsParam) equals() {}

type likesWithPrismaVideoEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaVideoEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaVideoEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaVideoEqualsUniqueParam) likesModel() {}
func (p likesWithPrismaVideoEqualsUniqueParam) videoField() {}

func (likesWithPrismaVideoEqualsUniqueParam) unique() {}
func (likesWithPrismaVideoEqualsUniqueParam) equals() {}

type LikesWithPrismaCommentEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likesModel()
	commentField()
}

type LikesWithPrismaCommentSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	commentField()
}

type likesWithPrismaCommentSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaCommentSetParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaCommentSetParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaCommentSetParam) likesModel() {}

func (p likesWithPrismaCommentSetParam) commentField() {}

type LikesWithPrismaCommentWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	commentField()
}

type likesWithPrismaCommentEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaCommentEqualsParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaCommentEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaCommentEqualsParam) likesModel() {}

func (p likesWithPrismaCommentEqualsParam) commentField() {}

func (likesWithPrismaCommentSetParam) settable()  {}
func (likesWithPrismaCommentEqualsParam) equals() {}

type likesWithPrismaCommentEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaCommentEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaCommentEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaCommentEqualsUniqueParam) likesModel()   {}
func (p likesWithPrismaCommentEqualsUniqueParam) commentField() {}

func (likesWithPrismaCommentEqualsUniqueParam) unique() {}
func (likesWithPrismaCommentEqualsUniqueParam) equals() {}

type LikesWithPrismaReplyEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	likesModel()
	replyField()
}

type LikesWithPrismaReplySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	replyField()
}

type likesWithPrismaReplySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaReplySetParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaReplySetParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaReplySetParam) likesModel() {}

func (p likesWithPrismaReplySetParam) replyField() {}

type LikesWithPrismaReplyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	likesModel()
	replyField()
}

type likesWithPrismaReplyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaReplyEqualsParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaReplyEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaReplyEqualsParam) likesModel() {}

func (p likesWithPrismaReplyEqualsParam) replyField() {}

func (likesWithPrismaReplySetParam) settable()  {}
func (likesWithPrismaReplyEqualsParam) equals() {}

type likesWithPrismaReplyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p likesWithPrismaReplyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p likesWithPrismaReplyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p likesWithPrismaReplyEqualsUniqueParam) likesModel() {}
func (p likesWithPrismaReplyEqualsUniqueParam) replyField() {}

func (likesWithPrismaReplyEqualsUniqueParam) unique() {}
func (likesWithPrismaReplyEqualsUniqueParam) equals() {}

type historyActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var historyOutput = []builder.Output{
	{Name: "id"},
	{Name: "userId"},
	{Name: "videoId"},
	{Name: "viewedAt"},
}

type HistoryRelationWith interface {
	getQuery() builder.Query
	with()
	historyRelation()
}

type HistoryWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	historyModel()
}

type historyDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyDefaultParam) field() builder.Field {
	return p.data
}

func (p historyDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p historyDefaultParam) historyModel() {}

type HistoryOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	historyModel()
}

type historyOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyOrderByParam) field() builder.Field {
	return p.data
}

func (p historyOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p historyOrderByParam) historyModel() {}

type HistoryCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	historyModel()
	isCursor()
}

type historyCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyCursorParam) field() builder.Field {
	return p.data
}

func (p historyCursorParam) isCursor() {}

func (p historyCursorParam) getQuery() builder.Query {
	return p.query
}

func (p historyCursorParam) historyModel() {}

type HistoryParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	historyModel()
}

type historyParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p historyParamUnique) historyModel() {}

func (historyParamUnique) unique() {}

func (p historyParamUnique) field() builder.Field {
	return p.data
}

func (p historyParamUnique) getQuery() builder.Query {
	return p.query
}

type HistoryEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	historyModel()
}

type historyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyEqualsParam) historyModel() {}

func (historyEqualsParam) equals() {}

func (p historyEqualsParam) field() builder.Field {
	return p.data
}

func (p historyEqualsParam) getQuery() builder.Query {
	return p.query
}

type HistoryEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	historyModel()
}

type historyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyEqualsUniqueParam) historyModel() {}

func (historyEqualsUniqueParam) unique() {}
func (historyEqualsUniqueParam) equals() {}

func (p historyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p historyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type HistorySetParam interface {
	field() builder.Field
	settable()
	historyModel()
}

type historySetParam struct {
	data builder.Field
}

func (historySetParam) settable() {}

func (p historySetParam) field() builder.Field {
	return p.data
}

func (p historySetParam) historyModel() {}

type HistoryWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	historyModel()
	idField()
}

type HistoryWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	historyModel()
	idField()
}

type historyWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaIDSetParam) historyModel() {}

func (p historyWithPrismaIDSetParam) idField() {}

type HistoryWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	historyModel()
	idField()
}

type historyWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaIDEqualsParam) historyModel() {}

func (p historyWithPrismaIDEqualsParam) idField() {}

func (historyWithPrismaIDSetParam) settable()  {}
func (historyWithPrismaIDEqualsParam) equals() {}

type historyWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaIDEqualsUniqueParam) historyModel() {}
func (p historyWithPrismaIDEqualsUniqueParam) idField()      {}

func (historyWithPrismaIDEqualsUniqueParam) unique() {}
func (historyWithPrismaIDEqualsUniqueParam) equals() {}

type HistoryWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	historyModel()
	userIDField()
}

type HistoryWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	historyModel()
	userIDField()
}

type historyWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaUserIDSetParam) historyModel() {}

func (p historyWithPrismaUserIDSetParam) userIDField() {}

type HistoryWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	historyModel()
	userIDField()
}

type historyWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaUserIDEqualsParam) historyModel() {}

func (p historyWithPrismaUserIDEqualsParam) userIDField() {}

func (historyWithPrismaUserIDSetParam) settable()  {}
func (historyWithPrismaUserIDEqualsParam) equals() {}

type historyWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaUserIDEqualsUniqueParam) historyModel() {}
func (p historyWithPrismaUserIDEqualsUniqueParam) userIDField()  {}

func (historyWithPrismaUserIDEqualsUniqueParam) unique() {}
func (historyWithPrismaUserIDEqualsUniqueParam) equals() {}

type HistoryWithPrismaVideoIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	historyModel()
	videoIDField()
}

type HistoryWithPrismaVideoIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	historyModel()
	videoIDField()
}

type historyWithPrismaVideoIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaVideoIDSetParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaVideoIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaVideoIDSetParam) historyModel() {}

func (p historyWithPrismaVideoIDSetParam) videoIDField() {}

type HistoryWithPrismaVideoIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	historyModel()
	videoIDField()
}

type historyWithPrismaVideoIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaVideoIDEqualsParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaVideoIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaVideoIDEqualsParam) historyModel() {}

func (p historyWithPrismaVideoIDEqualsParam) videoIDField() {}

func (historyWithPrismaVideoIDSetParam) settable()  {}
func (historyWithPrismaVideoIDEqualsParam) equals() {}

type historyWithPrismaVideoIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaVideoIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaVideoIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaVideoIDEqualsUniqueParam) historyModel() {}
func (p historyWithPrismaVideoIDEqualsUniqueParam) videoIDField() {}

func (historyWithPrismaVideoIDEqualsUniqueParam) unique() {}
func (historyWithPrismaVideoIDEqualsUniqueParam) equals() {}

type HistoryWithPrismaVideoEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	historyModel()
	videoField()
}

type HistoryWithPrismaVideoSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	historyModel()
	videoField()
}

type historyWithPrismaVideoSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaVideoSetParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaVideoSetParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaVideoSetParam) historyModel() {}

func (p historyWithPrismaVideoSetParam) videoField() {}

type HistoryWithPrismaVideoWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	historyModel()
	videoField()
}

type historyWithPrismaVideoEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaVideoEqualsParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaVideoEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaVideoEqualsParam) historyModel() {}

func (p historyWithPrismaVideoEqualsParam) videoField() {}

func (historyWithPrismaVideoSetParam) settable()  {}
func (historyWithPrismaVideoEqualsParam) equals() {}

type historyWithPrismaVideoEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaVideoEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaVideoEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaVideoEqualsUniqueParam) historyModel() {}
func (p historyWithPrismaVideoEqualsUniqueParam) videoField()   {}

func (historyWithPrismaVideoEqualsUniqueParam) unique() {}
func (historyWithPrismaVideoEqualsUniqueParam) equals() {}

type HistoryWithPrismaViewedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	historyModel()
	viewedAtField()
}

type HistoryWithPrismaViewedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	historyModel()
	viewedAtField()
}

type historyWithPrismaViewedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaViewedAtSetParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaViewedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaViewedAtSetParam) historyModel() {}

func (p historyWithPrismaViewedAtSetParam) viewedAtField() {}

type HistoryWithPrismaViewedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	historyModel()
	viewedAtField()
}

type historyWithPrismaViewedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaViewedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaViewedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaViewedAtEqualsParam) historyModel() {}

func (p historyWithPrismaViewedAtEqualsParam) viewedAtField() {}

func (historyWithPrismaViewedAtSetParam) settable()  {}
func (historyWithPrismaViewedAtEqualsParam) equals() {}

type historyWithPrismaViewedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p historyWithPrismaViewedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p historyWithPrismaViewedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p historyWithPrismaViewedAtEqualsUniqueParam) historyModel()  {}
func (p historyWithPrismaViewedAtEqualsUniqueParam) viewedAtField() {}

func (historyWithPrismaViewedAtEqualsUniqueParam) unique() {}
func (historyWithPrismaViewedAtEqualsUniqueParam) equals() {}

type watchLaterActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var watchLaterOutput = []builder.Output{
	{Name: "id"},
	{Name: "userId"},
	{Name: "videoId"},
	{Name: "createdAt"},
}

type WatchLaterRelationWith interface {
	getQuery() builder.Query
	with()
	watchLaterRelation()
}

type WatchLaterWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	watchLaterModel()
}

type watchLaterDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterDefaultParam) field() builder.Field {
	return p.data
}

func (p watchLaterDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterDefaultParam) watchLaterModel() {}

type WatchLaterOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	watchLaterModel()
}

type watchLaterOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterOrderByParam) field() builder.Field {
	return p.data
}

func (p watchLaterOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterOrderByParam) watchLaterModel() {}

type WatchLaterCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	watchLaterModel()
	isCursor()
}

type watchLaterCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterCursorParam) field() builder.Field {
	return p.data
}

func (p watchLaterCursorParam) isCursor() {}

func (p watchLaterCursorParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterCursorParam) watchLaterModel() {}

type WatchLaterParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	watchLaterModel()
}

type watchLaterParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterParamUnique) watchLaterModel() {}

func (watchLaterParamUnique) unique() {}

func (p watchLaterParamUnique) field() builder.Field {
	return p.data
}

func (p watchLaterParamUnique) getQuery() builder.Query {
	return p.query
}

type WatchLaterEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	watchLaterModel()
}

type watchLaterEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterEqualsParam) watchLaterModel() {}

func (watchLaterEqualsParam) equals() {}

func (p watchLaterEqualsParam) field() builder.Field {
	return p.data
}

func (p watchLaterEqualsParam) getQuery() builder.Query {
	return p.query
}

type WatchLaterEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	watchLaterModel()
}

type watchLaterEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterEqualsUniqueParam) watchLaterModel() {}

func (watchLaterEqualsUniqueParam) unique() {}
func (watchLaterEqualsUniqueParam) equals() {}

func (p watchLaterEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p watchLaterEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type WatchLaterSetParam interface {
	field() builder.Field
	settable()
	watchLaterModel()
}

type watchLaterSetParam struct {
	data builder.Field
}

func (watchLaterSetParam) settable() {}

func (p watchLaterSetParam) field() builder.Field {
	return p.data
}

func (p watchLaterSetParam) watchLaterModel() {}

type WatchLaterWithPrismaIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	watchLaterModel()
	idField()
}

type WatchLaterWithPrismaIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	watchLaterModel()
	idField()
}

type watchLaterWithPrismaIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaIDSetParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaIDSetParam) watchLaterModel() {}

func (p watchLaterWithPrismaIDSetParam) idField() {}

type WatchLaterWithPrismaIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	watchLaterModel()
	idField()
}

type watchLaterWithPrismaIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaIDEqualsParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaIDEqualsParam) watchLaterModel() {}

func (p watchLaterWithPrismaIDEqualsParam) idField() {}

func (watchLaterWithPrismaIDSetParam) settable()  {}
func (watchLaterWithPrismaIDEqualsParam) equals() {}

type watchLaterWithPrismaIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaIDEqualsUniqueParam) watchLaterModel() {}
func (p watchLaterWithPrismaIDEqualsUniqueParam) idField()         {}

func (watchLaterWithPrismaIDEqualsUniqueParam) unique() {}
func (watchLaterWithPrismaIDEqualsUniqueParam) equals() {}

type WatchLaterWithPrismaUserIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	watchLaterModel()
	userIDField()
}

type WatchLaterWithPrismaUserIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	watchLaterModel()
	userIDField()
}

type watchLaterWithPrismaUserIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaUserIDSetParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaUserIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaUserIDSetParam) watchLaterModel() {}

func (p watchLaterWithPrismaUserIDSetParam) userIDField() {}

type WatchLaterWithPrismaUserIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	watchLaterModel()
	userIDField()
}

type watchLaterWithPrismaUserIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaUserIDEqualsParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaUserIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaUserIDEqualsParam) watchLaterModel() {}

func (p watchLaterWithPrismaUserIDEqualsParam) userIDField() {}

func (watchLaterWithPrismaUserIDSetParam) settable()  {}
func (watchLaterWithPrismaUserIDEqualsParam) equals() {}

type watchLaterWithPrismaUserIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaUserIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaUserIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaUserIDEqualsUniqueParam) watchLaterModel() {}
func (p watchLaterWithPrismaUserIDEqualsUniqueParam) userIDField()     {}

func (watchLaterWithPrismaUserIDEqualsUniqueParam) unique() {}
func (watchLaterWithPrismaUserIDEqualsUniqueParam) equals() {}

type WatchLaterWithPrismaVideoIDEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	watchLaterModel()
	videoIDField()
}

type WatchLaterWithPrismaVideoIDSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	watchLaterModel()
	videoIDField()
}

type watchLaterWithPrismaVideoIDSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaVideoIDSetParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaVideoIDSetParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaVideoIDSetParam) watchLaterModel() {}

func (p watchLaterWithPrismaVideoIDSetParam) videoIDField() {}

type WatchLaterWithPrismaVideoIDWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	watchLaterModel()
	videoIDField()
}

type watchLaterWithPrismaVideoIDEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaVideoIDEqualsParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaVideoIDEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaVideoIDEqualsParam) watchLaterModel() {}

func (p watchLaterWithPrismaVideoIDEqualsParam) videoIDField() {}

func (watchLaterWithPrismaVideoIDSetParam) settable()  {}
func (watchLaterWithPrismaVideoIDEqualsParam) equals() {}

type watchLaterWithPrismaVideoIDEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaVideoIDEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaVideoIDEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaVideoIDEqualsUniqueParam) watchLaterModel() {}
func (p watchLaterWithPrismaVideoIDEqualsUniqueParam) videoIDField()    {}

func (watchLaterWithPrismaVideoIDEqualsUniqueParam) unique() {}
func (watchLaterWithPrismaVideoIDEqualsUniqueParam) equals() {}

type WatchLaterWithPrismaVideoEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	watchLaterModel()
	videoField()
}

type WatchLaterWithPrismaVideoSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	watchLaterModel()
	videoField()
}

type watchLaterWithPrismaVideoSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaVideoSetParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaVideoSetParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaVideoSetParam) watchLaterModel() {}

func (p watchLaterWithPrismaVideoSetParam) videoField() {}

type WatchLaterWithPrismaVideoWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	watchLaterModel()
	videoField()
}

type watchLaterWithPrismaVideoEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaVideoEqualsParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaVideoEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaVideoEqualsParam) watchLaterModel() {}

func (p watchLaterWithPrismaVideoEqualsParam) videoField() {}

func (watchLaterWithPrismaVideoSetParam) settable()  {}
func (watchLaterWithPrismaVideoEqualsParam) equals() {}

type watchLaterWithPrismaVideoEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaVideoEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaVideoEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaVideoEqualsUniqueParam) watchLaterModel() {}
func (p watchLaterWithPrismaVideoEqualsUniqueParam) videoField()      {}

func (watchLaterWithPrismaVideoEqualsUniqueParam) unique() {}
func (watchLaterWithPrismaVideoEqualsUniqueParam) equals() {}

type WatchLaterWithPrismaCreatedAtEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	watchLaterModel()
	createdAtField()
}

type WatchLaterWithPrismaCreatedAtSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	watchLaterModel()
	createdAtField()
}

type watchLaterWithPrismaCreatedAtSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaCreatedAtSetParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaCreatedAtSetParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaCreatedAtSetParam) watchLaterModel() {}

func (p watchLaterWithPrismaCreatedAtSetParam) createdAtField() {}

type WatchLaterWithPrismaCreatedAtWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	watchLaterModel()
	createdAtField()
}

type watchLaterWithPrismaCreatedAtEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaCreatedAtEqualsParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaCreatedAtEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaCreatedAtEqualsParam) watchLaterModel() {}

func (p watchLaterWithPrismaCreatedAtEqualsParam) createdAtField() {}

func (watchLaterWithPrismaCreatedAtSetParam) settable()  {}
func (watchLaterWithPrismaCreatedAtEqualsParam) equals() {}

type watchLaterWithPrismaCreatedAtEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p watchLaterWithPrismaCreatedAtEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p watchLaterWithPrismaCreatedAtEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p watchLaterWithPrismaCreatedAtEqualsUniqueParam) watchLaterModel() {}
func (p watchLaterWithPrismaCreatedAtEqualsUniqueParam) createdAtField()  {}

func (watchLaterWithPrismaCreatedAtEqualsUniqueParam) unique() {}
func (watchLaterWithPrismaCreatedAtEqualsUniqueParam) equals() {}

// --- template create.gotpl ---

// Creates a single user.
func (r userActions) CreateOne(
	_fullname UserWithPrismaFullnameSetParam,
	_email UserWithPrismaEmailSetParam,
	_password UserWithPrismaPasswordSetParam,
	_avatar UserWithPrismaAvatarSetParam,

	optional ...UserSetParam,
) userCreateOne {
	var v userCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	var fields []builder.Field

	fields = append(fields, _fullname.field())
	fields = append(fields, _email.field())
	fields = append(fields, _password.field())
	fields = append(fields, _avatar.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r userCreateOne) With(params ...UserRelationWith) userCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type userCreateOne struct {
	query builder.Query
}

func (p userCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p userCreateOne) userModel() {}

func (r userCreateOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userCreateOne) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single guild.
func (r guildActions) CreateOne(
	_name GuildWithPrismaNameSetParam,
	_owner GuildWithPrismaOwnerSetParam,

	optional ...GuildSetParam,
) guildCreateOne {
	var v guildCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Guild"
	v.query.Outputs = guildOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _owner.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r guildCreateOne) With(params ...GuildRelationWith) guildCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type guildCreateOne struct {
	query builder.Query
}

func (p guildCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p guildCreateOne) guildModel() {}

func (r guildCreateOne) Exec(ctx context.Context) (*GuildModel, error) {
	var v GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildCreateOne) Tx() GuildUniqueTxResult {
	v := newGuildUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single guildMember.
func (r guildMemberActions) CreateOne(
	_user GuildMemberWithPrismaUserSetParam,
	_guild GuildMemberWithPrismaGuildSetParam,

	optional ...GuildMemberSetParam,
) guildMemberCreateOne {
	var v guildMemberCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "GuildMember"
	v.query.Outputs = guildMemberOutput

	var fields []builder.Field

	fields = append(fields, _user.field())
	fields = append(fields, _guild.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r guildMemberCreateOne) With(params ...GuildMemberRelationWith) guildMemberCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type guildMemberCreateOne struct {
	query builder.Query
}

func (p guildMemberCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p guildMemberCreateOne) guildMemberModel() {}

func (r guildMemberCreateOne) Exec(ctx context.Context) (*GuildMemberModel, error) {
	var v GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberCreateOne) Tx() GuildMemberUniqueTxResult {
	v := newGuildMemberUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single videos.
func (r videosActions) CreateOne(
	_title VideosWithPrismaTitleSetParam,
	_description VideosWithPrismaDescriptionSetParam,
	_thumbnail VideosWithPrismaThumbnailSetParam,
	_videoURL VideosWithPrismaVideoURLSetParam,
	_duration VideosWithPrismaDurationSetParam,
	_owner VideosWithPrismaOwnerSetParam,
	_guild VideosWithPrismaGuildSetParam,

	optional ...VideosSetParam,
) videosCreateOne {
	var v videosCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Videos"
	v.query.Outputs = videosOutput

	var fields []builder.Field

	fields = append(fields, _title.field())
	fields = append(fields, _description.field())
	fields = append(fields, _thumbnail.field())
	fields = append(fields, _videoURL.field())
	fields = append(fields, _duration.field())
	fields = append(fields, _owner.field())
	fields = append(fields, _guild.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r videosCreateOne) With(params ...VideosRelationWith) videosCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type videosCreateOne struct {
	query builder.Query
}

func (p videosCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p videosCreateOne) videosModel() {}

func (r videosCreateOne) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosCreateOne) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single tags.
func (r tagsActions) CreateOne(
	_name TagsWithPrismaNameSetParam,
	_guild TagsWithPrismaGuildSetParam,

	optional ...TagsSetParam,
) tagsCreateOne {
	var v tagsCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Tags"
	v.query.Outputs = tagsOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _guild.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r tagsCreateOne) With(params ...TagsRelationWith) tagsCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type tagsCreateOne struct {
	query builder.Query
}

func (p tagsCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p tagsCreateOne) tagsModel() {}

func (r tagsCreateOne) Exec(ctx context.Context) (*TagsModel, error) {
	var v TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsCreateOne) Tx() TagsUniqueTxResult {
	v := newTagsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single tagsOnVideos.
func (r tagsOnVideosActions) CreateOne(
	_video TagsOnVideosWithPrismaVideoSetParam,
	_tag TagsOnVideosWithPrismaTagSetParam,

	optional ...TagsOnVideosSetParam,
) tagsOnVideosCreateOne {
	var v tagsOnVideosCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "TagsOnVideos"
	v.query.Outputs = tagsOnVideosOutput

	var fields []builder.Field

	fields = append(fields, _video.field())
	fields = append(fields, _tag.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r tagsOnVideosCreateOne) With(params ...TagsOnVideosRelationWith) tagsOnVideosCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type tagsOnVideosCreateOne struct {
	query builder.Query
}

func (p tagsOnVideosCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p tagsOnVideosCreateOne) tagsOnVideosModel() {}

func (r tagsOnVideosCreateOne) Exec(ctx context.Context) (*TagsOnVideosModel, error) {
	var v TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosCreateOne) Tx() TagsOnVideosUniqueTxResult {
	v := newTagsOnVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single comments.
func (r commentsActions) CreateOne(
	_role CommentsWithPrismaRoleSetParam,
	_videoID CommentsWithPrismaVideoIDSetParam,
	_content CommentsWithPrismaContentSetParam,
	_owner CommentsWithPrismaOwnerSetParam,

	optional ...CommentsSetParam,
) commentsCreateOne {
	var v commentsCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Comments"
	v.query.Outputs = commentsOutput

	var fields []builder.Field

	fields = append(fields, _role.field())
	fields = append(fields, _videoID.field())
	fields = append(fields, _content.field())
	fields = append(fields, _owner.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r commentsCreateOne) With(params ...CommentsRelationWith) commentsCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type commentsCreateOne struct {
	query builder.Query
}

func (p commentsCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p commentsCreateOne) commentsModel() {}

func (r commentsCreateOne) Exec(ctx context.Context) (*CommentsModel, error) {
	var v CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsCreateOne) Tx() CommentsUniqueTxResult {
	v := newCommentsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single replies.
func (r repliesActions) CreateOne(
	_role RepliesWithPrismaRoleSetParam,
	_content RepliesWithPrismaContentSetParam,
	_videoID RepliesWithPrismaVideoIDSetParam,
	_owner RepliesWithPrismaOwnerSetParam,

	optional ...RepliesSetParam,
) repliesCreateOne {
	var v repliesCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Replies"
	v.query.Outputs = repliesOutput

	var fields []builder.Field

	fields = append(fields, _role.field())
	fields = append(fields, _content.field())
	fields = append(fields, _videoID.field())
	fields = append(fields, _owner.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r repliesCreateOne) With(params ...RepliesRelationWith) repliesCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type repliesCreateOne struct {
	query builder.Query
}

func (p repliesCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p repliesCreateOne) repliesModel() {}

func (r repliesCreateOne) Exec(ctx context.Context) (*RepliesModel, error) {
	var v RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesCreateOne) Tx() RepliesUniqueTxResult {
	v := newRepliesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single likes.
func (r likesActions) CreateOne(
	_entityType LikesWithPrismaEntityTypeSetParam,
	_owner LikesWithPrismaOwnerSetParam,

	optional ...LikesSetParam,
) likesCreateOne {
	var v likesCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "Likes"
	v.query.Outputs = likesOutput

	var fields []builder.Field

	fields = append(fields, _entityType.field())
	fields = append(fields, _owner.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r likesCreateOne) With(params ...LikesRelationWith) likesCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type likesCreateOne struct {
	query builder.Query
}

func (p likesCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p likesCreateOne) likesModel() {}

func (r likesCreateOne) Exec(ctx context.Context) (*LikesModel, error) {
	var v LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesCreateOne) Tx() LikesUniqueTxResult {
	v := newLikesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single history.
func (r historyActions) CreateOne(
	_userID HistoryWithPrismaUserIDSetParam,
	_video HistoryWithPrismaVideoSetParam,

	optional ...HistorySetParam,
) historyCreateOne {
	var v historyCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "history"
	v.query.Outputs = historyOutput

	var fields []builder.Field

	fields = append(fields, _userID.field())
	fields = append(fields, _video.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r historyCreateOne) With(params ...HistoryRelationWith) historyCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type historyCreateOne struct {
	query builder.Query
}

func (p historyCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p historyCreateOne) historyModel() {}

func (r historyCreateOne) Exec(ctx context.Context) (*HistoryModel, error) {
	var v HistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r historyCreateOne) Tx() HistoryUniqueTxResult {
	v := newHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single watchLater.
func (r watchLaterActions) CreateOne(
	_userID WatchLaterWithPrismaUserIDSetParam,
	_video WatchLaterWithPrismaVideoSetParam,

	optional ...WatchLaterSetParam,
) watchLaterCreateOne {
	var v watchLaterCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "WatchLater"
	v.query.Outputs = watchLaterOutput

	var fields []builder.Field

	fields = append(fields, _userID.field())
	fields = append(fields, _video.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r watchLaterCreateOne) With(params ...WatchLaterRelationWith) watchLaterCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type watchLaterCreateOne struct {
	query builder.Query
}

func (p watchLaterCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p watchLaterCreateOne) watchLaterModel() {}

func (r watchLaterCreateOne) Exec(ctx context.Context) (*WatchLaterModel, error) {
	var v WatchLaterModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r watchLaterCreateOne) Tx() WatchLaterUniqueTxResult {
	v := newWatchLaterUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type userToGuildsFindUnique struct {
	query builder.Query
}

func (r userToGuildsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToGuildsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToGuildsFindUnique) with()         {}
func (r userToGuildsFindUnique) userModel()    {}
func (r userToGuildsFindUnique) userRelation() {}

func (r userToGuildsFindUnique) With(params ...GuildMemberRelationWith) userToGuildsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToGuildsFindUnique) Select(params ...userPrismaFields) userToGuildsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToGuildsFindUnique) Omit(params ...userPrismaFields) userToGuildsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToGuildsFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToGuildsFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToGuildsFindUnique) Update(params ...UserSetParam) userToGuildsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToGuildsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToGuildsUpdateUnique struct {
	query builder.Query
}

func (r userToGuildsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToGuildsUpdateUnique) userModel() {}

func (r userToGuildsUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToGuildsUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToGuildsFindUnique) Delete() userToGuildsDeleteUnique {
	var v userToGuildsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToGuildsDeleteUnique struct {
	query builder.Query
}

func (r userToGuildsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToGuildsDeleteUnique) userModel() {}

func (r userToGuildsDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToGuildsDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToGuildsFindFirst struct {
	query builder.Query
}

func (r userToGuildsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToGuildsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToGuildsFindFirst) with()         {}
func (r userToGuildsFindFirst) userModel()    {}
func (r userToGuildsFindFirst) userRelation() {}

func (r userToGuildsFindFirst) With(params ...GuildMemberRelationWith) userToGuildsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToGuildsFindFirst) Select(params ...userPrismaFields) userToGuildsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToGuildsFindFirst) Omit(params ...userPrismaFields) userToGuildsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToGuildsFindFirst) OrderBy(params ...GuildMemberOrderByParam) userToGuildsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToGuildsFindFirst) Skip(count int) userToGuildsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToGuildsFindFirst) Take(count int) userToGuildsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToGuildsFindFirst) Cursor(cursor UserCursorParam) userToGuildsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToGuildsFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToGuildsFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToGuildsFindMany struct {
	query builder.Query
}

func (r userToGuildsFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToGuildsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToGuildsFindMany) with()         {}
func (r userToGuildsFindMany) userModel()    {}
func (r userToGuildsFindMany) userRelation() {}

func (r userToGuildsFindMany) With(params ...GuildMemberRelationWith) userToGuildsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToGuildsFindMany) Select(params ...userPrismaFields) userToGuildsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToGuildsFindMany) Omit(params ...userPrismaFields) userToGuildsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToGuildsFindMany) OrderBy(params ...GuildMemberOrderByParam) userToGuildsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToGuildsFindMany) Skip(count int) userToGuildsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToGuildsFindMany) Take(count int) userToGuildsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToGuildsFindMany) Cursor(cursor UserCursorParam) userToGuildsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToGuildsFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToGuildsFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToGuildsFindMany) Update(params ...UserSetParam) userToGuildsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToGuildsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToGuildsUpdateMany struct {
	query builder.Query
}

func (r userToGuildsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToGuildsUpdateMany) userModel() {}

func (r userToGuildsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToGuildsUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToGuildsFindMany) Delete() userToGuildsDeleteMany {
	var v userToGuildsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToGuildsDeleteMany struct {
	query builder.Query
}

func (r userToGuildsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToGuildsDeleteMany) userModel() {}

func (r userToGuildsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToGuildsDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToVideosFindUnique struct {
	query builder.Query
}

func (r userToVideosFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToVideosFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToVideosFindUnique) with()         {}
func (r userToVideosFindUnique) userModel()    {}
func (r userToVideosFindUnique) userRelation() {}

func (r userToVideosFindUnique) With(params ...VideosRelationWith) userToVideosFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToVideosFindUnique) Select(params ...userPrismaFields) userToVideosFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToVideosFindUnique) Omit(params ...userPrismaFields) userToVideosFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToVideosFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToVideosFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToVideosFindUnique) Update(params ...UserSetParam) userToVideosUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToVideosUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToVideosUpdateUnique struct {
	query builder.Query
}

func (r userToVideosUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToVideosUpdateUnique) userModel() {}

func (r userToVideosUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToVideosUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToVideosFindUnique) Delete() userToVideosDeleteUnique {
	var v userToVideosDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToVideosDeleteUnique struct {
	query builder.Query
}

func (r userToVideosDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToVideosDeleteUnique) userModel() {}

func (r userToVideosDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToVideosDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToVideosFindFirst struct {
	query builder.Query
}

func (r userToVideosFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToVideosFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToVideosFindFirst) with()         {}
func (r userToVideosFindFirst) userModel()    {}
func (r userToVideosFindFirst) userRelation() {}

func (r userToVideosFindFirst) With(params ...VideosRelationWith) userToVideosFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToVideosFindFirst) Select(params ...userPrismaFields) userToVideosFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToVideosFindFirst) Omit(params ...userPrismaFields) userToVideosFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToVideosFindFirst) OrderBy(params ...VideosOrderByParam) userToVideosFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToVideosFindFirst) Skip(count int) userToVideosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToVideosFindFirst) Take(count int) userToVideosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToVideosFindFirst) Cursor(cursor UserCursorParam) userToVideosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToVideosFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToVideosFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToVideosFindMany struct {
	query builder.Query
}

func (r userToVideosFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToVideosFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToVideosFindMany) with()         {}
func (r userToVideosFindMany) userModel()    {}
func (r userToVideosFindMany) userRelation() {}

func (r userToVideosFindMany) With(params ...VideosRelationWith) userToVideosFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToVideosFindMany) Select(params ...userPrismaFields) userToVideosFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToVideosFindMany) Omit(params ...userPrismaFields) userToVideosFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToVideosFindMany) OrderBy(params ...VideosOrderByParam) userToVideosFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToVideosFindMany) Skip(count int) userToVideosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToVideosFindMany) Take(count int) userToVideosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToVideosFindMany) Cursor(cursor UserCursorParam) userToVideosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToVideosFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToVideosFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToVideosFindMany) Update(params ...UserSetParam) userToVideosUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToVideosUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToVideosUpdateMany struct {
	query builder.Query
}

func (r userToVideosUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToVideosUpdateMany) userModel() {}

func (r userToVideosUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToVideosUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToVideosFindMany) Delete() userToVideosDeleteMany {
	var v userToVideosDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToVideosDeleteMany struct {
	query builder.Query
}

func (r userToVideosDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToVideosDeleteMany) userModel() {}

func (r userToVideosDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToVideosDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToOwnedGuildFindUnique struct {
	query builder.Query
}

func (r userToOwnedGuildFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToOwnedGuildFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToOwnedGuildFindUnique) with()         {}
func (r userToOwnedGuildFindUnique) userModel()    {}
func (r userToOwnedGuildFindUnique) userRelation() {}

func (r userToOwnedGuildFindUnique) With(params ...GuildRelationWith) userToOwnedGuildFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToOwnedGuildFindUnique) Select(params ...userPrismaFields) userToOwnedGuildFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToOwnedGuildFindUnique) Omit(params ...userPrismaFields) userToOwnedGuildFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToOwnedGuildFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToOwnedGuildFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToOwnedGuildFindUnique) Update(params ...UserSetParam) userToOwnedGuildUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToOwnedGuildUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToOwnedGuildUpdateUnique struct {
	query builder.Query
}

func (r userToOwnedGuildUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToOwnedGuildUpdateUnique) userModel() {}

func (r userToOwnedGuildUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToOwnedGuildUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToOwnedGuildFindUnique) Delete() userToOwnedGuildDeleteUnique {
	var v userToOwnedGuildDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToOwnedGuildDeleteUnique struct {
	query builder.Query
}

func (r userToOwnedGuildDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToOwnedGuildDeleteUnique) userModel() {}

func (r userToOwnedGuildDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToOwnedGuildDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToOwnedGuildFindFirst struct {
	query builder.Query
}

func (r userToOwnedGuildFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToOwnedGuildFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToOwnedGuildFindFirst) with()         {}
func (r userToOwnedGuildFindFirst) userModel()    {}
func (r userToOwnedGuildFindFirst) userRelation() {}

func (r userToOwnedGuildFindFirst) With(params ...GuildRelationWith) userToOwnedGuildFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToOwnedGuildFindFirst) Select(params ...userPrismaFields) userToOwnedGuildFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToOwnedGuildFindFirst) Omit(params ...userPrismaFields) userToOwnedGuildFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToOwnedGuildFindFirst) OrderBy(params ...GuildOrderByParam) userToOwnedGuildFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToOwnedGuildFindFirst) Skip(count int) userToOwnedGuildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToOwnedGuildFindFirst) Take(count int) userToOwnedGuildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToOwnedGuildFindFirst) Cursor(cursor UserCursorParam) userToOwnedGuildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToOwnedGuildFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToOwnedGuildFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToOwnedGuildFindMany struct {
	query builder.Query
}

func (r userToOwnedGuildFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToOwnedGuildFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToOwnedGuildFindMany) with()         {}
func (r userToOwnedGuildFindMany) userModel()    {}
func (r userToOwnedGuildFindMany) userRelation() {}

func (r userToOwnedGuildFindMany) With(params ...GuildRelationWith) userToOwnedGuildFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToOwnedGuildFindMany) Select(params ...userPrismaFields) userToOwnedGuildFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToOwnedGuildFindMany) Omit(params ...userPrismaFields) userToOwnedGuildFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToOwnedGuildFindMany) OrderBy(params ...GuildOrderByParam) userToOwnedGuildFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToOwnedGuildFindMany) Skip(count int) userToOwnedGuildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToOwnedGuildFindMany) Take(count int) userToOwnedGuildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToOwnedGuildFindMany) Cursor(cursor UserCursorParam) userToOwnedGuildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToOwnedGuildFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToOwnedGuildFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToOwnedGuildFindMany) Update(params ...UserSetParam) userToOwnedGuildUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToOwnedGuildUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToOwnedGuildUpdateMany struct {
	query builder.Query
}

func (r userToOwnedGuildUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToOwnedGuildUpdateMany) userModel() {}

func (r userToOwnedGuildUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToOwnedGuildUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToOwnedGuildFindMany) Delete() userToOwnedGuildDeleteMany {
	var v userToOwnedGuildDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToOwnedGuildDeleteMany struct {
	query builder.Query
}

func (r userToOwnedGuildDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToOwnedGuildDeleteMany) userModel() {}

func (r userToOwnedGuildDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToOwnedGuildDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToCommentsFindUnique struct {
	query builder.Query
}

func (r userToCommentsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindUnique) with()         {}
func (r userToCommentsFindUnique) userModel()    {}
func (r userToCommentsFindUnique) userRelation() {}

func (r userToCommentsFindUnique) With(params ...CommentsRelationWith) userToCommentsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToCommentsFindUnique) Select(params ...userPrismaFields) userToCommentsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindUnique) Omit(params ...userPrismaFields) userToCommentsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToCommentsFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToCommentsFindUnique) Update(params ...UserSetParam) userToCommentsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToCommentsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToCommentsUpdateUnique struct {
	query builder.Query
}

func (r userToCommentsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsUpdateUnique) userModel() {}

func (r userToCommentsUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToCommentsUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToCommentsFindUnique) Delete() userToCommentsDeleteUnique {
	var v userToCommentsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToCommentsDeleteUnique struct {
	query builder.Query
}

func (r userToCommentsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToCommentsDeleteUnique) userModel() {}

func (r userToCommentsDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToCommentsDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToCommentsFindFirst struct {
	query builder.Query
}

func (r userToCommentsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindFirst) with()         {}
func (r userToCommentsFindFirst) userModel()    {}
func (r userToCommentsFindFirst) userRelation() {}

func (r userToCommentsFindFirst) With(params ...CommentsRelationWith) userToCommentsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToCommentsFindFirst) Select(params ...userPrismaFields) userToCommentsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindFirst) Omit(params ...userPrismaFields) userToCommentsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindFirst) OrderBy(params ...CommentsOrderByParam) userToCommentsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToCommentsFindFirst) Skip(count int) userToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToCommentsFindFirst) Take(count int) userToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToCommentsFindFirst) Cursor(cursor UserCursorParam) userToCommentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToCommentsFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToCommentsFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToCommentsFindMany struct {
	query builder.Query
}

func (r userToCommentsFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsFindMany) with()         {}
func (r userToCommentsFindMany) userModel()    {}
func (r userToCommentsFindMany) userRelation() {}

func (r userToCommentsFindMany) With(params ...CommentsRelationWith) userToCommentsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToCommentsFindMany) Select(params ...userPrismaFields) userToCommentsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindMany) Omit(params ...userPrismaFields) userToCommentsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToCommentsFindMany) OrderBy(params ...CommentsOrderByParam) userToCommentsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToCommentsFindMany) Skip(count int) userToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToCommentsFindMany) Take(count int) userToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToCommentsFindMany) Cursor(cursor UserCursorParam) userToCommentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToCommentsFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToCommentsFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToCommentsFindMany) Update(params ...UserSetParam) userToCommentsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToCommentsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToCommentsUpdateMany struct {
	query builder.Query
}

func (r userToCommentsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToCommentsUpdateMany) userModel() {}

func (r userToCommentsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToCommentsUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToCommentsFindMany) Delete() userToCommentsDeleteMany {
	var v userToCommentsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToCommentsDeleteMany struct {
	query builder.Query
}

func (r userToCommentsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToCommentsDeleteMany) userModel() {}

func (r userToCommentsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToCommentsDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToRepliesFindUnique struct {
	query builder.Query
}

func (r userToRepliesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToRepliesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToRepliesFindUnique) with()         {}
func (r userToRepliesFindUnique) userModel()    {}
func (r userToRepliesFindUnique) userRelation() {}

func (r userToRepliesFindUnique) With(params ...RepliesRelationWith) userToRepliesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToRepliesFindUnique) Select(params ...userPrismaFields) userToRepliesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToRepliesFindUnique) Omit(params ...userPrismaFields) userToRepliesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToRepliesFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToRepliesFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToRepliesFindUnique) Update(params ...UserSetParam) userToRepliesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToRepliesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToRepliesUpdateUnique struct {
	query builder.Query
}

func (r userToRepliesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToRepliesUpdateUnique) userModel() {}

func (r userToRepliesUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToRepliesUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToRepliesFindUnique) Delete() userToRepliesDeleteUnique {
	var v userToRepliesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToRepliesDeleteUnique struct {
	query builder.Query
}

func (r userToRepliesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToRepliesDeleteUnique) userModel() {}

func (r userToRepliesDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToRepliesDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToRepliesFindFirst struct {
	query builder.Query
}

func (r userToRepliesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToRepliesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToRepliesFindFirst) with()         {}
func (r userToRepliesFindFirst) userModel()    {}
func (r userToRepliesFindFirst) userRelation() {}

func (r userToRepliesFindFirst) With(params ...RepliesRelationWith) userToRepliesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToRepliesFindFirst) Select(params ...userPrismaFields) userToRepliesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToRepliesFindFirst) Omit(params ...userPrismaFields) userToRepliesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToRepliesFindFirst) OrderBy(params ...RepliesOrderByParam) userToRepliesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToRepliesFindFirst) Skip(count int) userToRepliesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToRepliesFindFirst) Take(count int) userToRepliesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToRepliesFindFirst) Cursor(cursor UserCursorParam) userToRepliesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToRepliesFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToRepliesFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToRepliesFindMany struct {
	query builder.Query
}

func (r userToRepliesFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToRepliesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToRepliesFindMany) with()         {}
func (r userToRepliesFindMany) userModel()    {}
func (r userToRepliesFindMany) userRelation() {}

func (r userToRepliesFindMany) With(params ...RepliesRelationWith) userToRepliesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToRepliesFindMany) Select(params ...userPrismaFields) userToRepliesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToRepliesFindMany) Omit(params ...userPrismaFields) userToRepliesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToRepliesFindMany) OrderBy(params ...RepliesOrderByParam) userToRepliesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToRepliesFindMany) Skip(count int) userToRepliesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToRepliesFindMany) Take(count int) userToRepliesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToRepliesFindMany) Cursor(cursor UserCursorParam) userToRepliesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToRepliesFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToRepliesFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToRepliesFindMany) Update(params ...UserSetParam) userToRepliesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToRepliesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToRepliesUpdateMany struct {
	query builder.Query
}

func (r userToRepliesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToRepliesUpdateMany) userModel() {}

func (r userToRepliesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToRepliesUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToRepliesFindMany) Delete() userToRepliesDeleteMany {
	var v userToRepliesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToRepliesDeleteMany struct {
	query builder.Query
}

func (r userToRepliesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToRepliesDeleteMany) userModel() {}

func (r userToRepliesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToRepliesDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToLikesFindUnique struct {
	query builder.Query
}

func (r userToLikesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userToLikesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToLikesFindUnique) with()         {}
func (r userToLikesFindUnique) userModel()    {}
func (r userToLikesFindUnique) userRelation() {}

func (r userToLikesFindUnique) With(params ...LikesRelationWith) userToLikesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToLikesFindUnique) Select(params ...userPrismaFields) userToLikesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToLikesFindUnique) Omit(params ...userPrismaFields) userToLikesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToLikesFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToLikesFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToLikesFindUnique) Update(params ...UserSetParam) userToLikesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userToLikesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToLikesUpdateUnique struct {
	query builder.Query
}

func (r userToLikesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userToLikesUpdateUnique) userModel() {}

func (r userToLikesUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToLikesUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToLikesFindUnique) Delete() userToLikesDeleteUnique {
	var v userToLikesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userToLikesDeleteUnique struct {
	query builder.Query
}

func (r userToLikesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userToLikesDeleteUnique) userModel() {}

func (r userToLikesDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToLikesDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userToLikesFindFirst struct {
	query builder.Query
}

func (r userToLikesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userToLikesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userToLikesFindFirst) with()         {}
func (r userToLikesFindFirst) userModel()    {}
func (r userToLikesFindFirst) userRelation() {}

func (r userToLikesFindFirst) With(params ...LikesRelationWith) userToLikesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToLikesFindFirst) Select(params ...userPrismaFields) userToLikesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToLikesFindFirst) Omit(params ...userPrismaFields) userToLikesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToLikesFindFirst) OrderBy(params ...LikesOrderByParam) userToLikesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToLikesFindFirst) Skip(count int) userToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToLikesFindFirst) Take(count int) userToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToLikesFindFirst) Cursor(cursor UserCursorParam) userToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToLikesFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userToLikesFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userToLikesFindMany struct {
	query builder.Query
}

func (r userToLikesFindMany) getQuery() builder.Query {
	return r.query
}

func (r userToLikesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToLikesFindMany) with()         {}
func (r userToLikesFindMany) userModel()    {}
func (r userToLikesFindMany) userRelation() {}

func (r userToLikesFindMany) With(params ...LikesRelationWith) userToLikesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userToLikesFindMany) Select(params ...userPrismaFields) userToLikesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userToLikesFindMany) Omit(params ...userPrismaFields) userToLikesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userToLikesFindMany) OrderBy(params ...LikesOrderByParam) userToLikesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userToLikesFindMany) Skip(count int) userToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userToLikesFindMany) Take(count int) userToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userToLikesFindMany) Cursor(cursor UserCursorParam) userToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userToLikesFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToLikesFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userToLikesFindMany) Update(params ...UserSetParam) userToLikesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userToLikesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userToLikesUpdateMany struct {
	query builder.Query
}

func (r userToLikesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userToLikesUpdateMany) userModel() {}

func (r userToLikesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToLikesUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userToLikesFindMany) Delete() userToLikesDeleteMany {
	var v userToLikesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userToLikesDeleteMany struct {
	query builder.Query
}

func (r userToLikesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userToLikesDeleteMany) userModel() {}

func (r userToLikesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userToLikesDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindUnique struct {
	query builder.Query
}

func (r userFindUnique) getQuery() builder.Query {
	return r.query
}

func (r userFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindUnique) with()         {}
func (r userFindUnique) userModel()    {}
func (r userFindUnique) userRelation() {}

func (r userActions) FindUnique(
	params UserEqualsUniqueWhereParam,
) userFindUnique {
	var v userFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userFindUnique) With(params ...UserRelationWith) userFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindUnique) Select(params ...userPrismaFields) userFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindUnique) Omit(params ...userPrismaFields) userFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindUnique) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindUnique) Update(params ...UserSetParam) userUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "User"

	var v userUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateUnique struct {
	query builder.Query
}

func (r userUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateUnique) userModel() {}

func (r userUpdateUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindUnique) Delete() userDeleteUnique {
	var v userDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "User"

	return v
}

type userDeleteUnique struct {
	query builder.Query
}

func (r userDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteUnique) userModel() {}

func (r userDeleteUnique) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteUnique) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type userFindFirst struct {
	query builder.Query
}

func (r userFindFirst) getQuery() builder.Query {
	return r.query
}

func (r userFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindFirst) with()         {}
func (r userFindFirst) userModel()    {}
func (r userFindFirst) userRelation() {}

func (r userActions) FindFirst(
	params ...UserWhereParam,
) userFindFirst {
	var v userFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindFirst) With(params ...UserRelationWith) userFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindFirst) Select(params ...userPrismaFields) userFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindFirst) Omit(params ...userPrismaFields) userFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindFirst) OrderBy(params ...UserOrderByParam) userFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindFirst) Skip(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindFirst) Take(count int) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindFirst) Cursor(cursor UserCursorParam) userFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindFirst) Exec(ctx context.Context) (
	*UserModel,
	error,
) {
	var v *UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r userFindFirst) ExecInner(ctx context.Context) (
	*InnerUser,
	error,
) {
	var v *InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type userFindMany struct {
	query builder.Query
}

func (r userFindMany) getQuery() builder.Query {
	return r.query
}

func (r userFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userFindMany) with()         {}
func (r userFindMany) userModel()    {}
func (r userFindMany) userRelation() {}

func (r userActions) FindMany(
	params ...UserWhereParam,
) userFindMany {
	var v userFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "User"
	v.query.Outputs = userOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r userFindMany) With(params ...UserRelationWith) userFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r userFindMany) Select(params ...userPrismaFields) userFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindMany) Omit(params ...userPrismaFields) userFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range userOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r userFindMany) OrderBy(params ...UserOrderByParam) userFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r userFindMany) Skip(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r userFindMany) Take(count int) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r userFindMany) Cursor(cursor UserCursorParam) userFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r userFindMany) Exec(ctx context.Context) (
	[]UserModel,
	error,
) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) ExecInner(ctx context.Context) (
	[]InnerUser,
	error,
) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r userFindMany) Update(params ...UserSetParam) userUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "User"

	r.query.Outputs = countOutput

	var v userUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type userUpdateMany struct {
	query builder.Query
}

func (r userUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpdateMany) userModel() {}

func (r userUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpdateMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r userFindMany) Delete() userDeleteMany {
	var v userDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "User"

	v.query.Outputs = countOutput

	return v
}

type userDeleteMany struct {
	query builder.Query
}

func (r userDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p userDeleteMany) userModel() {}

func (r userDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userDeleteMany) Tx() UserManyTxResult {
	v := newUserManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildToOwnerFindUnique struct {
	query builder.Query
}

func (r guildToOwnerFindUnique) getQuery() builder.Query {
	return r.query
}

func (r guildToOwnerFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToOwnerFindUnique) with()          {}
func (r guildToOwnerFindUnique) guildModel()    {}
func (r guildToOwnerFindUnique) guildRelation() {}

func (r guildToOwnerFindUnique) With(params ...UserRelationWith) guildToOwnerFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildToOwnerFindUnique) Select(params ...guildPrismaFields) guildToOwnerFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToOwnerFindUnique) Omit(params ...guildPrismaFields) guildToOwnerFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToOwnerFindUnique) Exec(ctx context.Context) (
	*GuildModel,
	error,
) {
	var v *GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildToOwnerFindUnique) ExecInner(ctx context.Context) (
	*InnerGuild,
	error,
) {
	var v *InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildToOwnerFindUnique) Update(params ...GuildSetParam) guildToOwnerUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Guild"

	var v guildToOwnerUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildToOwnerUpdateUnique struct {
	query builder.Query
}

func (r guildToOwnerUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToOwnerUpdateUnique) guildModel() {}

func (r guildToOwnerUpdateUnique) Exec(ctx context.Context) (*GuildModel, error) {
	var v GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToOwnerUpdateUnique) Tx() GuildUniqueTxResult {
	v := newGuildUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildToOwnerFindUnique) Delete() guildToOwnerDeleteUnique {
	var v guildToOwnerDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Guild"

	return v
}

type guildToOwnerDeleteUnique struct {
	query builder.Query
}

func (r guildToOwnerDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p guildToOwnerDeleteUnique) guildModel() {}

func (r guildToOwnerDeleteUnique) Exec(ctx context.Context) (*GuildModel, error) {
	var v GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToOwnerDeleteUnique) Tx() GuildUniqueTxResult {
	v := newGuildUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildToOwnerFindFirst struct {
	query builder.Query
}

func (r guildToOwnerFindFirst) getQuery() builder.Query {
	return r.query
}

func (r guildToOwnerFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToOwnerFindFirst) with()          {}
func (r guildToOwnerFindFirst) guildModel()    {}
func (r guildToOwnerFindFirst) guildRelation() {}

func (r guildToOwnerFindFirst) With(params ...UserRelationWith) guildToOwnerFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildToOwnerFindFirst) Select(params ...guildPrismaFields) guildToOwnerFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToOwnerFindFirst) Omit(params ...guildPrismaFields) guildToOwnerFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToOwnerFindFirst) OrderBy(params ...UserOrderByParam) guildToOwnerFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildToOwnerFindFirst) Skip(count int) guildToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildToOwnerFindFirst) Take(count int) guildToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildToOwnerFindFirst) Cursor(cursor GuildCursorParam) guildToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildToOwnerFindFirst) Exec(ctx context.Context) (
	*GuildModel,
	error,
) {
	var v *GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildToOwnerFindFirst) ExecInner(ctx context.Context) (
	*InnerGuild,
	error,
) {
	var v *InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type guildToOwnerFindMany struct {
	query builder.Query
}

func (r guildToOwnerFindMany) getQuery() builder.Query {
	return r.query
}

func (r guildToOwnerFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToOwnerFindMany) with()          {}
func (r guildToOwnerFindMany) guildModel()    {}
func (r guildToOwnerFindMany) guildRelation() {}

func (r guildToOwnerFindMany) With(params ...UserRelationWith) guildToOwnerFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildToOwnerFindMany) Select(params ...guildPrismaFields) guildToOwnerFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToOwnerFindMany) Omit(params ...guildPrismaFields) guildToOwnerFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToOwnerFindMany) OrderBy(params ...UserOrderByParam) guildToOwnerFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildToOwnerFindMany) Skip(count int) guildToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildToOwnerFindMany) Take(count int) guildToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildToOwnerFindMany) Cursor(cursor GuildCursorParam) guildToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildToOwnerFindMany) Exec(ctx context.Context) (
	[]GuildModel,
	error,
) {
	var v []GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildToOwnerFindMany) ExecInner(ctx context.Context) (
	[]InnerGuild,
	error,
) {
	var v []InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildToOwnerFindMany) Update(params ...GuildSetParam) guildToOwnerUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Guild"

	r.query.Outputs = countOutput

	var v guildToOwnerUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildToOwnerUpdateMany struct {
	query builder.Query
}

func (r guildToOwnerUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToOwnerUpdateMany) guildModel() {}

func (r guildToOwnerUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToOwnerUpdateMany) Tx() GuildManyTxResult {
	v := newGuildManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildToOwnerFindMany) Delete() guildToOwnerDeleteMany {
	var v guildToOwnerDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Guild"

	v.query.Outputs = countOutput

	return v
}

type guildToOwnerDeleteMany struct {
	query builder.Query
}

func (r guildToOwnerDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p guildToOwnerDeleteMany) guildModel() {}

func (r guildToOwnerDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToOwnerDeleteMany) Tx() GuildManyTxResult {
	v := newGuildManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildToMembersFindUnique struct {
	query builder.Query
}

func (r guildToMembersFindUnique) getQuery() builder.Query {
	return r.query
}

func (r guildToMembersFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToMembersFindUnique) with()          {}
func (r guildToMembersFindUnique) guildModel()    {}
func (r guildToMembersFindUnique) guildRelation() {}

func (r guildToMembersFindUnique) With(params ...GuildMemberRelationWith) guildToMembersFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildToMembersFindUnique) Select(params ...guildPrismaFields) guildToMembersFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToMembersFindUnique) Omit(params ...guildPrismaFields) guildToMembersFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToMembersFindUnique) Exec(ctx context.Context) (
	*GuildModel,
	error,
) {
	var v *GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildToMembersFindUnique) ExecInner(ctx context.Context) (
	*InnerGuild,
	error,
) {
	var v *InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildToMembersFindUnique) Update(params ...GuildSetParam) guildToMembersUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Guild"

	var v guildToMembersUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildToMembersUpdateUnique struct {
	query builder.Query
}

func (r guildToMembersUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToMembersUpdateUnique) guildModel() {}

func (r guildToMembersUpdateUnique) Exec(ctx context.Context) (*GuildModel, error) {
	var v GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToMembersUpdateUnique) Tx() GuildUniqueTxResult {
	v := newGuildUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildToMembersFindUnique) Delete() guildToMembersDeleteUnique {
	var v guildToMembersDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Guild"

	return v
}

type guildToMembersDeleteUnique struct {
	query builder.Query
}

func (r guildToMembersDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p guildToMembersDeleteUnique) guildModel() {}

func (r guildToMembersDeleteUnique) Exec(ctx context.Context) (*GuildModel, error) {
	var v GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToMembersDeleteUnique) Tx() GuildUniqueTxResult {
	v := newGuildUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildToMembersFindFirst struct {
	query builder.Query
}

func (r guildToMembersFindFirst) getQuery() builder.Query {
	return r.query
}

func (r guildToMembersFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToMembersFindFirst) with()          {}
func (r guildToMembersFindFirst) guildModel()    {}
func (r guildToMembersFindFirst) guildRelation() {}

func (r guildToMembersFindFirst) With(params ...GuildMemberRelationWith) guildToMembersFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildToMembersFindFirst) Select(params ...guildPrismaFields) guildToMembersFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToMembersFindFirst) Omit(params ...guildPrismaFields) guildToMembersFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToMembersFindFirst) OrderBy(params ...GuildMemberOrderByParam) guildToMembersFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildToMembersFindFirst) Skip(count int) guildToMembersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildToMembersFindFirst) Take(count int) guildToMembersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildToMembersFindFirst) Cursor(cursor GuildCursorParam) guildToMembersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildToMembersFindFirst) Exec(ctx context.Context) (
	*GuildModel,
	error,
) {
	var v *GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildToMembersFindFirst) ExecInner(ctx context.Context) (
	*InnerGuild,
	error,
) {
	var v *InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type guildToMembersFindMany struct {
	query builder.Query
}

func (r guildToMembersFindMany) getQuery() builder.Query {
	return r.query
}

func (r guildToMembersFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToMembersFindMany) with()          {}
func (r guildToMembersFindMany) guildModel()    {}
func (r guildToMembersFindMany) guildRelation() {}

func (r guildToMembersFindMany) With(params ...GuildMemberRelationWith) guildToMembersFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildToMembersFindMany) Select(params ...guildPrismaFields) guildToMembersFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToMembersFindMany) Omit(params ...guildPrismaFields) guildToMembersFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToMembersFindMany) OrderBy(params ...GuildMemberOrderByParam) guildToMembersFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildToMembersFindMany) Skip(count int) guildToMembersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildToMembersFindMany) Take(count int) guildToMembersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildToMembersFindMany) Cursor(cursor GuildCursorParam) guildToMembersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildToMembersFindMany) Exec(ctx context.Context) (
	[]GuildModel,
	error,
) {
	var v []GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildToMembersFindMany) ExecInner(ctx context.Context) (
	[]InnerGuild,
	error,
) {
	var v []InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildToMembersFindMany) Update(params ...GuildSetParam) guildToMembersUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Guild"

	r.query.Outputs = countOutput

	var v guildToMembersUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildToMembersUpdateMany struct {
	query builder.Query
}

func (r guildToMembersUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToMembersUpdateMany) guildModel() {}

func (r guildToMembersUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToMembersUpdateMany) Tx() GuildManyTxResult {
	v := newGuildManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildToMembersFindMany) Delete() guildToMembersDeleteMany {
	var v guildToMembersDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Guild"

	v.query.Outputs = countOutput

	return v
}

type guildToMembersDeleteMany struct {
	query builder.Query
}

func (r guildToMembersDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p guildToMembersDeleteMany) guildModel() {}

func (r guildToMembersDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToMembersDeleteMany) Tx() GuildManyTxResult {
	v := newGuildManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildToVideosFindUnique struct {
	query builder.Query
}

func (r guildToVideosFindUnique) getQuery() builder.Query {
	return r.query
}

func (r guildToVideosFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToVideosFindUnique) with()          {}
func (r guildToVideosFindUnique) guildModel()    {}
func (r guildToVideosFindUnique) guildRelation() {}

func (r guildToVideosFindUnique) With(params ...VideosRelationWith) guildToVideosFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildToVideosFindUnique) Select(params ...guildPrismaFields) guildToVideosFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToVideosFindUnique) Omit(params ...guildPrismaFields) guildToVideosFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToVideosFindUnique) Exec(ctx context.Context) (
	*GuildModel,
	error,
) {
	var v *GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildToVideosFindUnique) ExecInner(ctx context.Context) (
	*InnerGuild,
	error,
) {
	var v *InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildToVideosFindUnique) Update(params ...GuildSetParam) guildToVideosUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Guild"

	var v guildToVideosUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildToVideosUpdateUnique struct {
	query builder.Query
}

func (r guildToVideosUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToVideosUpdateUnique) guildModel() {}

func (r guildToVideosUpdateUnique) Exec(ctx context.Context) (*GuildModel, error) {
	var v GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToVideosUpdateUnique) Tx() GuildUniqueTxResult {
	v := newGuildUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildToVideosFindUnique) Delete() guildToVideosDeleteUnique {
	var v guildToVideosDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Guild"

	return v
}

type guildToVideosDeleteUnique struct {
	query builder.Query
}

func (r guildToVideosDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p guildToVideosDeleteUnique) guildModel() {}

func (r guildToVideosDeleteUnique) Exec(ctx context.Context) (*GuildModel, error) {
	var v GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToVideosDeleteUnique) Tx() GuildUniqueTxResult {
	v := newGuildUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildToVideosFindFirst struct {
	query builder.Query
}

func (r guildToVideosFindFirst) getQuery() builder.Query {
	return r.query
}

func (r guildToVideosFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToVideosFindFirst) with()          {}
func (r guildToVideosFindFirst) guildModel()    {}
func (r guildToVideosFindFirst) guildRelation() {}

func (r guildToVideosFindFirst) With(params ...VideosRelationWith) guildToVideosFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildToVideosFindFirst) Select(params ...guildPrismaFields) guildToVideosFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToVideosFindFirst) Omit(params ...guildPrismaFields) guildToVideosFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToVideosFindFirst) OrderBy(params ...VideosOrderByParam) guildToVideosFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildToVideosFindFirst) Skip(count int) guildToVideosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildToVideosFindFirst) Take(count int) guildToVideosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildToVideosFindFirst) Cursor(cursor GuildCursorParam) guildToVideosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildToVideosFindFirst) Exec(ctx context.Context) (
	*GuildModel,
	error,
) {
	var v *GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildToVideosFindFirst) ExecInner(ctx context.Context) (
	*InnerGuild,
	error,
) {
	var v *InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type guildToVideosFindMany struct {
	query builder.Query
}

func (r guildToVideosFindMany) getQuery() builder.Query {
	return r.query
}

func (r guildToVideosFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToVideosFindMany) with()          {}
func (r guildToVideosFindMany) guildModel()    {}
func (r guildToVideosFindMany) guildRelation() {}

func (r guildToVideosFindMany) With(params ...VideosRelationWith) guildToVideosFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildToVideosFindMany) Select(params ...guildPrismaFields) guildToVideosFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToVideosFindMany) Omit(params ...guildPrismaFields) guildToVideosFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToVideosFindMany) OrderBy(params ...VideosOrderByParam) guildToVideosFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildToVideosFindMany) Skip(count int) guildToVideosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildToVideosFindMany) Take(count int) guildToVideosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildToVideosFindMany) Cursor(cursor GuildCursorParam) guildToVideosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildToVideosFindMany) Exec(ctx context.Context) (
	[]GuildModel,
	error,
) {
	var v []GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildToVideosFindMany) ExecInner(ctx context.Context) (
	[]InnerGuild,
	error,
) {
	var v []InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildToVideosFindMany) Update(params ...GuildSetParam) guildToVideosUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Guild"

	r.query.Outputs = countOutput

	var v guildToVideosUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildToVideosUpdateMany struct {
	query builder.Query
}

func (r guildToVideosUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToVideosUpdateMany) guildModel() {}

func (r guildToVideosUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToVideosUpdateMany) Tx() GuildManyTxResult {
	v := newGuildManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildToVideosFindMany) Delete() guildToVideosDeleteMany {
	var v guildToVideosDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Guild"

	v.query.Outputs = countOutput

	return v
}

type guildToVideosDeleteMany struct {
	query builder.Query
}

func (r guildToVideosDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p guildToVideosDeleteMany) guildModel() {}

func (r guildToVideosDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToVideosDeleteMany) Tx() GuildManyTxResult {
	v := newGuildManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildToTagsFindUnique struct {
	query builder.Query
}

func (r guildToTagsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r guildToTagsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToTagsFindUnique) with()          {}
func (r guildToTagsFindUnique) guildModel()    {}
func (r guildToTagsFindUnique) guildRelation() {}

func (r guildToTagsFindUnique) With(params ...TagsRelationWith) guildToTagsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildToTagsFindUnique) Select(params ...guildPrismaFields) guildToTagsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToTagsFindUnique) Omit(params ...guildPrismaFields) guildToTagsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToTagsFindUnique) Exec(ctx context.Context) (
	*GuildModel,
	error,
) {
	var v *GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildToTagsFindUnique) ExecInner(ctx context.Context) (
	*InnerGuild,
	error,
) {
	var v *InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildToTagsFindUnique) Update(params ...GuildSetParam) guildToTagsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Guild"

	var v guildToTagsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildToTagsUpdateUnique struct {
	query builder.Query
}

func (r guildToTagsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToTagsUpdateUnique) guildModel() {}

func (r guildToTagsUpdateUnique) Exec(ctx context.Context) (*GuildModel, error) {
	var v GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToTagsUpdateUnique) Tx() GuildUniqueTxResult {
	v := newGuildUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildToTagsFindUnique) Delete() guildToTagsDeleteUnique {
	var v guildToTagsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Guild"

	return v
}

type guildToTagsDeleteUnique struct {
	query builder.Query
}

func (r guildToTagsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p guildToTagsDeleteUnique) guildModel() {}

func (r guildToTagsDeleteUnique) Exec(ctx context.Context) (*GuildModel, error) {
	var v GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToTagsDeleteUnique) Tx() GuildUniqueTxResult {
	v := newGuildUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildToTagsFindFirst struct {
	query builder.Query
}

func (r guildToTagsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r guildToTagsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToTagsFindFirst) with()          {}
func (r guildToTagsFindFirst) guildModel()    {}
func (r guildToTagsFindFirst) guildRelation() {}

func (r guildToTagsFindFirst) With(params ...TagsRelationWith) guildToTagsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildToTagsFindFirst) Select(params ...guildPrismaFields) guildToTagsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToTagsFindFirst) Omit(params ...guildPrismaFields) guildToTagsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToTagsFindFirst) OrderBy(params ...TagsOrderByParam) guildToTagsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildToTagsFindFirst) Skip(count int) guildToTagsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildToTagsFindFirst) Take(count int) guildToTagsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildToTagsFindFirst) Cursor(cursor GuildCursorParam) guildToTagsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildToTagsFindFirst) Exec(ctx context.Context) (
	*GuildModel,
	error,
) {
	var v *GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildToTagsFindFirst) ExecInner(ctx context.Context) (
	*InnerGuild,
	error,
) {
	var v *InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type guildToTagsFindMany struct {
	query builder.Query
}

func (r guildToTagsFindMany) getQuery() builder.Query {
	return r.query
}

func (r guildToTagsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToTagsFindMany) with()          {}
func (r guildToTagsFindMany) guildModel()    {}
func (r guildToTagsFindMany) guildRelation() {}

func (r guildToTagsFindMany) With(params ...TagsRelationWith) guildToTagsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildToTagsFindMany) Select(params ...guildPrismaFields) guildToTagsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToTagsFindMany) Omit(params ...guildPrismaFields) guildToTagsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildToTagsFindMany) OrderBy(params ...TagsOrderByParam) guildToTagsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildToTagsFindMany) Skip(count int) guildToTagsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildToTagsFindMany) Take(count int) guildToTagsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildToTagsFindMany) Cursor(cursor GuildCursorParam) guildToTagsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildToTagsFindMany) Exec(ctx context.Context) (
	[]GuildModel,
	error,
) {
	var v []GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildToTagsFindMany) ExecInner(ctx context.Context) (
	[]InnerGuild,
	error,
) {
	var v []InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildToTagsFindMany) Update(params ...GuildSetParam) guildToTagsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Guild"

	r.query.Outputs = countOutput

	var v guildToTagsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildToTagsUpdateMany struct {
	query builder.Query
}

func (r guildToTagsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildToTagsUpdateMany) guildModel() {}

func (r guildToTagsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToTagsUpdateMany) Tx() GuildManyTxResult {
	v := newGuildManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildToTagsFindMany) Delete() guildToTagsDeleteMany {
	var v guildToTagsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Guild"

	v.query.Outputs = countOutput

	return v
}

type guildToTagsDeleteMany struct {
	query builder.Query
}

func (r guildToTagsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p guildToTagsDeleteMany) guildModel() {}

func (r guildToTagsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildToTagsDeleteMany) Tx() GuildManyTxResult {
	v := newGuildManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildFindUnique struct {
	query builder.Query
}

func (r guildFindUnique) getQuery() builder.Query {
	return r.query
}

func (r guildFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildFindUnique) with()          {}
func (r guildFindUnique) guildModel()    {}
func (r guildFindUnique) guildRelation() {}

func (r guildActions) FindUnique(
	params GuildEqualsUniqueWhereParam,
) guildFindUnique {
	var v guildFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Guild"
	v.query.Outputs = guildOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r guildFindUnique) With(params ...GuildRelationWith) guildFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildFindUnique) Select(params ...guildPrismaFields) guildFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildFindUnique) Omit(params ...guildPrismaFields) guildFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildFindUnique) Exec(ctx context.Context) (
	*GuildModel,
	error,
) {
	var v *GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildFindUnique) ExecInner(ctx context.Context) (
	*InnerGuild,
	error,
) {
	var v *InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildFindUnique) Update(params ...GuildSetParam) guildUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Guild"

	var v guildUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildUpdateUnique struct {
	query builder.Query
}

func (r guildUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildUpdateUnique) guildModel() {}

func (r guildUpdateUnique) Exec(ctx context.Context) (*GuildModel, error) {
	var v GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildUpdateUnique) Tx() GuildUniqueTxResult {
	v := newGuildUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildFindUnique) Delete() guildDeleteUnique {
	var v guildDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Guild"

	return v
}

type guildDeleteUnique struct {
	query builder.Query
}

func (r guildDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p guildDeleteUnique) guildModel() {}

func (r guildDeleteUnique) Exec(ctx context.Context) (*GuildModel, error) {
	var v GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildDeleteUnique) Tx() GuildUniqueTxResult {
	v := newGuildUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildFindFirst struct {
	query builder.Query
}

func (r guildFindFirst) getQuery() builder.Query {
	return r.query
}

func (r guildFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r guildFindFirst) with()          {}
func (r guildFindFirst) guildModel()    {}
func (r guildFindFirst) guildRelation() {}

func (r guildActions) FindFirst(
	params ...GuildWhereParam,
) guildFindFirst {
	var v guildFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Guild"
	v.query.Outputs = guildOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r guildFindFirst) With(params ...GuildRelationWith) guildFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildFindFirst) Select(params ...guildPrismaFields) guildFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildFindFirst) Omit(params ...guildPrismaFields) guildFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildFindFirst) OrderBy(params ...GuildOrderByParam) guildFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildFindFirst) Skip(count int) guildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildFindFirst) Take(count int) guildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildFindFirst) Cursor(cursor GuildCursorParam) guildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildFindFirst) Exec(ctx context.Context) (
	*GuildModel,
	error,
) {
	var v *GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildFindFirst) ExecInner(ctx context.Context) (
	*InnerGuild,
	error,
) {
	var v *InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type guildFindMany struct {
	query builder.Query
}

func (r guildFindMany) getQuery() builder.Query {
	return r.query
}

func (r guildFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildFindMany) with()          {}
func (r guildFindMany) guildModel()    {}
func (r guildFindMany) guildRelation() {}

func (r guildActions) FindMany(
	params ...GuildWhereParam,
) guildFindMany {
	var v guildFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Guild"
	v.query.Outputs = guildOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r guildFindMany) With(params ...GuildRelationWith) guildFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildFindMany) Select(params ...guildPrismaFields) guildFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildFindMany) Omit(params ...guildPrismaFields) guildFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildFindMany) OrderBy(params ...GuildOrderByParam) guildFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildFindMany) Skip(count int) guildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildFindMany) Take(count int) guildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildFindMany) Cursor(cursor GuildCursorParam) guildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildFindMany) Exec(ctx context.Context) (
	[]GuildModel,
	error,
) {
	var v []GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildFindMany) ExecInner(ctx context.Context) (
	[]InnerGuild,
	error,
) {
	var v []InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildFindMany) Update(params ...GuildSetParam) guildUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Guild"

	r.query.Outputs = countOutput

	var v guildUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildUpdateMany struct {
	query builder.Query
}

func (r guildUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildUpdateMany) guildModel() {}

func (r guildUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildUpdateMany) Tx() GuildManyTxResult {
	v := newGuildManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildFindMany) Delete() guildDeleteMany {
	var v guildDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Guild"

	v.query.Outputs = countOutput

	return v
}

type guildDeleteMany struct {
	query builder.Query
}

func (r guildDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p guildDeleteMany) guildModel() {}

func (r guildDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildDeleteMany) Tx() GuildManyTxResult {
	v := newGuildManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildMemberToUserFindUnique struct {
	query builder.Query
}

func (r guildMemberToUserFindUnique) getQuery() builder.Query {
	return r.query
}

func (r guildMemberToUserFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberToUserFindUnique) with()                {}
func (r guildMemberToUserFindUnique) guildMemberModel()    {}
func (r guildMemberToUserFindUnique) guildMemberRelation() {}

func (r guildMemberToUserFindUnique) With(params ...UserRelationWith) guildMemberToUserFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildMemberToUserFindUnique) Select(params ...guildMemberPrismaFields) guildMemberToUserFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberToUserFindUnique) Omit(params ...guildMemberPrismaFields) guildMemberToUserFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildMemberOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberToUserFindUnique) Exec(ctx context.Context) (
	*GuildMemberModel,
	error,
) {
	var v *GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildMemberToUserFindUnique) ExecInner(ctx context.Context) (
	*InnerGuildMember,
	error,
) {
	var v *InnerGuildMember
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildMemberToUserFindUnique) Update(params ...GuildMemberSetParam) guildMemberToUserUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "GuildMember"

	var v guildMemberToUserUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildMemberToUserUpdateUnique struct {
	query builder.Query
}

func (r guildMemberToUserUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberToUserUpdateUnique) guildMemberModel() {}

func (r guildMemberToUserUpdateUnique) Exec(ctx context.Context) (*GuildMemberModel, error) {
	var v GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberToUserUpdateUnique) Tx() GuildMemberUniqueTxResult {
	v := newGuildMemberUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildMemberToUserFindUnique) Delete() guildMemberToUserDeleteUnique {
	var v guildMemberToUserDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "GuildMember"

	return v
}

type guildMemberToUserDeleteUnique struct {
	query builder.Query
}

func (r guildMemberToUserDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p guildMemberToUserDeleteUnique) guildMemberModel() {}

func (r guildMemberToUserDeleteUnique) Exec(ctx context.Context) (*GuildMemberModel, error) {
	var v GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberToUserDeleteUnique) Tx() GuildMemberUniqueTxResult {
	v := newGuildMemberUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildMemberToUserFindFirst struct {
	query builder.Query
}

func (r guildMemberToUserFindFirst) getQuery() builder.Query {
	return r.query
}

func (r guildMemberToUserFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberToUserFindFirst) with()                {}
func (r guildMemberToUserFindFirst) guildMemberModel()    {}
func (r guildMemberToUserFindFirst) guildMemberRelation() {}

func (r guildMemberToUserFindFirst) With(params ...UserRelationWith) guildMemberToUserFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildMemberToUserFindFirst) Select(params ...guildMemberPrismaFields) guildMemberToUserFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberToUserFindFirst) Omit(params ...guildMemberPrismaFields) guildMemberToUserFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildMemberOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberToUserFindFirst) OrderBy(params ...UserOrderByParam) guildMemberToUserFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildMemberToUserFindFirst) Skip(count int) guildMemberToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildMemberToUserFindFirst) Take(count int) guildMemberToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildMemberToUserFindFirst) Cursor(cursor GuildMemberCursorParam) guildMemberToUserFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildMemberToUserFindFirst) Exec(ctx context.Context) (
	*GuildMemberModel,
	error,
) {
	var v *GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildMemberToUserFindFirst) ExecInner(ctx context.Context) (
	*InnerGuildMember,
	error,
) {
	var v *InnerGuildMember
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type guildMemberToUserFindMany struct {
	query builder.Query
}

func (r guildMemberToUserFindMany) getQuery() builder.Query {
	return r.query
}

func (r guildMemberToUserFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberToUserFindMany) with()                {}
func (r guildMemberToUserFindMany) guildMemberModel()    {}
func (r guildMemberToUserFindMany) guildMemberRelation() {}

func (r guildMemberToUserFindMany) With(params ...UserRelationWith) guildMemberToUserFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildMemberToUserFindMany) Select(params ...guildMemberPrismaFields) guildMemberToUserFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberToUserFindMany) Omit(params ...guildMemberPrismaFields) guildMemberToUserFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildMemberOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberToUserFindMany) OrderBy(params ...UserOrderByParam) guildMemberToUserFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildMemberToUserFindMany) Skip(count int) guildMemberToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildMemberToUserFindMany) Take(count int) guildMemberToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildMemberToUserFindMany) Cursor(cursor GuildMemberCursorParam) guildMemberToUserFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildMemberToUserFindMany) Exec(ctx context.Context) (
	[]GuildMemberModel,
	error,
) {
	var v []GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildMemberToUserFindMany) ExecInner(ctx context.Context) (
	[]InnerGuildMember,
	error,
) {
	var v []InnerGuildMember
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildMemberToUserFindMany) Update(params ...GuildMemberSetParam) guildMemberToUserUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "GuildMember"

	r.query.Outputs = countOutput

	var v guildMemberToUserUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildMemberToUserUpdateMany struct {
	query builder.Query
}

func (r guildMemberToUserUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberToUserUpdateMany) guildMemberModel() {}

func (r guildMemberToUserUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberToUserUpdateMany) Tx() GuildMemberManyTxResult {
	v := newGuildMemberManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildMemberToUserFindMany) Delete() guildMemberToUserDeleteMany {
	var v guildMemberToUserDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "GuildMember"

	v.query.Outputs = countOutput

	return v
}

type guildMemberToUserDeleteMany struct {
	query builder.Query
}

func (r guildMemberToUserDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p guildMemberToUserDeleteMany) guildMemberModel() {}

func (r guildMemberToUserDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberToUserDeleteMany) Tx() GuildMemberManyTxResult {
	v := newGuildMemberManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildMemberToGuildFindUnique struct {
	query builder.Query
}

func (r guildMemberToGuildFindUnique) getQuery() builder.Query {
	return r.query
}

func (r guildMemberToGuildFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberToGuildFindUnique) with()                {}
func (r guildMemberToGuildFindUnique) guildMemberModel()    {}
func (r guildMemberToGuildFindUnique) guildMemberRelation() {}

func (r guildMemberToGuildFindUnique) With(params ...GuildRelationWith) guildMemberToGuildFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildMemberToGuildFindUnique) Select(params ...guildMemberPrismaFields) guildMemberToGuildFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberToGuildFindUnique) Omit(params ...guildMemberPrismaFields) guildMemberToGuildFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildMemberOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberToGuildFindUnique) Exec(ctx context.Context) (
	*GuildMemberModel,
	error,
) {
	var v *GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildMemberToGuildFindUnique) ExecInner(ctx context.Context) (
	*InnerGuildMember,
	error,
) {
	var v *InnerGuildMember
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildMemberToGuildFindUnique) Update(params ...GuildMemberSetParam) guildMemberToGuildUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "GuildMember"

	var v guildMemberToGuildUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildMemberToGuildUpdateUnique struct {
	query builder.Query
}

func (r guildMemberToGuildUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberToGuildUpdateUnique) guildMemberModel() {}

func (r guildMemberToGuildUpdateUnique) Exec(ctx context.Context) (*GuildMemberModel, error) {
	var v GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberToGuildUpdateUnique) Tx() GuildMemberUniqueTxResult {
	v := newGuildMemberUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildMemberToGuildFindUnique) Delete() guildMemberToGuildDeleteUnique {
	var v guildMemberToGuildDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "GuildMember"

	return v
}

type guildMemberToGuildDeleteUnique struct {
	query builder.Query
}

func (r guildMemberToGuildDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p guildMemberToGuildDeleteUnique) guildMemberModel() {}

func (r guildMemberToGuildDeleteUnique) Exec(ctx context.Context) (*GuildMemberModel, error) {
	var v GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberToGuildDeleteUnique) Tx() GuildMemberUniqueTxResult {
	v := newGuildMemberUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildMemberToGuildFindFirst struct {
	query builder.Query
}

func (r guildMemberToGuildFindFirst) getQuery() builder.Query {
	return r.query
}

func (r guildMemberToGuildFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberToGuildFindFirst) with()                {}
func (r guildMemberToGuildFindFirst) guildMemberModel()    {}
func (r guildMemberToGuildFindFirst) guildMemberRelation() {}

func (r guildMemberToGuildFindFirst) With(params ...GuildRelationWith) guildMemberToGuildFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildMemberToGuildFindFirst) Select(params ...guildMemberPrismaFields) guildMemberToGuildFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberToGuildFindFirst) Omit(params ...guildMemberPrismaFields) guildMemberToGuildFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildMemberOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberToGuildFindFirst) OrderBy(params ...GuildOrderByParam) guildMemberToGuildFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildMemberToGuildFindFirst) Skip(count int) guildMemberToGuildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildMemberToGuildFindFirst) Take(count int) guildMemberToGuildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildMemberToGuildFindFirst) Cursor(cursor GuildMemberCursorParam) guildMemberToGuildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildMemberToGuildFindFirst) Exec(ctx context.Context) (
	*GuildMemberModel,
	error,
) {
	var v *GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildMemberToGuildFindFirst) ExecInner(ctx context.Context) (
	*InnerGuildMember,
	error,
) {
	var v *InnerGuildMember
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type guildMemberToGuildFindMany struct {
	query builder.Query
}

func (r guildMemberToGuildFindMany) getQuery() builder.Query {
	return r.query
}

func (r guildMemberToGuildFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberToGuildFindMany) with()                {}
func (r guildMemberToGuildFindMany) guildMemberModel()    {}
func (r guildMemberToGuildFindMany) guildMemberRelation() {}

func (r guildMemberToGuildFindMany) With(params ...GuildRelationWith) guildMemberToGuildFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildMemberToGuildFindMany) Select(params ...guildMemberPrismaFields) guildMemberToGuildFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberToGuildFindMany) Omit(params ...guildMemberPrismaFields) guildMemberToGuildFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildMemberOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberToGuildFindMany) OrderBy(params ...GuildOrderByParam) guildMemberToGuildFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildMemberToGuildFindMany) Skip(count int) guildMemberToGuildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildMemberToGuildFindMany) Take(count int) guildMemberToGuildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildMemberToGuildFindMany) Cursor(cursor GuildMemberCursorParam) guildMemberToGuildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildMemberToGuildFindMany) Exec(ctx context.Context) (
	[]GuildMemberModel,
	error,
) {
	var v []GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildMemberToGuildFindMany) ExecInner(ctx context.Context) (
	[]InnerGuildMember,
	error,
) {
	var v []InnerGuildMember
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildMemberToGuildFindMany) Update(params ...GuildMemberSetParam) guildMemberToGuildUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "GuildMember"

	r.query.Outputs = countOutput

	var v guildMemberToGuildUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildMemberToGuildUpdateMany struct {
	query builder.Query
}

func (r guildMemberToGuildUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberToGuildUpdateMany) guildMemberModel() {}

func (r guildMemberToGuildUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberToGuildUpdateMany) Tx() GuildMemberManyTxResult {
	v := newGuildMemberManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildMemberToGuildFindMany) Delete() guildMemberToGuildDeleteMany {
	var v guildMemberToGuildDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "GuildMember"

	v.query.Outputs = countOutput

	return v
}

type guildMemberToGuildDeleteMany struct {
	query builder.Query
}

func (r guildMemberToGuildDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p guildMemberToGuildDeleteMany) guildMemberModel() {}

func (r guildMemberToGuildDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberToGuildDeleteMany) Tx() GuildMemberManyTxResult {
	v := newGuildMemberManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildMemberFindUnique struct {
	query builder.Query
}

func (r guildMemberFindUnique) getQuery() builder.Query {
	return r.query
}

func (r guildMemberFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberFindUnique) with()                {}
func (r guildMemberFindUnique) guildMemberModel()    {}
func (r guildMemberFindUnique) guildMemberRelation() {}

func (r guildMemberActions) FindUnique(
	params GuildMemberEqualsUniqueWhereParam,
) guildMemberFindUnique {
	var v guildMemberFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "GuildMember"
	v.query.Outputs = guildMemberOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r guildMemberFindUnique) With(params ...GuildMemberRelationWith) guildMemberFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildMemberFindUnique) Select(params ...guildMemberPrismaFields) guildMemberFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberFindUnique) Omit(params ...guildMemberPrismaFields) guildMemberFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildMemberOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberFindUnique) Exec(ctx context.Context) (
	*GuildMemberModel,
	error,
) {
	var v *GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildMemberFindUnique) ExecInner(ctx context.Context) (
	*InnerGuildMember,
	error,
) {
	var v *InnerGuildMember
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildMemberFindUnique) Update(params ...GuildMemberSetParam) guildMemberUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "GuildMember"

	var v guildMemberUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildMemberUpdateUnique struct {
	query builder.Query
}

func (r guildMemberUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberUpdateUnique) guildMemberModel() {}

func (r guildMemberUpdateUnique) Exec(ctx context.Context) (*GuildMemberModel, error) {
	var v GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberUpdateUnique) Tx() GuildMemberUniqueTxResult {
	v := newGuildMemberUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildMemberFindUnique) Delete() guildMemberDeleteUnique {
	var v guildMemberDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "GuildMember"

	return v
}

type guildMemberDeleteUnique struct {
	query builder.Query
}

func (r guildMemberDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p guildMemberDeleteUnique) guildMemberModel() {}

func (r guildMemberDeleteUnique) Exec(ctx context.Context) (*GuildMemberModel, error) {
	var v GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberDeleteUnique) Tx() GuildMemberUniqueTxResult {
	v := newGuildMemberUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildMemberFindFirst struct {
	query builder.Query
}

func (r guildMemberFindFirst) getQuery() builder.Query {
	return r.query
}

func (r guildMemberFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberFindFirst) with()                {}
func (r guildMemberFindFirst) guildMemberModel()    {}
func (r guildMemberFindFirst) guildMemberRelation() {}

func (r guildMemberActions) FindFirst(
	params ...GuildMemberWhereParam,
) guildMemberFindFirst {
	var v guildMemberFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "GuildMember"
	v.query.Outputs = guildMemberOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r guildMemberFindFirst) With(params ...GuildMemberRelationWith) guildMemberFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildMemberFindFirst) Select(params ...guildMemberPrismaFields) guildMemberFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberFindFirst) Omit(params ...guildMemberPrismaFields) guildMemberFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildMemberOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberFindFirst) OrderBy(params ...GuildMemberOrderByParam) guildMemberFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildMemberFindFirst) Skip(count int) guildMemberFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildMemberFindFirst) Take(count int) guildMemberFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildMemberFindFirst) Cursor(cursor GuildMemberCursorParam) guildMemberFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildMemberFindFirst) Exec(ctx context.Context) (
	*GuildMemberModel,
	error,
) {
	var v *GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r guildMemberFindFirst) ExecInner(ctx context.Context) (
	*InnerGuildMember,
	error,
) {
	var v *InnerGuildMember
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type guildMemberFindMany struct {
	query builder.Query
}

func (r guildMemberFindMany) getQuery() builder.Query {
	return r.query
}

func (r guildMemberFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberFindMany) with()                {}
func (r guildMemberFindMany) guildMemberModel()    {}
func (r guildMemberFindMany) guildMemberRelation() {}

func (r guildMemberActions) FindMany(
	params ...GuildMemberWhereParam,
) guildMemberFindMany {
	var v guildMemberFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "GuildMember"
	v.query.Outputs = guildMemberOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r guildMemberFindMany) With(params ...GuildMemberRelationWith) guildMemberFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r guildMemberFindMany) Select(params ...guildMemberPrismaFields) guildMemberFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberFindMany) Omit(params ...guildMemberPrismaFields) guildMemberFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range guildMemberOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r guildMemberFindMany) OrderBy(params ...GuildMemberOrderByParam) guildMemberFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r guildMemberFindMany) Skip(count int) guildMemberFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r guildMemberFindMany) Take(count int) guildMemberFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r guildMemberFindMany) Cursor(cursor GuildMemberCursorParam) guildMemberFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r guildMemberFindMany) Exec(ctx context.Context) (
	[]GuildMemberModel,
	error,
) {
	var v []GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildMemberFindMany) ExecInner(ctx context.Context) (
	[]InnerGuildMember,
	error,
) {
	var v []InnerGuildMember
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r guildMemberFindMany) Update(params ...GuildMemberSetParam) guildMemberUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "GuildMember"

	r.query.Outputs = countOutput

	var v guildMemberUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type guildMemberUpdateMany struct {
	query builder.Query
}

func (r guildMemberUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberUpdateMany) guildMemberModel() {}

func (r guildMemberUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberUpdateMany) Tx() GuildMemberManyTxResult {
	v := newGuildMemberManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r guildMemberFindMany) Delete() guildMemberDeleteMany {
	var v guildMemberDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "GuildMember"

	v.query.Outputs = countOutput

	return v
}

type guildMemberDeleteMany struct {
	query builder.Query
}

func (r guildMemberDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p guildMemberDeleteMany) guildMemberModel() {}

func (r guildMemberDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberDeleteMany) Tx() GuildMemberManyTxResult {
	v := newGuildMemberManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosToOwnerFindUnique struct {
	query builder.Query
}

func (r videosToOwnerFindUnique) getQuery() builder.Query {
	return r.query
}

func (r videosToOwnerFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToOwnerFindUnique) with()           {}
func (r videosToOwnerFindUnique) videosModel()    {}
func (r videosToOwnerFindUnique) videosRelation() {}

func (r videosToOwnerFindUnique) With(params ...UserRelationWith) videosToOwnerFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToOwnerFindUnique) Select(params ...videosPrismaFields) videosToOwnerFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToOwnerFindUnique) Omit(params ...videosPrismaFields) videosToOwnerFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToOwnerFindUnique) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToOwnerFindUnique) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToOwnerFindUnique) Update(params ...VideosSetParam) videosToOwnerUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Videos"

	var v videosToOwnerUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosToOwnerUpdateUnique struct {
	query builder.Query
}

func (r videosToOwnerUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToOwnerUpdateUnique) videosModel() {}

func (r videosToOwnerUpdateUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToOwnerUpdateUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosToOwnerFindUnique) Delete() videosToOwnerDeleteUnique {
	var v videosToOwnerDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Videos"

	return v
}

type videosToOwnerDeleteUnique struct {
	query builder.Query
}

func (r videosToOwnerDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p videosToOwnerDeleteUnique) videosModel() {}

func (r videosToOwnerDeleteUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToOwnerDeleteUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosToOwnerFindFirst struct {
	query builder.Query
}

func (r videosToOwnerFindFirst) getQuery() builder.Query {
	return r.query
}

func (r videosToOwnerFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToOwnerFindFirst) with()           {}
func (r videosToOwnerFindFirst) videosModel()    {}
func (r videosToOwnerFindFirst) videosRelation() {}

func (r videosToOwnerFindFirst) With(params ...UserRelationWith) videosToOwnerFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToOwnerFindFirst) Select(params ...videosPrismaFields) videosToOwnerFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToOwnerFindFirst) Omit(params ...videosPrismaFields) videosToOwnerFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToOwnerFindFirst) OrderBy(params ...UserOrderByParam) videosToOwnerFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosToOwnerFindFirst) Skip(count int) videosToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosToOwnerFindFirst) Take(count int) videosToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosToOwnerFindFirst) Cursor(cursor VideosCursorParam) videosToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosToOwnerFindFirst) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToOwnerFindFirst) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type videosToOwnerFindMany struct {
	query builder.Query
}

func (r videosToOwnerFindMany) getQuery() builder.Query {
	return r.query
}

func (r videosToOwnerFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToOwnerFindMany) with()           {}
func (r videosToOwnerFindMany) videosModel()    {}
func (r videosToOwnerFindMany) videosRelation() {}

func (r videosToOwnerFindMany) With(params ...UserRelationWith) videosToOwnerFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToOwnerFindMany) Select(params ...videosPrismaFields) videosToOwnerFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToOwnerFindMany) Omit(params ...videosPrismaFields) videosToOwnerFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToOwnerFindMany) OrderBy(params ...UserOrderByParam) videosToOwnerFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosToOwnerFindMany) Skip(count int) videosToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosToOwnerFindMany) Take(count int) videosToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosToOwnerFindMany) Cursor(cursor VideosCursorParam) videosToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosToOwnerFindMany) Exec(ctx context.Context) (
	[]VideosModel,
	error,
) {
	var v []VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosToOwnerFindMany) ExecInner(ctx context.Context) (
	[]InnerVideos,
	error,
) {
	var v []InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosToOwnerFindMany) Update(params ...VideosSetParam) videosToOwnerUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Videos"

	r.query.Outputs = countOutput

	var v videosToOwnerUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosToOwnerUpdateMany struct {
	query builder.Query
}

func (r videosToOwnerUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToOwnerUpdateMany) videosModel() {}

func (r videosToOwnerUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToOwnerUpdateMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosToOwnerFindMany) Delete() videosToOwnerDeleteMany {
	var v videosToOwnerDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Videos"

	v.query.Outputs = countOutput

	return v
}

type videosToOwnerDeleteMany struct {
	query builder.Query
}

func (r videosToOwnerDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p videosToOwnerDeleteMany) videosModel() {}

func (r videosToOwnerDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToOwnerDeleteMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosToGuildFindUnique struct {
	query builder.Query
}

func (r videosToGuildFindUnique) getQuery() builder.Query {
	return r.query
}

func (r videosToGuildFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToGuildFindUnique) with()           {}
func (r videosToGuildFindUnique) videosModel()    {}
func (r videosToGuildFindUnique) videosRelation() {}

func (r videosToGuildFindUnique) With(params ...GuildRelationWith) videosToGuildFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToGuildFindUnique) Select(params ...videosPrismaFields) videosToGuildFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToGuildFindUnique) Omit(params ...videosPrismaFields) videosToGuildFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToGuildFindUnique) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToGuildFindUnique) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToGuildFindUnique) Update(params ...VideosSetParam) videosToGuildUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Videos"

	var v videosToGuildUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosToGuildUpdateUnique struct {
	query builder.Query
}

func (r videosToGuildUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToGuildUpdateUnique) videosModel() {}

func (r videosToGuildUpdateUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToGuildUpdateUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosToGuildFindUnique) Delete() videosToGuildDeleteUnique {
	var v videosToGuildDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Videos"

	return v
}

type videosToGuildDeleteUnique struct {
	query builder.Query
}

func (r videosToGuildDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p videosToGuildDeleteUnique) videosModel() {}

func (r videosToGuildDeleteUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToGuildDeleteUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosToGuildFindFirst struct {
	query builder.Query
}

func (r videosToGuildFindFirst) getQuery() builder.Query {
	return r.query
}

func (r videosToGuildFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToGuildFindFirst) with()           {}
func (r videosToGuildFindFirst) videosModel()    {}
func (r videosToGuildFindFirst) videosRelation() {}

func (r videosToGuildFindFirst) With(params ...GuildRelationWith) videosToGuildFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToGuildFindFirst) Select(params ...videosPrismaFields) videosToGuildFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToGuildFindFirst) Omit(params ...videosPrismaFields) videosToGuildFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToGuildFindFirst) OrderBy(params ...GuildOrderByParam) videosToGuildFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosToGuildFindFirst) Skip(count int) videosToGuildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosToGuildFindFirst) Take(count int) videosToGuildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosToGuildFindFirst) Cursor(cursor VideosCursorParam) videosToGuildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosToGuildFindFirst) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToGuildFindFirst) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type videosToGuildFindMany struct {
	query builder.Query
}

func (r videosToGuildFindMany) getQuery() builder.Query {
	return r.query
}

func (r videosToGuildFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToGuildFindMany) with()           {}
func (r videosToGuildFindMany) videosModel()    {}
func (r videosToGuildFindMany) videosRelation() {}

func (r videosToGuildFindMany) With(params ...GuildRelationWith) videosToGuildFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToGuildFindMany) Select(params ...videosPrismaFields) videosToGuildFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToGuildFindMany) Omit(params ...videosPrismaFields) videosToGuildFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToGuildFindMany) OrderBy(params ...GuildOrderByParam) videosToGuildFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosToGuildFindMany) Skip(count int) videosToGuildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosToGuildFindMany) Take(count int) videosToGuildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosToGuildFindMany) Cursor(cursor VideosCursorParam) videosToGuildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosToGuildFindMany) Exec(ctx context.Context) (
	[]VideosModel,
	error,
) {
	var v []VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosToGuildFindMany) ExecInner(ctx context.Context) (
	[]InnerVideos,
	error,
) {
	var v []InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosToGuildFindMany) Update(params ...VideosSetParam) videosToGuildUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Videos"

	r.query.Outputs = countOutput

	var v videosToGuildUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosToGuildUpdateMany struct {
	query builder.Query
}

func (r videosToGuildUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToGuildUpdateMany) videosModel() {}

func (r videosToGuildUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToGuildUpdateMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosToGuildFindMany) Delete() videosToGuildDeleteMany {
	var v videosToGuildDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Videos"

	v.query.Outputs = countOutput

	return v
}

type videosToGuildDeleteMany struct {
	query builder.Query
}

func (r videosToGuildDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p videosToGuildDeleteMany) videosModel() {}

func (r videosToGuildDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToGuildDeleteMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosToTagsFindUnique struct {
	query builder.Query
}

func (r videosToTagsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r videosToTagsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToTagsFindUnique) with()           {}
func (r videosToTagsFindUnique) videosModel()    {}
func (r videosToTagsFindUnique) videosRelation() {}

func (r videosToTagsFindUnique) With(params ...TagsOnVideosRelationWith) videosToTagsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToTagsFindUnique) Select(params ...videosPrismaFields) videosToTagsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToTagsFindUnique) Omit(params ...videosPrismaFields) videosToTagsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToTagsFindUnique) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToTagsFindUnique) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToTagsFindUnique) Update(params ...VideosSetParam) videosToTagsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Videos"

	var v videosToTagsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosToTagsUpdateUnique struct {
	query builder.Query
}

func (r videosToTagsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToTagsUpdateUnique) videosModel() {}

func (r videosToTagsUpdateUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToTagsUpdateUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosToTagsFindUnique) Delete() videosToTagsDeleteUnique {
	var v videosToTagsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Videos"

	return v
}

type videosToTagsDeleteUnique struct {
	query builder.Query
}

func (r videosToTagsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p videosToTagsDeleteUnique) videosModel() {}

func (r videosToTagsDeleteUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToTagsDeleteUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosToTagsFindFirst struct {
	query builder.Query
}

func (r videosToTagsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r videosToTagsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToTagsFindFirst) with()           {}
func (r videosToTagsFindFirst) videosModel()    {}
func (r videosToTagsFindFirst) videosRelation() {}

func (r videosToTagsFindFirst) With(params ...TagsOnVideosRelationWith) videosToTagsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToTagsFindFirst) Select(params ...videosPrismaFields) videosToTagsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToTagsFindFirst) Omit(params ...videosPrismaFields) videosToTagsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToTagsFindFirst) OrderBy(params ...TagsOnVideosOrderByParam) videosToTagsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosToTagsFindFirst) Skip(count int) videosToTagsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosToTagsFindFirst) Take(count int) videosToTagsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosToTagsFindFirst) Cursor(cursor VideosCursorParam) videosToTagsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosToTagsFindFirst) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToTagsFindFirst) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type videosToTagsFindMany struct {
	query builder.Query
}

func (r videosToTagsFindMany) getQuery() builder.Query {
	return r.query
}

func (r videosToTagsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToTagsFindMany) with()           {}
func (r videosToTagsFindMany) videosModel()    {}
func (r videosToTagsFindMany) videosRelation() {}

func (r videosToTagsFindMany) With(params ...TagsOnVideosRelationWith) videosToTagsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToTagsFindMany) Select(params ...videosPrismaFields) videosToTagsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToTagsFindMany) Omit(params ...videosPrismaFields) videosToTagsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToTagsFindMany) OrderBy(params ...TagsOnVideosOrderByParam) videosToTagsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosToTagsFindMany) Skip(count int) videosToTagsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosToTagsFindMany) Take(count int) videosToTagsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosToTagsFindMany) Cursor(cursor VideosCursorParam) videosToTagsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosToTagsFindMany) Exec(ctx context.Context) (
	[]VideosModel,
	error,
) {
	var v []VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosToTagsFindMany) ExecInner(ctx context.Context) (
	[]InnerVideos,
	error,
) {
	var v []InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosToTagsFindMany) Update(params ...VideosSetParam) videosToTagsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Videos"

	r.query.Outputs = countOutput

	var v videosToTagsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosToTagsUpdateMany struct {
	query builder.Query
}

func (r videosToTagsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToTagsUpdateMany) videosModel() {}

func (r videosToTagsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToTagsUpdateMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosToTagsFindMany) Delete() videosToTagsDeleteMany {
	var v videosToTagsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Videos"

	v.query.Outputs = countOutput

	return v
}

type videosToTagsDeleteMany struct {
	query builder.Query
}

func (r videosToTagsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p videosToTagsDeleteMany) videosModel() {}

func (r videosToTagsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToTagsDeleteMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosToLikesFindUnique struct {
	query builder.Query
}

func (r videosToLikesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r videosToLikesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToLikesFindUnique) with()           {}
func (r videosToLikesFindUnique) videosModel()    {}
func (r videosToLikesFindUnique) videosRelation() {}

func (r videosToLikesFindUnique) With(params ...LikesRelationWith) videosToLikesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToLikesFindUnique) Select(params ...videosPrismaFields) videosToLikesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToLikesFindUnique) Omit(params ...videosPrismaFields) videosToLikesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToLikesFindUnique) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToLikesFindUnique) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToLikesFindUnique) Update(params ...VideosSetParam) videosToLikesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Videos"

	var v videosToLikesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosToLikesUpdateUnique struct {
	query builder.Query
}

func (r videosToLikesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToLikesUpdateUnique) videosModel() {}

func (r videosToLikesUpdateUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToLikesUpdateUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosToLikesFindUnique) Delete() videosToLikesDeleteUnique {
	var v videosToLikesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Videos"

	return v
}

type videosToLikesDeleteUnique struct {
	query builder.Query
}

func (r videosToLikesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p videosToLikesDeleteUnique) videosModel() {}

func (r videosToLikesDeleteUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToLikesDeleteUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosToLikesFindFirst struct {
	query builder.Query
}

func (r videosToLikesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r videosToLikesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToLikesFindFirst) with()           {}
func (r videosToLikesFindFirst) videosModel()    {}
func (r videosToLikesFindFirst) videosRelation() {}

func (r videosToLikesFindFirst) With(params ...LikesRelationWith) videosToLikesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToLikesFindFirst) Select(params ...videosPrismaFields) videosToLikesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToLikesFindFirst) Omit(params ...videosPrismaFields) videosToLikesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToLikesFindFirst) OrderBy(params ...LikesOrderByParam) videosToLikesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosToLikesFindFirst) Skip(count int) videosToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosToLikesFindFirst) Take(count int) videosToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosToLikesFindFirst) Cursor(cursor VideosCursorParam) videosToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosToLikesFindFirst) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToLikesFindFirst) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type videosToLikesFindMany struct {
	query builder.Query
}

func (r videosToLikesFindMany) getQuery() builder.Query {
	return r.query
}

func (r videosToLikesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToLikesFindMany) with()           {}
func (r videosToLikesFindMany) videosModel()    {}
func (r videosToLikesFindMany) videosRelation() {}

func (r videosToLikesFindMany) With(params ...LikesRelationWith) videosToLikesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToLikesFindMany) Select(params ...videosPrismaFields) videosToLikesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToLikesFindMany) Omit(params ...videosPrismaFields) videosToLikesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToLikesFindMany) OrderBy(params ...LikesOrderByParam) videosToLikesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosToLikesFindMany) Skip(count int) videosToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosToLikesFindMany) Take(count int) videosToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosToLikesFindMany) Cursor(cursor VideosCursorParam) videosToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosToLikesFindMany) Exec(ctx context.Context) (
	[]VideosModel,
	error,
) {
	var v []VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosToLikesFindMany) ExecInner(ctx context.Context) (
	[]InnerVideos,
	error,
) {
	var v []InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosToLikesFindMany) Update(params ...VideosSetParam) videosToLikesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Videos"

	r.query.Outputs = countOutput

	var v videosToLikesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosToLikesUpdateMany struct {
	query builder.Query
}

func (r videosToLikesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToLikesUpdateMany) videosModel() {}

func (r videosToLikesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToLikesUpdateMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosToLikesFindMany) Delete() videosToLikesDeleteMany {
	var v videosToLikesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Videos"

	v.query.Outputs = countOutput

	return v
}

type videosToLikesDeleteMany struct {
	query builder.Query
}

func (r videosToLikesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p videosToLikesDeleteMany) videosModel() {}

func (r videosToLikesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToLikesDeleteMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosToHistoryFindUnique struct {
	query builder.Query
}

func (r videosToHistoryFindUnique) getQuery() builder.Query {
	return r.query
}

func (r videosToHistoryFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToHistoryFindUnique) with()           {}
func (r videosToHistoryFindUnique) videosModel()    {}
func (r videosToHistoryFindUnique) videosRelation() {}

func (r videosToHistoryFindUnique) With(params ...HistoryRelationWith) videosToHistoryFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToHistoryFindUnique) Select(params ...videosPrismaFields) videosToHistoryFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToHistoryFindUnique) Omit(params ...videosPrismaFields) videosToHistoryFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToHistoryFindUnique) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToHistoryFindUnique) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToHistoryFindUnique) Update(params ...VideosSetParam) videosToHistoryUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Videos"

	var v videosToHistoryUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosToHistoryUpdateUnique struct {
	query builder.Query
}

func (r videosToHistoryUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToHistoryUpdateUnique) videosModel() {}

func (r videosToHistoryUpdateUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToHistoryUpdateUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosToHistoryFindUnique) Delete() videosToHistoryDeleteUnique {
	var v videosToHistoryDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Videos"

	return v
}

type videosToHistoryDeleteUnique struct {
	query builder.Query
}

func (r videosToHistoryDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p videosToHistoryDeleteUnique) videosModel() {}

func (r videosToHistoryDeleteUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToHistoryDeleteUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosToHistoryFindFirst struct {
	query builder.Query
}

func (r videosToHistoryFindFirst) getQuery() builder.Query {
	return r.query
}

func (r videosToHistoryFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToHistoryFindFirst) with()           {}
func (r videosToHistoryFindFirst) videosModel()    {}
func (r videosToHistoryFindFirst) videosRelation() {}

func (r videosToHistoryFindFirst) With(params ...HistoryRelationWith) videosToHistoryFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToHistoryFindFirst) Select(params ...videosPrismaFields) videosToHistoryFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToHistoryFindFirst) Omit(params ...videosPrismaFields) videosToHistoryFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToHistoryFindFirst) OrderBy(params ...HistoryOrderByParam) videosToHistoryFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosToHistoryFindFirst) Skip(count int) videosToHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosToHistoryFindFirst) Take(count int) videosToHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosToHistoryFindFirst) Cursor(cursor VideosCursorParam) videosToHistoryFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosToHistoryFindFirst) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToHistoryFindFirst) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type videosToHistoryFindMany struct {
	query builder.Query
}

func (r videosToHistoryFindMany) getQuery() builder.Query {
	return r.query
}

func (r videosToHistoryFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToHistoryFindMany) with()           {}
func (r videosToHistoryFindMany) videosModel()    {}
func (r videosToHistoryFindMany) videosRelation() {}

func (r videosToHistoryFindMany) With(params ...HistoryRelationWith) videosToHistoryFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToHistoryFindMany) Select(params ...videosPrismaFields) videosToHistoryFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToHistoryFindMany) Omit(params ...videosPrismaFields) videosToHistoryFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToHistoryFindMany) OrderBy(params ...HistoryOrderByParam) videosToHistoryFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosToHistoryFindMany) Skip(count int) videosToHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosToHistoryFindMany) Take(count int) videosToHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosToHistoryFindMany) Cursor(cursor VideosCursorParam) videosToHistoryFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosToHistoryFindMany) Exec(ctx context.Context) (
	[]VideosModel,
	error,
) {
	var v []VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosToHistoryFindMany) ExecInner(ctx context.Context) (
	[]InnerVideos,
	error,
) {
	var v []InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosToHistoryFindMany) Update(params ...VideosSetParam) videosToHistoryUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Videos"

	r.query.Outputs = countOutput

	var v videosToHistoryUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosToHistoryUpdateMany struct {
	query builder.Query
}

func (r videosToHistoryUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToHistoryUpdateMany) videosModel() {}

func (r videosToHistoryUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToHistoryUpdateMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosToHistoryFindMany) Delete() videosToHistoryDeleteMany {
	var v videosToHistoryDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Videos"

	v.query.Outputs = countOutput

	return v
}

type videosToHistoryDeleteMany struct {
	query builder.Query
}

func (r videosToHistoryDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p videosToHistoryDeleteMany) videosModel() {}

func (r videosToHistoryDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToHistoryDeleteMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosToWatchLaterFindUnique struct {
	query builder.Query
}

func (r videosToWatchLaterFindUnique) getQuery() builder.Query {
	return r.query
}

func (r videosToWatchLaterFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToWatchLaterFindUnique) with()           {}
func (r videosToWatchLaterFindUnique) videosModel()    {}
func (r videosToWatchLaterFindUnique) videosRelation() {}

func (r videosToWatchLaterFindUnique) With(params ...WatchLaterRelationWith) videosToWatchLaterFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToWatchLaterFindUnique) Select(params ...videosPrismaFields) videosToWatchLaterFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToWatchLaterFindUnique) Omit(params ...videosPrismaFields) videosToWatchLaterFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToWatchLaterFindUnique) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToWatchLaterFindUnique) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToWatchLaterFindUnique) Update(params ...VideosSetParam) videosToWatchLaterUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Videos"

	var v videosToWatchLaterUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosToWatchLaterUpdateUnique struct {
	query builder.Query
}

func (r videosToWatchLaterUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToWatchLaterUpdateUnique) videosModel() {}

func (r videosToWatchLaterUpdateUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToWatchLaterUpdateUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosToWatchLaterFindUnique) Delete() videosToWatchLaterDeleteUnique {
	var v videosToWatchLaterDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Videos"

	return v
}

type videosToWatchLaterDeleteUnique struct {
	query builder.Query
}

func (r videosToWatchLaterDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p videosToWatchLaterDeleteUnique) videosModel() {}

func (r videosToWatchLaterDeleteUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToWatchLaterDeleteUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosToWatchLaterFindFirst struct {
	query builder.Query
}

func (r videosToWatchLaterFindFirst) getQuery() builder.Query {
	return r.query
}

func (r videosToWatchLaterFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToWatchLaterFindFirst) with()           {}
func (r videosToWatchLaterFindFirst) videosModel()    {}
func (r videosToWatchLaterFindFirst) videosRelation() {}

func (r videosToWatchLaterFindFirst) With(params ...WatchLaterRelationWith) videosToWatchLaterFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToWatchLaterFindFirst) Select(params ...videosPrismaFields) videosToWatchLaterFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToWatchLaterFindFirst) Omit(params ...videosPrismaFields) videosToWatchLaterFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToWatchLaterFindFirst) OrderBy(params ...WatchLaterOrderByParam) videosToWatchLaterFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosToWatchLaterFindFirst) Skip(count int) videosToWatchLaterFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosToWatchLaterFindFirst) Take(count int) videosToWatchLaterFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosToWatchLaterFindFirst) Cursor(cursor VideosCursorParam) videosToWatchLaterFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosToWatchLaterFindFirst) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosToWatchLaterFindFirst) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type videosToWatchLaterFindMany struct {
	query builder.Query
}

func (r videosToWatchLaterFindMany) getQuery() builder.Query {
	return r.query
}

func (r videosToWatchLaterFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToWatchLaterFindMany) with()           {}
func (r videosToWatchLaterFindMany) videosModel()    {}
func (r videosToWatchLaterFindMany) videosRelation() {}

func (r videosToWatchLaterFindMany) With(params ...WatchLaterRelationWith) videosToWatchLaterFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosToWatchLaterFindMany) Select(params ...videosPrismaFields) videosToWatchLaterFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToWatchLaterFindMany) Omit(params ...videosPrismaFields) videosToWatchLaterFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosToWatchLaterFindMany) OrderBy(params ...WatchLaterOrderByParam) videosToWatchLaterFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosToWatchLaterFindMany) Skip(count int) videosToWatchLaterFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosToWatchLaterFindMany) Take(count int) videosToWatchLaterFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosToWatchLaterFindMany) Cursor(cursor VideosCursorParam) videosToWatchLaterFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosToWatchLaterFindMany) Exec(ctx context.Context) (
	[]VideosModel,
	error,
) {
	var v []VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosToWatchLaterFindMany) ExecInner(ctx context.Context) (
	[]InnerVideos,
	error,
) {
	var v []InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosToWatchLaterFindMany) Update(params ...VideosSetParam) videosToWatchLaterUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Videos"

	r.query.Outputs = countOutput

	var v videosToWatchLaterUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosToWatchLaterUpdateMany struct {
	query builder.Query
}

func (r videosToWatchLaterUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosToWatchLaterUpdateMany) videosModel() {}

func (r videosToWatchLaterUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToWatchLaterUpdateMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosToWatchLaterFindMany) Delete() videosToWatchLaterDeleteMany {
	var v videosToWatchLaterDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Videos"

	v.query.Outputs = countOutput

	return v
}

type videosToWatchLaterDeleteMany struct {
	query builder.Query
}

func (r videosToWatchLaterDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p videosToWatchLaterDeleteMany) videosModel() {}

func (r videosToWatchLaterDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosToWatchLaterDeleteMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosFindUnique struct {
	query builder.Query
}

func (r videosFindUnique) getQuery() builder.Query {
	return r.query
}

func (r videosFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosFindUnique) with()           {}
func (r videosFindUnique) videosModel()    {}
func (r videosFindUnique) videosRelation() {}

func (r videosActions) FindUnique(
	params VideosEqualsUniqueWhereParam,
) videosFindUnique {
	var v videosFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Videos"
	v.query.Outputs = videosOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r videosFindUnique) With(params ...VideosRelationWith) videosFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosFindUnique) Select(params ...videosPrismaFields) videosFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosFindUnique) Omit(params ...videosPrismaFields) videosFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosFindUnique) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosFindUnique) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosFindUnique) Update(params ...VideosSetParam) videosUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Videos"

	var v videosUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosUpdateUnique struct {
	query builder.Query
}

func (r videosUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r videosUpdateUnique) videosModel() {}

func (r videosUpdateUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosUpdateUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosFindUnique) Delete() videosDeleteUnique {
	var v videosDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Videos"

	return v
}

type videosDeleteUnique struct {
	query builder.Query
}

func (r videosDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p videosDeleteUnique) videosModel() {}

func (r videosDeleteUnique) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosDeleteUnique) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosFindFirst struct {
	query builder.Query
}

func (r videosFindFirst) getQuery() builder.Query {
	return r.query
}

func (r videosFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r videosFindFirst) with()           {}
func (r videosFindFirst) videosModel()    {}
func (r videosFindFirst) videosRelation() {}

func (r videosActions) FindFirst(
	params ...VideosWhereParam,
) videosFindFirst {
	var v videosFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Videos"
	v.query.Outputs = videosOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r videosFindFirst) With(params ...VideosRelationWith) videosFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosFindFirst) Select(params ...videosPrismaFields) videosFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosFindFirst) Omit(params ...videosPrismaFields) videosFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosFindFirst) OrderBy(params ...VideosOrderByParam) videosFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosFindFirst) Skip(count int) videosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosFindFirst) Take(count int) videosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosFindFirst) Cursor(cursor VideosCursorParam) videosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosFindFirst) Exec(ctx context.Context) (
	*VideosModel,
	error,
) {
	var v *VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r videosFindFirst) ExecInner(ctx context.Context) (
	*InnerVideos,
	error,
) {
	var v *InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type videosFindMany struct {
	query builder.Query
}

func (r videosFindMany) getQuery() builder.Query {
	return r.query
}

func (r videosFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosFindMany) with()           {}
func (r videosFindMany) videosModel()    {}
func (r videosFindMany) videosRelation() {}

func (r videosActions) FindMany(
	params ...VideosWhereParam,
) videosFindMany {
	var v videosFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Videos"
	v.query.Outputs = videosOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r videosFindMany) With(params ...VideosRelationWith) videosFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r videosFindMany) Select(params ...videosPrismaFields) videosFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r videosFindMany) Omit(params ...videosPrismaFields) videosFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range videosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r videosFindMany) OrderBy(params ...VideosOrderByParam) videosFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r videosFindMany) Skip(count int) videosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r videosFindMany) Take(count int) videosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r videosFindMany) Cursor(cursor VideosCursorParam) videosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r videosFindMany) Exec(ctx context.Context) (
	[]VideosModel,
	error,
) {
	var v []VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosFindMany) ExecInner(ctx context.Context) (
	[]InnerVideos,
	error,
) {
	var v []InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r videosFindMany) Update(params ...VideosSetParam) videosUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Videos"

	r.query.Outputs = countOutput

	var v videosUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type videosUpdateMany struct {
	query builder.Query
}

func (r videosUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r videosUpdateMany) videosModel() {}

func (r videosUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosUpdateMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r videosFindMany) Delete() videosDeleteMany {
	var v videosDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Videos"

	v.query.Outputs = countOutput

	return v
}

type videosDeleteMany struct {
	query builder.Query
}

func (r videosDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p videosDeleteMany) videosModel() {}

func (r videosDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosDeleteMany) Tx() VideosManyTxResult {
	v := newVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsToGuildFindUnique struct {
	query builder.Query
}

func (r tagsToGuildFindUnique) getQuery() builder.Query {
	return r.query
}

func (r tagsToGuildFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsToGuildFindUnique) with()         {}
func (r tagsToGuildFindUnique) tagsModel()    {}
func (r tagsToGuildFindUnique) tagsRelation() {}

func (r tagsToGuildFindUnique) With(params ...GuildRelationWith) tagsToGuildFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsToGuildFindUnique) Select(params ...tagsPrismaFields) tagsToGuildFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsToGuildFindUnique) Omit(params ...tagsPrismaFields) tagsToGuildFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsToGuildFindUnique) Exec(ctx context.Context) (
	*TagsModel,
	error,
) {
	var v *TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsToGuildFindUnique) ExecInner(ctx context.Context) (
	*InnerTags,
	error,
) {
	var v *InnerTags
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsToGuildFindUnique) Update(params ...TagsSetParam) tagsToGuildUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Tags"

	var v tagsToGuildUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagsToGuildUpdateUnique struct {
	query builder.Query
}

func (r tagsToGuildUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsToGuildUpdateUnique) tagsModel() {}

func (r tagsToGuildUpdateUnique) Exec(ctx context.Context) (*TagsModel, error) {
	var v TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsToGuildUpdateUnique) Tx() TagsUniqueTxResult {
	v := newTagsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagsToGuildFindUnique) Delete() tagsToGuildDeleteUnique {
	var v tagsToGuildDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Tags"

	return v
}

type tagsToGuildDeleteUnique struct {
	query builder.Query
}

func (r tagsToGuildDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p tagsToGuildDeleteUnique) tagsModel() {}

func (r tagsToGuildDeleteUnique) Exec(ctx context.Context) (*TagsModel, error) {
	var v TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsToGuildDeleteUnique) Tx() TagsUniqueTxResult {
	v := newTagsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsToGuildFindFirst struct {
	query builder.Query
}

func (r tagsToGuildFindFirst) getQuery() builder.Query {
	return r.query
}

func (r tagsToGuildFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsToGuildFindFirst) with()         {}
func (r tagsToGuildFindFirst) tagsModel()    {}
func (r tagsToGuildFindFirst) tagsRelation() {}

func (r tagsToGuildFindFirst) With(params ...GuildRelationWith) tagsToGuildFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsToGuildFindFirst) Select(params ...tagsPrismaFields) tagsToGuildFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsToGuildFindFirst) Omit(params ...tagsPrismaFields) tagsToGuildFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsToGuildFindFirst) OrderBy(params ...GuildOrderByParam) tagsToGuildFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagsToGuildFindFirst) Skip(count int) tagsToGuildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagsToGuildFindFirst) Take(count int) tagsToGuildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagsToGuildFindFirst) Cursor(cursor TagsCursorParam) tagsToGuildFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagsToGuildFindFirst) Exec(ctx context.Context) (
	*TagsModel,
	error,
) {
	var v *TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsToGuildFindFirst) ExecInner(ctx context.Context) (
	*InnerTags,
	error,
) {
	var v *InnerTags
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type tagsToGuildFindMany struct {
	query builder.Query
}

func (r tagsToGuildFindMany) getQuery() builder.Query {
	return r.query
}

func (r tagsToGuildFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsToGuildFindMany) with()         {}
func (r tagsToGuildFindMany) tagsModel()    {}
func (r tagsToGuildFindMany) tagsRelation() {}

func (r tagsToGuildFindMany) With(params ...GuildRelationWith) tagsToGuildFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsToGuildFindMany) Select(params ...tagsPrismaFields) tagsToGuildFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsToGuildFindMany) Omit(params ...tagsPrismaFields) tagsToGuildFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsToGuildFindMany) OrderBy(params ...GuildOrderByParam) tagsToGuildFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagsToGuildFindMany) Skip(count int) tagsToGuildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagsToGuildFindMany) Take(count int) tagsToGuildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagsToGuildFindMany) Cursor(cursor TagsCursorParam) tagsToGuildFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagsToGuildFindMany) Exec(ctx context.Context) (
	[]TagsModel,
	error,
) {
	var v []TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagsToGuildFindMany) ExecInner(ctx context.Context) (
	[]InnerTags,
	error,
) {
	var v []InnerTags
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagsToGuildFindMany) Update(params ...TagsSetParam) tagsToGuildUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Tags"

	r.query.Outputs = countOutput

	var v tagsToGuildUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagsToGuildUpdateMany struct {
	query builder.Query
}

func (r tagsToGuildUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsToGuildUpdateMany) tagsModel() {}

func (r tagsToGuildUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsToGuildUpdateMany) Tx() TagsManyTxResult {
	v := newTagsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagsToGuildFindMany) Delete() tagsToGuildDeleteMany {
	var v tagsToGuildDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Tags"

	v.query.Outputs = countOutput

	return v
}

type tagsToGuildDeleteMany struct {
	query builder.Query
}

func (r tagsToGuildDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p tagsToGuildDeleteMany) tagsModel() {}

func (r tagsToGuildDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsToGuildDeleteMany) Tx() TagsManyTxResult {
	v := newTagsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsToVideosFindUnique struct {
	query builder.Query
}

func (r tagsToVideosFindUnique) getQuery() builder.Query {
	return r.query
}

func (r tagsToVideosFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsToVideosFindUnique) with()         {}
func (r tagsToVideosFindUnique) tagsModel()    {}
func (r tagsToVideosFindUnique) tagsRelation() {}

func (r tagsToVideosFindUnique) With(params ...TagsOnVideosRelationWith) tagsToVideosFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsToVideosFindUnique) Select(params ...tagsPrismaFields) tagsToVideosFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsToVideosFindUnique) Omit(params ...tagsPrismaFields) tagsToVideosFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsToVideosFindUnique) Exec(ctx context.Context) (
	*TagsModel,
	error,
) {
	var v *TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsToVideosFindUnique) ExecInner(ctx context.Context) (
	*InnerTags,
	error,
) {
	var v *InnerTags
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsToVideosFindUnique) Update(params ...TagsSetParam) tagsToVideosUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Tags"

	var v tagsToVideosUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagsToVideosUpdateUnique struct {
	query builder.Query
}

func (r tagsToVideosUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsToVideosUpdateUnique) tagsModel() {}

func (r tagsToVideosUpdateUnique) Exec(ctx context.Context) (*TagsModel, error) {
	var v TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsToVideosUpdateUnique) Tx() TagsUniqueTxResult {
	v := newTagsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagsToVideosFindUnique) Delete() tagsToVideosDeleteUnique {
	var v tagsToVideosDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Tags"

	return v
}

type tagsToVideosDeleteUnique struct {
	query builder.Query
}

func (r tagsToVideosDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p tagsToVideosDeleteUnique) tagsModel() {}

func (r tagsToVideosDeleteUnique) Exec(ctx context.Context) (*TagsModel, error) {
	var v TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsToVideosDeleteUnique) Tx() TagsUniqueTxResult {
	v := newTagsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsToVideosFindFirst struct {
	query builder.Query
}

func (r tagsToVideosFindFirst) getQuery() builder.Query {
	return r.query
}

func (r tagsToVideosFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsToVideosFindFirst) with()         {}
func (r tagsToVideosFindFirst) tagsModel()    {}
func (r tagsToVideosFindFirst) tagsRelation() {}

func (r tagsToVideosFindFirst) With(params ...TagsOnVideosRelationWith) tagsToVideosFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsToVideosFindFirst) Select(params ...tagsPrismaFields) tagsToVideosFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsToVideosFindFirst) Omit(params ...tagsPrismaFields) tagsToVideosFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsToVideosFindFirst) OrderBy(params ...TagsOnVideosOrderByParam) tagsToVideosFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagsToVideosFindFirst) Skip(count int) tagsToVideosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagsToVideosFindFirst) Take(count int) tagsToVideosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagsToVideosFindFirst) Cursor(cursor TagsCursorParam) tagsToVideosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagsToVideosFindFirst) Exec(ctx context.Context) (
	*TagsModel,
	error,
) {
	var v *TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsToVideosFindFirst) ExecInner(ctx context.Context) (
	*InnerTags,
	error,
) {
	var v *InnerTags
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type tagsToVideosFindMany struct {
	query builder.Query
}

func (r tagsToVideosFindMany) getQuery() builder.Query {
	return r.query
}

func (r tagsToVideosFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsToVideosFindMany) with()         {}
func (r tagsToVideosFindMany) tagsModel()    {}
func (r tagsToVideosFindMany) tagsRelation() {}

func (r tagsToVideosFindMany) With(params ...TagsOnVideosRelationWith) tagsToVideosFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsToVideosFindMany) Select(params ...tagsPrismaFields) tagsToVideosFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsToVideosFindMany) Omit(params ...tagsPrismaFields) tagsToVideosFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsToVideosFindMany) OrderBy(params ...TagsOnVideosOrderByParam) tagsToVideosFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagsToVideosFindMany) Skip(count int) tagsToVideosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagsToVideosFindMany) Take(count int) tagsToVideosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagsToVideosFindMany) Cursor(cursor TagsCursorParam) tagsToVideosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagsToVideosFindMany) Exec(ctx context.Context) (
	[]TagsModel,
	error,
) {
	var v []TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagsToVideosFindMany) ExecInner(ctx context.Context) (
	[]InnerTags,
	error,
) {
	var v []InnerTags
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagsToVideosFindMany) Update(params ...TagsSetParam) tagsToVideosUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Tags"

	r.query.Outputs = countOutput

	var v tagsToVideosUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagsToVideosUpdateMany struct {
	query builder.Query
}

func (r tagsToVideosUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsToVideosUpdateMany) tagsModel() {}

func (r tagsToVideosUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsToVideosUpdateMany) Tx() TagsManyTxResult {
	v := newTagsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagsToVideosFindMany) Delete() tagsToVideosDeleteMany {
	var v tagsToVideosDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Tags"

	v.query.Outputs = countOutput

	return v
}

type tagsToVideosDeleteMany struct {
	query builder.Query
}

func (r tagsToVideosDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p tagsToVideosDeleteMany) tagsModel() {}

func (r tagsToVideosDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsToVideosDeleteMany) Tx() TagsManyTxResult {
	v := newTagsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsFindUnique struct {
	query builder.Query
}

func (r tagsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r tagsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsFindUnique) with()         {}
func (r tagsFindUnique) tagsModel()    {}
func (r tagsFindUnique) tagsRelation() {}

func (r tagsActions) FindUnique(
	params TagsEqualsUniqueWhereParam,
) tagsFindUnique {
	var v tagsFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Tags"
	v.query.Outputs = tagsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r tagsFindUnique) With(params ...TagsRelationWith) tagsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsFindUnique) Select(params ...tagsPrismaFields) tagsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsFindUnique) Omit(params ...tagsPrismaFields) tagsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsFindUnique) Exec(ctx context.Context) (
	*TagsModel,
	error,
) {
	var v *TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsFindUnique) ExecInner(ctx context.Context) (
	*InnerTags,
	error,
) {
	var v *InnerTags
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsFindUnique) Update(params ...TagsSetParam) tagsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Tags"

	var v tagsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagsUpdateUnique struct {
	query builder.Query
}

func (r tagsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsUpdateUnique) tagsModel() {}

func (r tagsUpdateUnique) Exec(ctx context.Context) (*TagsModel, error) {
	var v TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsUpdateUnique) Tx() TagsUniqueTxResult {
	v := newTagsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagsFindUnique) Delete() tagsDeleteUnique {
	var v tagsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Tags"

	return v
}

type tagsDeleteUnique struct {
	query builder.Query
}

func (r tagsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p tagsDeleteUnique) tagsModel() {}

func (r tagsDeleteUnique) Exec(ctx context.Context) (*TagsModel, error) {
	var v TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsDeleteUnique) Tx() TagsUniqueTxResult {
	v := newTagsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsFindFirst struct {
	query builder.Query
}

func (r tagsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r tagsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsFindFirst) with()         {}
func (r tagsFindFirst) tagsModel()    {}
func (r tagsFindFirst) tagsRelation() {}

func (r tagsActions) FindFirst(
	params ...TagsWhereParam,
) tagsFindFirst {
	var v tagsFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Tags"
	v.query.Outputs = tagsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r tagsFindFirst) With(params ...TagsRelationWith) tagsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsFindFirst) Select(params ...tagsPrismaFields) tagsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsFindFirst) Omit(params ...tagsPrismaFields) tagsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsFindFirst) OrderBy(params ...TagsOrderByParam) tagsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagsFindFirst) Skip(count int) tagsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagsFindFirst) Take(count int) tagsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagsFindFirst) Cursor(cursor TagsCursorParam) tagsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagsFindFirst) Exec(ctx context.Context) (
	*TagsModel,
	error,
) {
	var v *TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsFindFirst) ExecInner(ctx context.Context) (
	*InnerTags,
	error,
) {
	var v *InnerTags
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type tagsFindMany struct {
	query builder.Query
}

func (r tagsFindMany) getQuery() builder.Query {
	return r.query
}

func (r tagsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsFindMany) with()         {}
func (r tagsFindMany) tagsModel()    {}
func (r tagsFindMany) tagsRelation() {}

func (r tagsActions) FindMany(
	params ...TagsWhereParam,
) tagsFindMany {
	var v tagsFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Tags"
	v.query.Outputs = tagsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r tagsFindMany) With(params ...TagsRelationWith) tagsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsFindMany) Select(params ...tagsPrismaFields) tagsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsFindMany) Omit(params ...tagsPrismaFields) tagsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsFindMany) OrderBy(params ...TagsOrderByParam) tagsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagsFindMany) Skip(count int) tagsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagsFindMany) Take(count int) tagsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagsFindMany) Cursor(cursor TagsCursorParam) tagsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagsFindMany) Exec(ctx context.Context) (
	[]TagsModel,
	error,
) {
	var v []TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagsFindMany) ExecInner(ctx context.Context) (
	[]InnerTags,
	error,
) {
	var v []InnerTags
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagsFindMany) Update(params ...TagsSetParam) tagsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Tags"

	r.query.Outputs = countOutput

	var v tagsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagsUpdateMany struct {
	query builder.Query
}

func (r tagsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsUpdateMany) tagsModel() {}

func (r tagsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsUpdateMany) Tx() TagsManyTxResult {
	v := newTagsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagsFindMany) Delete() tagsDeleteMany {
	var v tagsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Tags"

	v.query.Outputs = countOutput

	return v
}

type tagsDeleteMany struct {
	query builder.Query
}

func (r tagsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p tagsDeleteMany) tagsModel() {}

func (r tagsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsDeleteMany) Tx() TagsManyTxResult {
	v := newTagsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsOnVideosToVideoFindUnique struct {
	query builder.Query
}

func (r tagsOnVideosToVideoFindUnique) getQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToVideoFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToVideoFindUnique) with()                 {}
func (r tagsOnVideosToVideoFindUnique) tagsOnVideosModel()    {}
func (r tagsOnVideosToVideoFindUnique) tagsOnVideosRelation() {}

func (r tagsOnVideosToVideoFindUnique) With(params ...VideosRelationWith) tagsOnVideosToVideoFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsOnVideosToVideoFindUnique) Select(params ...tagsOnVideosPrismaFields) tagsOnVideosToVideoFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosToVideoFindUnique) Omit(params ...tagsOnVideosPrismaFields) tagsOnVideosToVideoFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOnVideosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosToVideoFindUnique) Exec(ctx context.Context) (
	*TagsOnVideosModel,
	error,
) {
	var v *TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsOnVideosToVideoFindUnique) ExecInner(ctx context.Context) (
	*InnerTagsOnVideos,
	error,
) {
	var v *InnerTagsOnVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsOnVideosToVideoFindUnique) Update(params ...TagsOnVideosSetParam) tagsOnVideosToVideoUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "TagsOnVideos"

	var v tagsOnVideosToVideoUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagsOnVideosToVideoUpdateUnique struct {
	query builder.Query
}

func (r tagsOnVideosToVideoUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToVideoUpdateUnique) tagsOnVideosModel() {}

func (r tagsOnVideosToVideoUpdateUnique) Exec(ctx context.Context) (*TagsOnVideosModel, error) {
	var v TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosToVideoUpdateUnique) Tx() TagsOnVideosUniqueTxResult {
	v := newTagsOnVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagsOnVideosToVideoFindUnique) Delete() tagsOnVideosToVideoDeleteUnique {
	var v tagsOnVideosToVideoDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "TagsOnVideos"

	return v
}

type tagsOnVideosToVideoDeleteUnique struct {
	query builder.Query
}

func (r tagsOnVideosToVideoDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p tagsOnVideosToVideoDeleteUnique) tagsOnVideosModel() {}

func (r tagsOnVideosToVideoDeleteUnique) Exec(ctx context.Context) (*TagsOnVideosModel, error) {
	var v TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosToVideoDeleteUnique) Tx() TagsOnVideosUniqueTxResult {
	v := newTagsOnVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsOnVideosToVideoFindFirst struct {
	query builder.Query
}

func (r tagsOnVideosToVideoFindFirst) getQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToVideoFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToVideoFindFirst) with()                 {}
func (r tagsOnVideosToVideoFindFirst) tagsOnVideosModel()    {}
func (r tagsOnVideosToVideoFindFirst) tagsOnVideosRelation() {}

func (r tagsOnVideosToVideoFindFirst) With(params ...VideosRelationWith) tagsOnVideosToVideoFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsOnVideosToVideoFindFirst) Select(params ...tagsOnVideosPrismaFields) tagsOnVideosToVideoFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosToVideoFindFirst) Omit(params ...tagsOnVideosPrismaFields) tagsOnVideosToVideoFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOnVideosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosToVideoFindFirst) OrderBy(params ...VideosOrderByParam) tagsOnVideosToVideoFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagsOnVideosToVideoFindFirst) Skip(count int) tagsOnVideosToVideoFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagsOnVideosToVideoFindFirst) Take(count int) tagsOnVideosToVideoFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagsOnVideosToVideoFindFirst) Cursor(cursor TagsOnVideosCursorParam) tagsOnVideosToVideoFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagsOnVideosToVideoFindFirst) Exec(ctx context.Context) (
	*TagsOnVideosModel,
	error,
) {
	var v *TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsOnVideosToVideoFindFirst) ExecInner(ctx context.Context) (
	*InnerTagsOnVideos,
	error,
) {
	var v *InnerTagsOnVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type tagsOnVideosToVideoFindMany struct {
	query builder.Query
}

func (r tagsOnVideosToVideoFindMany) getQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToVideoFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToVideoFindMany) with()                 {}
func (r tagsOnVideosToVideoFindMany) tagsOnVideosModel()    {}
func (r tagsOnVideosToVideoFindMany) tagsOnVideosRelation() {}

func (r tagsOnVideosToVideoFindMany) With(params ...VideosRelationWith) tagsOnVideosToVideoFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsOnVideosToVideoFindMany) Select(params ...tagsOnVideosPrismaFields) tagsOnVideosToVideoFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosToVideoFindMany) Omit(params ...tagsOnVideosPrismaFields) tagsOnVideosToVideoFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOnVideosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosToVideoFindMany) OrderBy(params ...VideosOrderByParam) tagsOnVideosToVideoFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagsOnVideosToVideoFindMany) Skip(count int) tagsOnVideosToVideoFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagsOnVideosToVideoFindMany) Take(count int) tagsOnVideosToVideoFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagsOnVideosToVideoFindMany) Cursor(cursor TagsOnVideosCursorParam) tagsOnVideosToVideoFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagsOnVideosToVideoFindMany) Exec(ctx context.Context) (
	[]TagsOnVideosModel,
	error,
) {
	var v []TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagsOnVideosToVideoFindMany) ExecInner(ctx context.Context) (
	[]InnerTagsOnVideos,
	error,
) {
	var v []InnerTagsOnVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagsOnVideosToVideoFindMany) Update(params ...TagsOnVideosSetParam) tagsOnVideosToVideoUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "TagsOnVideos"

	r.query.Outputs = countOutput

	var v tagsOnVideosToVideoUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagsOnVideosToVideoUpdateMany struct {
	query builder.Query
}

func (r tagsOnVideosToVideoUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToVideoUpdateMany) tagsOnVideosModel() {}

func (r tagsOnVideosToVideoUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosToVideoUpdateMany) Tx() TagsOnVideosManyTxResult {
	v := newTagsOnVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagsOnVideosToVideoFindMany) Delete() tagsOnVideosToVideoDeleteMany {
	var v tagsOnVideosToVideoDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "TagsOnVideos"

	v.query.Outputs = countOutput

	return v
}

type tagsOnVideosToVideoDeleteMany struct {
	query builder.Query
}

func (r tagsOnVideosToVideoDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p tagsOnVideosToVideoDeleteMany) tagsOnVideosModel() {}

func (r tagsOnVideosToVideoDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosToVideoDeleteMany) Tx() TagsOnVideosManyTxResult {
	v := newTagsOnVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsOnVideosToTagFindUnique struct {
	query builder.Query
}

func (r tagsOnVideosToTagFindUnique) getQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToTagFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToTagFindUnique) with()                 {}
func (r tagsOnVideosToTagFindUnique) tagsOnVideosModel()    {}
func (r tagsOnVideosToTagFindUnique) tagsOnVideosRelation() {}

func (r tagsOnVideosToTagFindUnique) With(params ...TagsRelationWith) tagsOnVideosToTagFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsOnVideosToTagFindUnique) Select(params ...tagsOnVideosPrismaFields) tagsOnVideosToTagFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosToTagFindUnique) Omit(params ...tagsOnVideosPrismaFields) tagsOnVideosToTagFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOnVideosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosToTagFindUnique) Exec(ctx context.Context) (
	*TagsOnVideosModel,
	error,
) {
	var v *TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsOnVideosToTagFindUnique) ExecInner(ctx context.Context) (
	*InnerTagsOnVideos,
	error,
) {
	var v *InnerTagsOnVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsOnVideosToTagFindUnique) Update(params ...TagsOnVideosSetParam) tagsOnVideosToTagUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "TagsOnVideos"

	var v tagsOnVideosToTagUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagsOnVideosToTagUpdateUnique struct {
	query builder.Query
}

func (r tagsOnVideosToTagUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToTagUpdateUnique) tagsOnVideosModel() {}

func (r tagsOnVideosToTagUpdateUnique) Exec(ctx context.Context) (*TagsOnVideosModel, error) {
	var v TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosToTagUpdateUnique) Tx() TagsOnVideosUniqueTxResult {
	v := newTagsOnVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagsOnVideosToTagFindUnique) Delete() tagsOnVideosToTagDeleteUnique {
	var v tagsOnVideosToTagDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "TagsOnVideos"

	return v
}

type tagsOnVideosToTagDeleteUnique struct {
	query builder.Query
}

func (r tagsOnVideosToTagDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p tagsOnVideosToTagDeleteUnique) tagsOnVideosModel() {}

func (r tagsOnVideosToTagDeleteUnique) Exec(ctx context.Context) (*TagsOnVideosModel, error) {
	var v TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosToTagDeleteUnique) Tx() TagsOnVideosUniqueTxResult {
	v := newTagsOnVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsOnVideosToTagFindFirst struct {
	query builder.Query
}

func (r tagsOnVideosToTagFindFirst) getQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToTagFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToTagFindFirst) with()                 {}
func (r tagsOnVideosToTagFindFirst) tagsOnVideosModel()    {}
func (r tagsOnVideosToTagFindFirst) tagsOnVideosRelation() {}

func (r tagsOnVideosToTagFindFirst) With(params ...TagsRelationWith) tagsOnVideosToTagFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsOnVideosToTagFindFirst) Select(params ...tagsOnVideosPrismaFields) tagsOnVideosToTagFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosToTagFindFirst) Omit(params ...tagsOnVideosPrismaFields) tagsOnVideosToTagFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOnVideosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosToTagFindFirst) OrderBy(params ...TagsOrderByParam) tagsOnVideosToTagFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagsOnVideosToTagFindFirst) Skip(count int) tagsOnVideosToTagFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagsOnVideosToTagFindFirst) Take(count int) tagsOnVideosToTagFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagsOnVideosToTagFindFirst) Cursor(cursor TagsOnVideosCursorParam) tagsOnVideosToTagFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagsOnVideosToTagFindFirst) Exec(ctx context.Context) (
	*TagsOnVideosModel,
	error,
) {
	var v *TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsOnVideosToTagFindFirst) ExecInner(ctx context.Context) (
	*InnerTagsOnVideos,
	error,
) {
	var v *InnerTagsOnVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type tagsOnVideosToTagFindMany struct {
	query builder.Query
}

func (r tagsOnVideosToTagFindMany) getQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToTagFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToTagFindMany) with()                 {}
func (r tagsOnVideosToTagFindMany) tagsOnVideosModel()    {}
func (r tagsOnVideosToTagFindMany) tagsOnVideosRelation() {}

func (r tagsOnVideosToTagFindMany) With(params ...TagsRelationWith) tagsOnVideosToTagFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsOnVideosToTagFindMany) Select(params ...tagsOnVideosPrismaFields) tagsOnVideosToTagFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosToTagFindMany) Omit(params ...tagsOnVideosPrismaFields) tagsOnVideosToTagFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOnVideosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosToTagFindMany) OrderBy(params ...TagsOrderByParam) tagsOnVideosToTagFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagsOnVideosToTagFindMany) Skip(count int) tagsOnVideosToTagFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagsOnVideosToTagFindMany) Take(count int) tagsOnVideosToTagFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagsOnVideosToTagFindMany) Cursor(cursor TagsOnVideosCursorParam) tagsOnVideosToTagFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagsOnVideosToTagFindMany) Exec(ctx context.Context) (
	[]TagsOnVideosModel,
	error,
) {
	var v []TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagsOnVideosToTagFindMany) ExecInner(ctx context.Context) (
	[]InnerTagsOnVideos,
	error,
) {
	var v []InnerTagsOnVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagsOnVideosToTagFindMany) Update(params ...TagsOnVideosSetParam) tagsOnVideosToTagUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "TagsOnVideos"

	r.query.Outputs = countOutput

	var v tagsOnVideosToTagUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagsOnVideosToTagUpdateMany struct {
	query builder.Query
}

func (r tagsOnVideosToTagUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosToTagUpdateMany) tagsOnVideosModel() {}

func (r tagsOnVideosToTagUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosToTagUpdateMany) Tx() TagsOnVideosManyTxResult {
	v := newTagsOnVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagsOnVideosToTagFindMany) Delete() tagsOnVideosToTagDeleteMany {
	var v tagsOnVideosToTagDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "TagsOnVideos"

	v.query.Outputs = countOutput

	return v
}

type tagsOnVideosToTagDeleteMany struct {
	query builder.Query
}

func (r tagsOnVideosToTagDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p tagsOnVideosToTagDeleteMany) tagsOnVideosModel() {}

func (r tagsOnVideosToTagDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosToTagDeleteMany) Tx() TagsOnVideosManyTxResult {
	v := newTagsOnVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsOnVideosFindUnique struct {
	query builder.Query
}

func (r tagsOnVideosFindUnique) getQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosFindUnique) with()                 {}
func (r tagsOnVideosFindUnique) tagsOnVideosModel()    {}
func (r tagsOnVideosFindUnique) tagsOnVideosRelation() {}

func (r tagsOnVideosActions) FindUnique(
	params TagsOnVideosEqualsUniqueWhereParam,
) tagsOnVideosFindUnique {
	var v tagsOnVideosFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "TagsOnVideos"
	v.query.Outputs = tagsOnVideosOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r tagsOnVideosFindUnique) With(params ...TagsOnVideosRelationWith) tagsOnVideosFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsOnVideosFindUnique) Select(params ...tagsOnVideosPrismaFields) tagsOnVideosFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosFindUnique) Omit(params ...tagsOnVideosPrismaFields) tagsOnVideosFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOnVideosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosFindUnique) Exec(ctx context.Context) (
	*TagsOnVideosModel,
	error,
) {
	var v *TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsOnVideosFindUnique) ExecInner(ctx context.Context) (
	*InnerTagsOnVideos,
	error,
) {
	var v *InnerTagsOnVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsOnVideosFindUnique) Update(params ...TagsOnVideosSetParam) tagsOnVideosUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "TagsOnVideos"

	var v tagsOnVideosUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagsOnVideosUpdateUnique struct {
	query builder.Query
}

func (r tagsOnVideosUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosUpdateUnique) tagsOnVideosModel() {}

func (r tagsOnVideosUpdateUnique) Exec(ctx context.Context) (*TagsOnVideosModel, error) {
	var v TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosUpdateUnique) Tx() TagsOnVideosUniqueTxResult {
	v := newTagsOnVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagsOnVideosFindUnique) Delete() tagsOnVideosDeleteUnique {
	var v tagsOnVideosDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "TagsOnVideos"

	return v
}

type tagsOnVideosDeleteUnique struct {
	query builder.Query
}

func (r tagsOnVideosDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p tagsOnVideosDeleteUnique) tagsOnVideosModel() {}

func (r tagsOnVideosDeleteUnique) Exec(ctx context.Context) (*TagsOnVideosModel, error) {
	var v TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosDeleteUnique) Tx() TagsOnVideosUniqueTxResult {
	v := newTagsOnVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsOnVideosFindFirst struct {
	query builder.Query
}

func (r tagsOnVideosFindFirst) getQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosFindFirst) with()                 {}
func (r tagsOnVideosFindFirst) tagsOnVideosModel()    {}
func (r tagsOnVideosFindFirst) tagsOnVideosRelation() {}

func (r tagsOnVideosActions) FindFirst(
	params ...TagsOnVideosWhereParam,
) tagsOnVideosFindFirst {
	var v tagsOnVideosFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "TagsOnVideos"
	v.query.Outputs = tagsOnVideosOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r tagsOnVideosFindFirst) With(params ...TagsOnVideosRelationWith) tagsOnVideosFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsOnVideosFindFirst) Select(params ...tagsOnVideosPrismaFields) tagsOnVideosFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosFindFirst) Omit(params ...tagsOnVideosPrismaFields) tagsOnVideosFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOnVideosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosFindFirst) OrderBy(params ...TagsOnVideosOrderByParam) tagsOnVideosFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagsOnVideosFindFirst) Skip(count int) tagsOnVideosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagsOnVideosFindFirst) Take(count int) tagsOnVideosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagsOnVideosFindFirst) Cursor(cursor TagsOnVideosCursorParam) tagsOnVideosFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagsOnVideosFindFirst) Exec(ctx context.Context) (
	*TagsOnVideosModel,
	error,
) {
	var v *TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r tagsOnVideosFindFirst) ExecInner(ctx context.Context) (
	*InnerTagsOnVideos,
	error,
) {
	var v *InnerTagsOnVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type tagsOnVideosFindMany struct {
	query builder.Query
}

func (r tagsOnVideosFindMany) getQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosFindMany) with()                 {}
func (r tagsOnVideosFindMany) tagsOnVideosModel()    {}
func (r tagsOnVideosFindMany) tagsOnVideosRelation() {}

func (r tagsOnVideosActions) FindMany(
	params ...TagsOnVideosWhereParam,
) tagsOnVideosFindMany {
	var v tagsOnVideosFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "TagsOnVideos"
	v.query.Outputs = tagsOnVideosOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r tagsOnVideosFindMany) With(params ...TagsOnVideosRelationWith) tagsOnVideosFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r tagsOnVideosFindMany) Select(params ...tagsOnVideosPrismaFields) tagsOnVideosFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosFindMany) Omit(params ...tagsOnVideosPrismaFields) tagsOnVideosFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range tagsOnVideosOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r tagsOnVideosFindMany) OrderBy(params ...TagsOnVideosOrderByParam) tagsOnVideosFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r tagsOnVideosFindMany) Skip(count int) tagsOnVideosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r tagsOnVideosFindMany) Take(count int) tagsOnVideosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r tagsOnVideosFindMany) Cursor(cursor TagsOnVideosCursorParam) tagsOnVideosFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r tagsOnVideosFindMany) Exec(ctx context.Context) (
	[]TagsOnVideosModel,
	error,
) {
	var v []TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagsOnVideosFindMany) ExecInner(ctx context.Context) (
	[]InnerTagsOnVideos,
	error,
) {
	var v []InnerTagsOnVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r tagsOnVideosFindMany) Update(params ...TagsOnVideosSetParam) tagsOnVideosUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "TagsOnVideos"

	r.query.Outputs = countOutput

	var v tagsOnVideosUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type tagsOnVideosUpdateMany struct {
	query builder.Query
}

func (r tagsOnVideosUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosUpdateMany) tagsOnVideosModel() {}

func (r tagsOnVideosUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosUpdateMany) Tx() TagsOnVideosManyTxResult {
	v := newTagsOnVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r tagsOnVideosFindMany) Delete() tagsOnVideosDeleteMany {
	var v tagsOnVideosDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "TagsOnVideos"

	v.query.Outputs = countOutput

	return v
}

type tagsOnVideosDeleteMany struct {
	query builder.Query
}

func (r tagsOnVideosDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p tagsOnVideosDeleteMany) tagsOnVideosModel() {}

func (r tagsOnVideosDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosDeleteMany) Tx() TagsOnVideosManyTxResult {
	v := newTagsOnVideosManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentsToLikesFindUnique struct {
	query builder.Query
}

func (r commentsToLikesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r commentsToLikesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsToLikesFindUnique) with()             {}
func (r commentsToLikesFindUnique) commentsModel()    {}
func (r commentsToLikesFindUnique) commentsRelation() {}

func (r commentsToLikesFindUnique) With(params ...LikesRelationWith) commentsToLikesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentsToLikesFindUnique) Select(params ...commentsPrismaFields) commentsToLikesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsToLikesFindUnique) Omit(params ...commentsPrismaFields) commentsToLikesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsToLikesFindUnique) Exec(ctx context.Context) (
	*CommentsModel,
	error,
) {
	var v *CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentsToLikesFindUnique) ExecInner(ctx context.Context) (
	*InnerComments,
	error,
) {
	var v *InnerComments
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentsToLikesFindUnique) Update(params ...CommentsSetParam) commentsToLikesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Comments"

	var v commentsToLikesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentsToLikesUpdateUnique struct {
	query builder.Query
}

func (r commentsToLikesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsToLikesUpdateUnique) commentsModel() {}

func (r commentsToLikesUpdateUnique) Exec(ctx context.Context) (*CommentsModel, error) {
	var v CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsToLikesUpdateUnique) Tx() CommentsUniqueTxResult {
	v := newCommentsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentsToLikesFindUnique) Delete() commentsToLikesDeleteUnique {
	var v commentsToLikesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Comments"

	return v
}

type commentsToLikesDeleteUnique struct {
	query builder.Query
}

func (r commentsToLikesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p commentsToLikesDeleteUnique) commentsModel() {}

func (r commentsToLikesDeleteUnique) Exec(ctx context.Context) (*CommentsModel, error) {
	var v CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsToLikesDeleteUnique) Tx() CommentsUniqueTxResult {
	v := newCommentsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentsToLikesFindFirst struct {
	query builder.Query
}

func (r commentsToLikesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r commentsToLikesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsToLikesFindFirst) with()             {}
func (r commentsToLikesFindFirst) commentsModel()    {}
func (r commentsToLikesFindFirst) commentsRelation() {}

func (r commentsToLikesFindFirst) With(params ...LikesRelationWith) commentsToLikesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentsToLikesFindFirst) Select(params ...commentsPrismaFields) commentsToLikesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsToLikesFindFirst) Omit(params ...commentsPrismaFields) commentsToLikesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsToLikesFindFirst) OrderBy(params ...LikesOrderByParam) commentsToLikesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentsToLikesFindFirst) Skip(count int) commentsToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentsToLikesFindFirst) Take(count int) commentsToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentsToLikesFindFirst) Cursor(cursor CommentsCursorParam) commentsToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentsToLikesFindFirst) Exec(ctx context.Context) (
	*CommentsModel,
	error,
) {
	var v *CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentsToLikesFindFirst) ExecInner(ctx context.Context) (
	*InnerComments,
	error,
) {
	var v *InnerComments
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type commentsToLikesFindMany struct {
	query builder.Query
}

func (r commentsToLikesFindMany) getQuery() builder.Query {
	return r.query
}

func (r commentsToLikesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsToLikesFindMany) with()             {}
func (r commentsToLikesFindMany) commentsModel()    {}
func (r commentsToLikesFindMany) commentsRelation() {}

func (r commentsToLikesFindMany) With(params ...LikesRelationWith) commentsToLikesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentsToLikesFindMany) Select(params ...commentsPrismaFields) commentsToLikesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsToLikesFindMany) Omit(params ...commentsPrismaFields) commentsToLikesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsToLikesFindMany) OrderBy(params ...LikesOrderByParam) commentsToLikesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentsToLikesFindMany) Skip(count int) commentsToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentsToLikesFindMany) Take(count int) commentsToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentsToLikesFindMany) Cursor(cursor CommentsCursorParam) commentsToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentsToLikesFindMany) Exec(ctx context.Context) (
	[]CommentsModel,
	error,
) {
	var v []CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentsToLikesFindMany) ExecInner(ctx context.Context) (
	[]InnerComments,
	error,
) {
	var v []InnerComments
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentsToLikesFindMany) Update(params ...CommentsSetParam) commentsToLikesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Comments"

	r.query.Outputs = countOutput

	var v commentsToLikesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentsToLikesUpdateMany struct {
	query builder.Query
}

func (r commentsToLikesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsToLikesUpdateMany) commentsModel() {}

func (r commentsToLikesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsToLikesUpdateMany) Tx() CommentsManyTxResult {
	v := newCommentsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentsToLikesFindMany) Delete() commentsToLikesDeleteMany {
	var v commentsToLikesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Comments"

	v.query.Outputs = countOutput

	return v
}

type commentsToLikesDeleteMany struct {
	query builder.Query
}

func (r commentsToLikesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p commentsToLikesDeleteMany) commentsModel() {}

func (r commentsToLikesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsToLikesDeleteMany) Tx() CommentsManyTxResult {
	v := newCommentsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentsToOwnerFindUnique struct {
	query builder.Query
}

func (r commentsToOwnerFindUnique) getQuery() builder.Query {
	return r.query
}

func (r commentsToOwnerFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsToOwnerFindUnique) with()             {}
func (r commentsToOwnerFindUnique) commentsModel()    {}
func (r commentsToOwnerFindUnique) commentsRelation() {}

func (r commentsToOwnerFindUnique) With(params ...UserRelationWith) commentsToOwnerFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentsToOwnerFindUnique) Select(params ...commentsPrismaFields) commentsToOwnerFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsToOwnerFindUnique) Omit(params ...commentsPrismaFields) commentsToOwnerFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsToOwnerFindUnique) Exec(ctx context.Context) (
	*CommentsModel,
	error,
) {
	var v *CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentsToOwnerFindUnique) ExecInner(ctx context.Context) (
	*InnerComments,
	error,
) {
	var v *InnerComments
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentsToOwnerFindUnique) Update(params ...CommentsSetParam) commentsToOwnerUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Comments"

	var v commentsToOwnerUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentsToOwnerUpdateUnique struct {
	query builder.Query
}

func (r commentsToOwnerUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsToOwnerUpdateUnique) commentsModel() {}

func (r commentsToOwnerUpdateUnique) Exec(ctx context.Context) (*CommentsModel, error) {
	var v CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsToOwnerUpdateUnique) Tx() CommentsUniqueTxResult {
	v := newCommentsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentsToOwnerFindUnique) Delete() commentsToOwnerDeleteUnique {
	var v commentsToOwnerDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Comments"

	return v
}

type commentsToOwnerDeleteUnique struct {
	query builder.Query
}

func (r commentsToOwnerDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p commentsToOwnerDeleteUnique) commentsModel() {}

func (r commentsToOwnerDeleteUnique) Exec(ctx context.Context) (*CommentsModel, error) {
	var v CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsToOwnerDeleteUnique) Tx() CommentsUniqueTxResult {
	v := newCommentsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentsToOwnerFindFirst struct {
	query builder.Query
}

func (r commentsToOwnerFindFirst) getQuery() builder.Query {
	return r.query
}

func (r commentsToOwnerFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsToOwnerFindFirst) with()             {}
func (r commentsToOwnerFindFirst) commentsModel()    {}
func (r commentsToOwnerFindFirst) commentsRelation() {}

func (r commentsToOwnerFindFirst) With(params ...UserRelationWith) commentsToOwnerFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentsToOwnerFindFirst) Select(params ...commentsPrismaFields) commentsToOwnerFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsToOwnerFindFirst) Omit(params ...commentsPrismaFields) commentsToOwnerFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsToOwnerFindFirst) OrderBy(params ...UserOrderByParam) commentsToOwnerFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentsToOwnerFindFirst) Skip(count int) commentsToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentsToOwnerFindFirst) Take(count int) commentsToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentsToOwnerFindFirst) Cursor(cursor CommentsCursorParam) commentsToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentsToOwnerFindFirst) Exec(ctx context.Context) (
	*CommentsModel,
	error,
) {
	var v *CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentsToOwnerFindFirst) ExecInner(ctx context.Context) (
	*InnerComments,
	error,
) {
	var v *InnerComments
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type commentsToOwnerFindMany struct {
	query builder.Query
}

func (r commentsToOwnerFindMany) getQuery() builder.Query {
	return r.query
}

func (r commentsToOwnerFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsToOwnerFindMany) with()             {}
func (r commentsToOwnerFindMany) commentsModel()    {}
func (r commentsToOwnerFindMany) commentsRelation() {}

func (r commentsToOwnerFindMany) With(params ...UserRelationWith) commentsToOwnerFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentsToOwnerFindMany) Select(params ...commentsPrismaFields) commentsToOwnerFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsToOwnerFindMany) Omit(params ...commentsPrismaFields) commentsToOwnerFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsToOwnerFindMany) OrderBy(params ...UserOrderByParam) commentsToOwnerFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentsToOwnerFindMany) Skip(count int) commentsToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentsToOwnerFindMany) Take(count int) commentsToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentsToOwnerFindMany) Cursor(cursor CommentsCursorParam) commentsToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentsToOwnerFindMany) Exec(ctx context.Context) (
	[]CommentsModel,
	error,
) {
	var v []CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentsToOwnerFindMany) ExecInner(ctx context.Context) (
	[]InnerComments,
	error,
) {
	var v []InnerComments
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentsToOwnerFindMany) Update(params ...CommentsSetParam) commentsToOwnerUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Comments"

	r.query.Outputs = countOutput

	var v commentsToOwnerUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentsToOwnerUpdateMany struct {
	query builder.Query
}

func (r commentsToOwnerUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsToOwnerUpdateMany) commentsModel() {}

func (r commentsToOwnerUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsToOwnerUpdateMany) Tx() CommentsManyTxResult {
	v := newCommentsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentsToOwnerFindMany) Delete() commentsToOwnerDeleteMany {
	var v commentsToOwnerDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Comments"

	v.query.Outputs = countOutput

	return v
}

type commentsToOwnerDeleteMany struct {
	query builder.Query
}

func (r commentsToOwnerDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p commentsToOwnerDeleteMany) commentsModel() {}

func (r commentsToOwnerDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsToOwnerDeleteMany) Tx() CommentsManyTxResult {
	v := newCommentsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentsFindUnique struct {
	query builder.Query
}

func (r commentsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r commentsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsFindUnique) with()             {}
func (r commentsFindUnique) commentsModel()    {}
func (r commentsFindUnique) commentsRelation() {}

func (r commentsActions) FindUnique(
	params CommentsEqualsUniqueWhereParam,
) commentsFindUnique {
	var v commentsFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Comments"
	v.query.Outputs = commentsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r commentsFindUnique) With(params ...CommentsRelationWith) commentsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentsFindUnique) Select(params ...commentsPrismaFields) commentsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsFindUnique) Omit(params ...commentsPrismaFields) commentsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsFindUnique) Exec(ctx context.Context) (
	*CommentsModel,
	error,
) {
	var v *CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentsFindUnique) ExecInner(ctx context.Context) (
	*InnerComments,
	error,
) {
	var v *InnerComments
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentsFindUnique) Update(params ...CommentsSetParam) commentsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Comments"

	var v commentsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentsUpdateUnique struct {
	query builder.Query
}

func (r commentsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsUpdateUnique) commentsModel() {}

func (r commentsUpdateUnique) Exec(ctx context.Context) (*CommentsModel, error) {
	var v CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsUpdateUnique) Tx() CommentsUniqueTxResult {
	v := newCommentsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentsFindUnique) Delete() commentsDeleteUnique {
	var v commentsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Comments"

	return v
}

type commentsDeleteUnique struct {
	query builder.Query
}

func (r commentsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p commentsDeleteUnique) commentsModel() {}

func (r commentsDeleteUnique) Exec(ctx context.Context) (*CommentsModel, error) {
	var v CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsDeleteUnique) Tx() CommentsUniqueTxResult {
	v := newCommentsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentsFindFirst struct {
	query builder.Query
}

func (r commentsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r commentsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsFindFirst) with()             {}
func (r commentsFindFirst) commentsModel()    {}
func (r commentsFindFirst) commentsRelation() {}

func (r commentsActions) FindFirst(
	params ...CommentsWhereParam,
) commentsFindFirst {
	var v commentsFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Comments"
	v.query.Outputs = commentsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r commentsFindFirst) With(params ...CommentsRelationWith) commentsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentsFindFirst) Select(params ...commentsPrismaFields) commentsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsFindFirst) Omit(params ...commentsPrismaFields) commentsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsFindFirst) OrderBy(params ...CommentsOrderByParam) commentsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentsFindFirst) Skip(count int) commentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentsFindFirst) Take(count int) commentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentsFindFirst) Cursor(cursor CommentsCursorParam) commentsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentsFindFirst) Exec(ctx context.Context) (
	*CommentsModel,
	error,
) {
	var v *CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r commentsFindFirst) ExecInner(ctx context.Context) (
	*InnerComments,
	error,
) {
	var v *InnerComments
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type commentsFindMany struct {
	query builder.Query
}

func (r commentsFindMany) getQuery() builder.Query {
	return r.query
}

func (r commentsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsFindMany) with()             {}
func (r commentsFindMany) commentsModel()    {}
func (r commentsFindMany) commentsRelation() {}

func (r commentsActions) FindMany(
	params ...CommentsWhereParam,
) commentsFindMany {
	var v commentsFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Comments"
	v.query.Outputs = commentsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r commentsFindMany) With(params ...CommentsRelationWith) commentsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r commentsFindMany) Select(params ...commentsPrismaFields) commentsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsFindMany) Omit(params ...commentsPrismaFields) commentsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range commentsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r commentsFindMany) OrderBy(params ...CommentsOrderByParam) commentsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r commentsFindMany) Skip(count int) commentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r commentsFindMany) Take(count int) commentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r commentsFindMany) Cursor(cursor CommentsCursorParam) commentsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r commentsFindMany) Exec(ctx context.Context) (
	[]CommentsModel,
	error,
) {
	var v []CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentsFindMany) ExecInner(ctx context.Context) (
	[]InnerComments,
	error,
) {
	var v []InnerComments
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r commentsFindMany) Update(params ...CommentsSetParam) commentsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Comments"

	r.query.Outputs = countOutput

	var v commentsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type commentsUpdateMany struct {
	query builder.Query
}

func (r commentsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsUpdateMany) commentsModel() {}

func (r commentsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsUpdateMany) Tx() CommentsManyTxResult {
	v := newCommentsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r commentsFindMany) Delete() commentsDeleteMany {
	var v commentsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Comments"

	v.query.Outputs = countOutput

	return v
}

type commentsDeleteMany struct {
	query builder.Query
}

func (r commentsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p commentsDeleteMany) commentsModel() {}

func (r commentsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsDeleteMany) Tx() CommentsManyTxResult {
	v := newCommentsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type repliesToLikesFindUnique struct {
	query builder.Query
}

func (r repliesToLikesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r repliesToLikesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesToLikesFindUnique) with()            {}
func (r repliesToLikesFindUnique) repliesModel()    {}
func (r repliesToLikesFindUnique) repliesRelation() {}

func (r repliesToLikesFindUnique) With(params ...LikesRelationWith) repliesToLikesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r repliesToLikesFindUnique) Select(params ...repliesPrismaFields) repliesToLikesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesToLikesFindUnique) Omit(params ...repliesPrismaFields) repliesToLikesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range repliesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesToLikesFindUnique) Exec(ctx context.Context) (
	*RepliesModel,
	error,
) {
	var v *RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r repliesToLikesFindUnique) ExecInner(ctx context.Context) (
	*InnerReplies,
	error,
) {
	var v *InnerReplies
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r repliesToLikesFindUnique) Update(params ...RepliesSetParam) repliesToLikesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Replies"

	var v repliesToLikesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type repliesToLikesUpdateUnique struct {
	query builder.Query
}

func (r repliesToLikesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesToLikesUpdateUnique) repliesModel() {}

func (r repliesToLikesUpdateUnique) Exec(ctx context.Context) (*RepliesModel, error) {
	var v RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesToLikesUpdateUnique) Tx() RepliesUniqueTxResult {
	v := newRepliesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r repliesToLikesFindUnique) Delete() repliesToLikesDeleteUnique {
	var v repliesToLikesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Replies"

	return v
}

type repliesToLikesDeleteUnique struct {
	query builder.Query
}

func (r repliesToLikesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p repliesToLikesDeleteUnique) repliesModel() {}

func (r repliesToLikesDeleteUnique) Exec(ctx context.Context) (*RepliesModel, error) {
	var v RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesToLikesDeleteUnique) Tx() RepliesUniqueTxResult {
	v := newRepliesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type repliesToLikesFindFirst struct {
	query builder.Query
}

func (r repliesToLikesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r repliesToLikesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesToLikesFindFirst) with()            {}
func (r repliesToLikesFindFirst) repliesModel()    {}
func (r repliesToLikesFindFirst) repliesRelation() {}

func (r repliesToLikesFindFirst) With(params ...LikesRelationWith) repliesToLikesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r repliesToLikesFindFirst) Select(params ...repliesPrismaFields) repliesToLikesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesToLikesFindFirst) Omit(params ...repliesPrismaFields) repliesToLikesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range repliesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesToLikesFindFirst) OrderBy(params ...LikesOrderByParam) repliesToLikesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r repliesToLikesFindFirst) Skip(count int) repliesToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r repliesToLikesFindFirst) Take(count int) repliesToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r repliesToLikesFindFirst) Cursor(cursor RepliesCursorParam) repliesToLikesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r repliesToLikesFindFirst) Exec(ctx context.Context) (
	*RepliesModel,
	error,
) {
	var v *RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r repliesToLikesFindFirst) ExecInner(ctx context.Context) (
	*InnerReplies,
	error,
) {
	var v *InnerReplies
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type repliesToLikesFindMany struct {
	query builder.Query
}

func (r repliesToLikesFindMany) getQuery() builder.Query {
	return r.query
}

func (r repliesToLikesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesToLikesFindMany) with()            {}
func (r repliesToLikesFindMany) repliesModel()    {}
func (r repliesToLikesFindMany) repliesRelation() {}

func (r repliesToLikesFindMany) With(params ...LikesRelationWith) repliesToLikesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r repliesToLikesFindMany) Select(params ...repliesPrismaFields) repliesToLikesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesToLikesFindMany) Omit(params ...repliesPrismaFields) repliesToLikesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range repliesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesToLikesFindMany) OrderBy(params ...LikesOrderByParam) repliesToLikesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r repliesToLikesFindMany) Skip(count int) repliesToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r repliesToLikesFindMany) Take(count int) repliesToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r repliesToLikesFindMany) Cursor(cursor RepliesCursorParam) repliesToLikesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r repliesToLikesFindMany) Exec(ctx context.Context) (
	[]RepliesModel,
	error,
) {
	var v []RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r repliesToLikesFindMany) ExecInner(ctx context.Context) (
	[]InnerReplies,
	error,
) {
	var v []InnerReplies
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r repliesToLikesFindMany) Update(params ...RepliesSetParam) repliesToLikesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Replies"

	r.query.Outputs = countOutput

	var v repliesToLikesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type repliesToLikesUpdateMany struct {
	query builder.Query
}

func (r repliesToLikesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesToLikesUpdateMany) repliesModel() {}

func (r repliesToLikesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesToLikesUpdateMany) Tx() RepliesManyTxResult {
	v := newRepliesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r repliesToLikesFindMany) Delete() repliesToLikesDeleteMany {
	var v repliesToLikesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Replies"

	v.query.Outputs = countOutput

	return v
}

type repliesToLikesDeleteMany struct {
	query builder.Query
}

func (r repliesToLikesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p repliesToLikesDeleteMany) repliesModel() {}

func (r repliesToLikesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesToLikesDeleteMany) Tx() RepliesManyTxResult {
	v := newRepliesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type repliesToOwnerFindUnique struct {
	query builder.Query
}

func (r repliesToOwnerFindUnique) getQuery() builder.Query {
	return r.query
}

func (r repliesToOwnerFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesToOwnerFindUnique) with()            {}
func (r repliesToOwnerFindUnique) repliesModel()    {}
func (r repliesToOwnerFindUnique) repliesRelation() {}

func (r repliesToOwnerFindUnique) With(params ...UserRelationWith) repliesToOwnerFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r repliesToOwnerFindUnique) Select(params ...repliesPrismaFields) repliesToOwnerFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesToOwnerFindUnique) Omit(params ...repliesPrismaFields) repliesToOwnerFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range repliesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesToOwnerFindUnique) Exec(ctx context.Context) (
	*RepliesModel,
	error,
) {
	var v *RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r repliesToOwnerFindUnique) ExecInner(ctx context.Context) (
	*InnerReplies,
	error,
) {
	var v *InnerReplies
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r repliesToOwnerFindUnique) Update(params ...RepliesSetParam) repliesToOwnerUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Replies"

	var v repliesToOwnerUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type repliesToOwnerUpdateUnique struct {
	query builder.Query
}

func (r repliesToOwnerUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesToOwnerUpdateUnique) repliesModel() {}

func (r repliesToOwnerUpdateUnique) Exec(ctx context.Context) (*RepliesModel, error) {
	var v RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesToOwnerUpdateUnique) Tx() RepliesUniqueTxResult {
	v := newRepliesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r repliesToOwnerFindUnique) Delete() repliesToOwnerDeleteUnique {
	var v repliesToOwnerDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Replies"

	return v
}

type repliesToOwnerDeleteUnique struct {
	query builder.Query
}

func (r repliesToOwnerDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p repliesToOwnerDeleteUnique) repliesModel() {}

func (r repliesToOwnerDeleteUnique) Exec(ctx context.Context) (*RepliesModel, error) {
	var v RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesToOwnerDeleteUnique) Tx() RepliesUniqueTxResult {
	v := newRepliesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type repliesToOwnerFindFirst struct {
	query builder.Query
}

func (r repliesToOwnerFindFirst) getQuery() builder.Query {
	return r.query
}

func (r repliesToOwnerFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesToOwnerFindFirst) with()            {}
func (r repliesToOwnerFindFirst) repliesModel()    {}
func (r repliesToOwnerFindFirst) repliesRelation() {}

func (r repliesToOwnerFindFirst) With(params ...UserRelationWith) repliesToOwnerFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r repliesToOwnerFindFirst) Select(params ...repliesPrismaFields) repliesToOwnerFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesToOwnerFindFirst) Omit(params ...repliesPrismaFields) repliesToOwnerFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range repliesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesToOwnerFindFirst) OrderBy(params ...UserOrderByParam) repliesToOwnerFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r repliesToOwnerFindFirst) Skip(count int) repliesToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r repliesToOwnerFindFirst) Take(count int) repliesToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r repliesToOwnerFindFirst) Cursor(cursor RepliesCursorParam) repliesToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r repliesToOwnerFindFirst) Exec(ctx context.Context) (
	*RepliesModel,
	error,
) {
	var v *RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r repliesToOwnerFindFirst) ExecInner(ctx context.Context) (
	*InnerReplies,
	error,
) {
	var v *InnerReplies
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type repliesToOwnerFindMany struct {
	query builder.Query
}

func (r repliesToOwnerFindMany) getQuery() builder.Query {
	return r.query
}

func (r repliesToOwnerFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesToOwnerFindMany) with()            {}
func (r repliesToOwnerFindMany) repliesModel()    {}
func (r repliesToOwnerFindMany) repliesRelation() {}

func (r repliesToOwnerFindMany) With(params ...UserRelationWith) repliesToOwnerFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r repliesToOwnerFindMany) Select(params ...repliesPrismaFields) repliesToOwnerFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesToOwnerFindMany) Omit(params ...repliesPrismaFields) repliesToOwnerFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range repliesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesToOwnerFindMany) OrderBy(params ...UserOrderByParam) repliesToOwnerFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r repliesToOwnerFindMany) Skip(count int) repliesToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r repliesToOwnerFindMany) Take(count int) repliesToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r repliesToOwnerFindMany) Cursor(cursor RepliesCursorParam) repliesToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r repliesToOwnerFindMany) Exec(ctx context.Context) (
	[]RepliesModel,
	error,
) {
	var v []RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r repliesToOwnerFindMany) ExecInner(ctx context.Context) (
	[]InnerReplies,
	error,
) {
	var v []InnerReplies
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r repliesToOwnerFindMany) Update(params ...RepliesSetParam) repliesToOwnerUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Replies"

	r.query.Outputs = countOutput

	var v repliesToOwnerUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type repliesToOwnerUpdateMany struct {
	query builder.Query
}

func (r repliesToOwnerUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesToOwnerUpdateMany) repliesModel() {}

func (r repliesToOwnerUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesToOwnerUpdateMany) Tx() RepliesManyTxResult {
	v := newRepliesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r repliesToOwnerFindMany) Delete() repliesToOwnerDeleteMany {
	var v repliesToOwnerDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Replies"

	v.query.Outputs = countOutput

	return v
}

type repliesToOwnerDeleteMany struct {
	query builder.Query
}

func (r repliesToOwnerDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p repliesToOwnerDeleteMany) repliesModel() {}

func (r repliesToOwnerDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesToOwnerDeleteMany) Tx() RepliesManyTxResult {
	v := newRepliesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type repliesFindUnique struct {
	query builder.Query
}

func (r repliesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r repliesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesFindUnique) with()            {}
func (r repliesFindUnique) repliesModel()    {}
func (r repliesFindUnique) repliesRelation() {}

func (r repliesActions) FindUnique(
	params RepliesEqualsUniqueWhereParam,
) repliesFindUnique {
	var v repliesFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Replies"
	v.query.Outputs = repliesOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r repliesFindUnique) With(params ...RepliesRelationWith) repliesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r repliesFindUnique) Select(params ...repliesPrismaFields) repliesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesFindUnique) Omit(params ...repliesPrismaFields) repliesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range repliesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesFindUnique) Exec(ctx context.Context) (
	*RepliesModel,
	error,
) {
	var v *RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r repliesFindUnique) ExecInner(ctx context.Context) (
	*InnerReplies,
	error,
) {
	var v *InnerReplies
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r repliesFindUnique) Update(params ...RepliesSetParam) repliesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Replies"

	var v repliesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type repliesUpdateUnique struct {
	query builder.Query
}

func (r repliesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesUpdateUnique) repliesModel() {}

func (r repliesUpdateUnique) Exec(ctx context.Context) (*RepliesModel, error) {
	var v RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesUpdateUnique) Tx() RepliesUniqueTxResult {
	v := newRepliesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r repliesFindUnique) Delete() repliesDeleteUnique {
	var v repliesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Replies"

	return v
}

type repliesDeleteUnique struct {
	query builder.Query
}

func (r repliesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p repliesDeleteUnique) repliesModel() {}

func (r repliesDeleteUnique) Exec(ctx context.Context) (*RepliesModel, error) {
	var v RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesDeleteUnique) Tx() RepliesUniqueTxResult {
	v := newRepliesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type repliesFindFirst struct {
	query builder.Query
}

func (r repliesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r repliesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesFindFirst) with()            {}
func (r repliesFindFirst) repliesModel()    {}
func (r repliesFindFirst) repliesRelation() {}

func (r repliesActions) FindFirst(
	params ...RepliesWhereParam,
) repliesFindFirst {
	var v repliesFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Replies"
	v.query.Outputs = repliesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r repliesFindFirst) With(params ...RepliesRelationWith) repliesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r repliesFindFirst) Select(params ...repliesPrismaFields) repliesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesFindFirst) Omit(params ...repliesPrismaFields) repliesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range repliesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesFindFirst) OrderBy(params ...RepliesOrderByParam) repliesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r repliesFindFirst) Skip(count int) repliesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r repliesFindFirst) Take(count int) repliesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r repliesFindFirst) Cursor(cursor RepliesCursorParam) repliesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r repliesFindFirst) Exec(ctx context.Context) (
	*RepliesModel,
	error,
) {
	var v *RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r repliesFindFirst) ExecInner(ctx context.Context) (
	*InnerReplies,
	error,
) {
	var v *InnerReplies
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type repliesFindMany struct {
	query builder.Query
}

func (r repliesFindMany) getQuery() builder.Query {
	return r.query
}

func (r repliesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesFindMany) with()            {}
func (r repliesFindMany) repliesModel()    {}
func (r repliesFindMany) repliesRelation() {}

func (r repliesActions) FindMany(
	params ...RepliesWhereParam,
) repliesFindMany {
	var v repliesFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Replies"
	v.query.Outputs = repliesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r repliesFindMany) With(params ...RepliesRelationWith) repliesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r repliesFindMany) Select(params ...repliesPrismaFields) repliesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesFindMany) Omit(params ...repliesPrismaFields) repliesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range repliesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r repliesFindMany) OrderBy(params ...RepliesOrderByParam) repliesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r repliesFindMany) Skip(count int) repliesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r repliesFindMany) Take(count int) repliesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r repliesFindMany) Cursor(cursor RepliesCursorParam) repliesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r repliesFindMany) Exec(ctx context.Context) (
	[]RepliesModel,
	error,
) {
	var v []RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r repliesFindMany) ExecInner(ctx context.Context) (
	[]InnerReplies,
	error,
) {
	var v []InnerReplies
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r repliesFindMany) Update(params ...RepliesSetParam) repliesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Replies"

	r.query.Outputs = countOutput

	var v repliesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type repliesUpdateMany struct {
	query builder.Query
}

func (r repliesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesUpdateMany) repliesModel() {}

func (r repliesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesUpdateMany) Tx() RepliesManyTxResult {
	v := newRepliesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r repliesFindMany) Delete() repliesDeleteMany {
	var v repliesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Replies"

	v.query.Outputs = countOutput

	return v
}

type repliesDeleteMany struct {
	query builder.Query
}

func (r repliesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p repliesDeleteMany) repliesModel() {}

func (r repliesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesDeleteMany) Tx() RepliesManyTxResult {
	v := newRepliesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likesToOwnerFindUnique struct {
	query builder.Query
}

func (r likesToOwnerFindUnique) getQuery() builder.Query {
	return r.query
}

func (r likesToOwnerFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToOwnerFindUnique) with()          {}
func (r likesToOwnerFindUnique) likesModel()    {}
func (r likesToOwnerFindUnique) likesRelation() {}

func (r likesToOwnerFindUnique) With(params ...UserRelationWith) likesToOwnerFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesToOwnerFindUnique) Select(params ...likesPrismaFields) likesToOwnerFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToOwnerFindUnique) Omit(params ...likesPrismaFields) likesToOwnerFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToOwnerFindUnique) Exec(ctx context.Context) (
	*LikesModel,
	error,
) {
	var v *LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesToOwnerFindUnique) ExecInner(ctx context.Context) (
	*InnerLikes,
	error,
) {
	var v *InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesToOwnerFindUnique) Update(params ...LikesSetParam) likesToOwnerUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Likes"

	var v likesToOwnerUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likesToOwnerUpdateUnique struct {
	query builder.Query
}

func (r likesToOwnerUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToOwnerUpdateUnique) likesModel() {}

func (r likesToOwnerUpdateUnique) Exec(ctx context.Context) (*LikesModel, error) {
	var v LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToOwnerUpdateUnique) Tx() LikesUniqueTxResult {
	v := newLikesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likesToOwnerFindUnique) Delete() likesToOwnerDeleteUnique {
	var v likesToOwnerDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Likes"

	return v
}

type likesToOwnerDeleteUnique struct {
	query builder.Query
}

func (r likesToOwnerDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p likesToOwnerDeleteUnique) likesModel() {}

func (r likesToOwnerDeleteUnique) Exec(ctx context.Context) (*LikesModel, error) {
	var v LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToOwnerDeleteUnique) Tx() LikesUniqueTxResult {
	v := newLikesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likesToOwnerFindFirst struct {
	query builder.Query
}

func (r likesToOwnerFindFirst) getQuery() builder.Query {
	return r.query
}

func (r likesToOwnerFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToOwnerFindFirst) with()          {}
func (r likesToOwnerFindFirst) likesModel()    {}
func (r likesToOwnerFindFirst) likesRelation() {}

func (r likesToOwnerFindFirst) With(params ...UserRelationWith) likesToOwnerFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesToOwnerFindFirst) Select(params ...likesPrismaFields) likesToOwnerFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToOwnerFindFirst) Omit(params ...likesPrismaFields) likesToOwnerFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToOwnerFindFirst) OrderBy(params ...UserOrderByParam) likesToOwnerFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likesToOwnerFindFirst) Skip(count int) likesToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likesToOwnerFindFirst) Take(count int) likesToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likesToOwnerFindFirst) Cursor(cursor LikesCursorParam) likesToOwnerFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likesToOwnerFindFirst) Exec(ctx context.Context) (
	*LikesModel,
	error,
) {
	var v *LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesToOwnerFindFirst) ExecInner(ctx context.Context) (
	*InnerLikes,
	error,
) {
	var v *InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type likesToOwnerFindMany struct {
	query builder.Query
}

func (r likesToOwnerFindMany) getQuery() builder.Query {
	return r.query
}

func (r likesToOwnerFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToOwnerFindMany) with()          {}
func (r likesToOwnerFindMany) likesModel()    {}
func (r likesToOwnerFindMany) likesRelation() {}

func (r likesToOwnerFindMany) With(params ...UserRelationWith) likesToOwnerFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesToOwnerFindMany) Select(params ...likesPrismaFields) likesToOwnerFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToOwnerFindMany) Omit(params ...likesPrismaFields) likesToOwnerFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToOwnerFindMany) OrderBy(params ...UserOrderByParam) likesToOwnerFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likesToOwnerFindMany) Skip(count int) likesToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likesToOwnerFindMany) Take(count int) likesToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likesToOwnerFindMany) Cursor(cursor LikesCursorParam) likesToOwnerFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likesToOwnerFindMany) Exec(ctx context.Context) (
	[]LikesModel,
	error,
) {
	var v []LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likesToOwnerFindMany) ExecInner(ctx context.Context) (
	[]InnerLikes,
	error,
) {
	var v []InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likesToOwnerFindMany) Update(params ...LikesSetParam) likesToOwnerUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Likes"

	r.query.Outputs = countOutput

	var v likesToOwnerUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likesToOwnerUpdateMany struct {
	query builder.Query
}

func (r likesToOwnerUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToOwnerUpdateMany) likesModel() {}

func (r likesToOwnerUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToOwnerUpdateMany) Tx() LikesManyTxResult {
	v := newLikesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likesToOwnerFindMany) Delete() likesToOwnerDeleteMany {
	var v likesToOwnerDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Likes"

	v.query.Outputs = countOutput

	return v
}

type likesToOwnerDeleteMany struct {
	query builder.Query
}

func (r likesToOwnerDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p likesToOwnerDeleteMany) likesModel() {}

func (r likesToOwnerDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToOwnerDeleteMany) Tx() LikesManyTxResult {
	v := newLikesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likesToVideoFindUnique struct {
	query builder.Query
}

func (r likesToVideoFindUnique) getQuery() builder.Query {
	return r.query
}

func (r likesToVideoFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToVideoFindUnique) with()          {}
func (r likesToVideoFindUnique) likesModel()    {}
func (r likesToVideoFindUnique) likesRelation() {}

func (r likesToVideoFindUnique) With(params ...VideosRelationWith) likesToVideoFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesToVideoFindUnique) Select(params ...likesPrismaFields) likesToVideoFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToVideoFindUnique) Omit(params ...likesPrismaFields) likesToVideoFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToVideoFindUnique) Exec(ctx context.Context) (
	*LikesModel,
	error,
) {
	var v *LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesToVideoFindUnique) ExecInner(ctx context.Context) (
	*InnerLikes,
	error,
) {
	var v *InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesToVideoFindUnique) Update(params ...LikesSetParam) likesToVideoUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Likes"

	var v likesToVideoUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likesToVideoUpdateUnique struct {
	query builder.Query
}

func (r likesToVideoUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToVideoUpdateUnique) likesModel() {}

func (r likesToVideoUpdateUnique) Exec(ctx context.Context) (*LikesModel, error) {
	var v LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToVideoUpdateUnique) Tx() LikesUniqueTxResult {
	v := newLikesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likesToVideoFindUnique) Delete() likesToVideoDeleteUnique {
	var v likesToVideoDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Likes"

	return v
}

type likesToVideoDeleteUnique struct {
	query builder.Query
}

func (r likesToVideoDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p likesToVideoDeleteUnique) likesModel() {}

func (r likesToVideoDeleteUnique) Exec(ctx context.Context) (*LikesModel, error) {
	var v LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToVideoDeleteUnique) Tx() LikesUniqueTxResult {
	v := newLikesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likesToVideoFindFirst struct {
	query builder.Query
}

func (r likesToVideoFindFirst) getQuery() builder.Query {
	return r.query
}

func (r likesToVideoFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToVideoFindFirst) with()          {}
func (r likesToVideoFindFirst) likesModel()    {}
func (r likesToVideoFindFirst) likesRelation() {}

func (r likesToVideoFindFirst) With(params ...VideosRelationWith) likesToVideoFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesToVideoFindFirst) Select(params ...likesPrismaFields) likesToVideoFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToVideoFindFirst) Omit(params ...likesPrismaFields) likesToVideoFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToVideoFindFirst) OrderBy(params ...VideosOrderByParam) likesToVideoFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likesToVideoFindFirst) Skip(count int) likesToVideoFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likesToVideoFindFirst) Take(count int) likesToVideoFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likesToVideoFindFirst) Cursor(cursor LikesCursorParam) likesToVideoFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likesToVideoFindFirst) Exec(ctx context.Context) (
	*LikesModel,
	error,
) {
	var v *LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesToVideoFindFirst) ExecInner(ctx context.Context) (
	*InnerLikes,
	error,
) {
	var v *InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type likesToVideoFindMany struct {
	query builder.Query
}

func (r likesToVideoFindMany) getQuery() builder.Query {
	return r.query
}

func (r likesToVideoFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToVideoFindMany) with()          {}
func (r likesToVideoFindMany) likesModel()    {}
func (r likesToVideoFindMany) likesRelation() {}

func (r likesToVideoFindMany) With(params ...VideosRelationWith) likesToVideoFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesToVideoFindMany) Select(params ...likesPrismaFields) likesToVideoFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToVideoFindMany) Omit(params ...likesPrismaFields) likesToVideoFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToVideoFindMany) OrderBy(params ...VideosOrderByParam) likesToVideoFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likesToVideoFindMany) Skip(count int) likesToVideoFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likesToVideoFindMany) Take(count int) likesToVideoFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likesToVideoFindMany) Cursor(cursor LikesCursorParam) likesToVideoFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likesToVideoFindMany) Exec(ctx context.Context) (
	[]LikesModel,
	error,
) {
	var v []LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likesToVideoFindMany) ExecInner(ctx context.Context) (
	[]InnerLikes,
	error,
) {
	var v []InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likesToVideoFindMany) Update(params ...LikesSetParam) likesToVideoUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Likes"

	r.query.Outputs = countOutput

	var v likesToVideoUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likesToVideoUpdateMany struct {
	query builder.Query
}

func (r likesToVideoUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToVideoUpdateMany) likesModel() {}

func (r likesToVideoUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToVideoUpdateMany) Tx() LikesManyTxResult {
	v := newLikesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likesToVideoFindMany) Delete() likesToVideoDeleteMany {
	var v likesToVideoDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Likes"

	v.query.Outputs = countOutput

	return v
}

type likesToVideoDeleteMany struct {
	query builder.Query
}

func (r likesToVideoDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p likesToVideoDeleteMany) likesModel() {}

func (r likesToVideoDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToVideoDeleteMany) Tx() LikesManyTxResult {
	v := newLikesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likesToCommentFindUnique struct {
	query builder.Query
}

func (r likesToCommentFindUnique) getQuery() builder.Query {
	return r.query
}

func (r likesToCommentFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToCommentFindUnique) with()          {}
func (r likesToCommentFindUnique) likesModel()    {}
func (r likesToCommentFindUnique) likesRelation() {}

func (r likesToCommentFindUnique) With(params ...CommentsRelationWith) likesToCommentFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesToCommentFindUnique) Select(params ...likesPrismaFields) likesToCommentFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToCommentFindUnique) Omit(params ...likesPrismaFields) likesToCommentFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToCommentFindUnique) Exec(ctx context.Context) (
	*LikesModel,
	error,
) {
	var v *LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesToCommentFindUnique) ExecInner(ctx context.Context) (
	*InnerLikes,
	error,
) {
	var v *InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesToCommentFindUnique) Update(params ...LikesSetParam) likesToCommentUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Likes"

	var v likesToCommentUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likesToCommentUpdateUnique struct {
	query builder.Query
}

func (r likesToCommentUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToCommentUpdateUnique) likesModel() {}

func (r likesToCommentUpdateUnique) Exec(ctx context.Context) (*LikesModel, error) {
	var v LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToCommentUpdateUnique) Tx() LikesUniqueTxResult {
	v := newLikesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likesToCommentFindUnique) Delete() likesToCommentDeleteUnique {
	var v likesToCommentDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Likes"

	return v
}

type likesToCommentDeleteUnique struct {
	query builder.Query
}

func (r likesToCommentDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p likesToCommentDeleteUnique) likesModel() {}

func (r likesToCommentDeleteUnique) Exec(ctx context.Context) (*LikesModel, error) {
	var v LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToCommentDeleteUnique) Tx() LikesUniqueTxResult {
	v := newLikesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likesToCommentFindFirst struct {
	query builder.Query
}

func (r likesToCommentFindFirst) getQuery() builder.Query {
	return r.query
}

func (r likesToCommentFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToCommentFindFirst) with()          {}
func (r likesToCommentFindFirst) likesModel()    {}
func (r likesToCommentFindFirst) likesRelation() {}

func (r likesToCommentFindFirst) With(params ...CommentsRelationWith) likesToCommentFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesToCommentFindFirst) Select(params ...likesPrismaFields) likesToCommentFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToCommentFindFirst) Omit(params ...likesPrismaFields) likesToCommentFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToCommentFindFirst) OrderBy(params ...CommentsOrderByParam) likesToCommentFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likesToCommentFindFirst) Skip(count int) likesToCommentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likesToCommentFindFirst) Take(count int) likesToCommentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likesToCommentFindFirst) Cursor(cursor LikesCursorParam) likesToCommentFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likesToCommentFindFirst) Exec(ctx context.Context) (
	*LikesModel,
	error,
) {
	var v *LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesToCommentFindFirst) ExecInner(ctx context.Context) (
	*InnerLikes,
	error,
) {
	var v *InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type likesToCommentFindMany struct {
	query builder.Query
}

func (r likesToCommentFindMany) getQuery() builder.Query {
	return r.query
}

func (r likesToCommentFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToCommentFindMany) with()          {}
func (r likesToCommentFindMany) likesModel()    {}
func (r likesToCommentFindMany) likesRelation() {}

func (r likesToCommentFindMany) With(params ...CommentsRelationWith) likesToCommentFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesToCommentFindMany) Select(params ...likesPrismaFields) likesToCommentFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToCommentFindMany) Omit(params ...likesPrismaFields) likesToCommentFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToCommentFindMany) OrderBy(params ...CommentsOrderByParam) likesToCommentFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likesToCommentFindMany) Skip(count int) likesToCommentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likesToCommentFindMany) Take(count int) likesToCommentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likesToCommentFindMany) Cursor(cursor LikesCursorParam) likesToCommentFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likesToCommentFindMany) Exec(ctx context.Context) (
	[]LikesModel,
	error,
) {
	var v []LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likesToCommentFindMany) ExecInner(ctx context.Context) (
	[]InnerLikes,
	error,
) {
	var v []InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likesToCommentFindMany) Update(params ...LikesSetParam) likesToCommentUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Likes"

	r.query.Outputs = countOutput

	var v likesToCommentUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likesToCommentUpdateMany struct {
	query builder.Query
}

func (r likesToCommentUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToCommentUpdateMany) likesModel() {}

func (r likesToCommentUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToCommentUpdateMany) Tx() LikesManyTxResult {
	v := newLikesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likesToCommentFindMany) Delete() likesToCommentDeleteMany {
	var v likesToCommentDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Likes"

	v.query.Outputs = countOutput

	return v
}

type likesToCommentDeleteMany struct {
	query builder.Query
}

func (r likesToCommentDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p likesToCommentDeleteMany) likesModel() {}

func (r likesToCommentDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToCommentDeleteMany) Tx() LikesManyTxResult {
	v := newLikesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likesToReplyFindUnique struct {
	query builder.Query
}

func (r likesToReplyFindUnique) getQuery() builder.Query {
	return r.query
}

func (r likesToReplyFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToReplyFindUnique) with()          {}
func (r likesToReplyFindUnique) likesModel()    {}
func (r likesToReplyFindUnique) likesRelation() {}

func (r likesToReplyFindUnique) With(params ...RepliesRelationWith) likesToReplyFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesToReplyFindUnique) Select(params ...likesPrismaFields) likesToReplyFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToReplyFindUnique) Omit(params ...likesPrismaFields) likesToReplyFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToReplyFindUnique) Exec(ctx context.Context) (
	*LikesModel,
	error,
) {
	var v *LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesToReplyFindUnique) ExecInner(ctx context.Context) (
	*InnerLikes,
	error,
) {
	var v *InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesToReplyFindUnique) Update(params ...LikesSetParam) likesToReplyUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Likes"

	var v likesToReplyUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likesToReplyUpdateUnique struct {
	query builder.Query
}

func (r likesToReplyUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToReplyUpdateUnique) likesModel() {}

func (r likesToReplyUpdateUnique) Exec(ctx context.Context) (*LikesModel, error) {
	var v LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToReplyUpdateUnique) Tx() LikesUniqueTxResult {
	v := newLikesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likesToReplyFindUnique) Delete() likesToReplyDeleteUnique {
	var v likesToReplyDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Likes"

	return v
}

type likesToReplyDeleteUnique struct {
	query builder.Query
}

func (r likesToReplyDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p likesToReplyDeleteUnique) likesModel() {}

func (r likesToReplyDeleteUnique) Exec(ctx context.Context) (*LikesModel, error) {
	var v LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToReplyDeleteUnique) Tx() LikesUniqueTxResult {
	v := newLikesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likesToReplyFindFirst struct {
	query builder.Query
}

func (r likesToReplyFindFirst) getQuery() builder.Query {
	return r.query
}

func (r likesToReplyFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToReplyFindFirst) with()          {}
func (r likesToReplyFindFirst) likesModel()    {}
func (r likesToReplyFindFirst) likesRelation() {}

func (r likesToReplyFindFirst) With(params ...RepliesRelationWith) likesToReplyFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesToReplyFindFirst) Select(params ...likesPrismaFields) likesToReplyFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToReplyFindFirst) Omit(params ...likesPrismaFields) likesToReplyFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToReplyFindFirst) OrderBy(params ...RepliesOrderByParam) likesToReplyFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likesToReplyFindFirst) Skip(count int) likesToReplyFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likesToReplyFindFirst) Take(count int) likesToReplyFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likesToReplyFindFirst) Cursor(cursor LikesCursorParam) likesToReplyFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likesToReplyFindFirst) Exec(ctx context.Context) (
	*LikesModel,
	error,
) {
	var v *LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesToReplyFindFirst) ExecInner(ctx context.Context) (
	*InnerLikes,
	error,
) {
	var v *InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type likesToReplyFindMany struct {
	query builder.Query
}

func (r likesToReplyFindMany) getQuery() builder.Query {
	return r.query
}

func (r likesToReplyFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToReplyFindMany) with()          {}
func (r likesToReplyFindMany) likesModel()    {}
func (r likesToReplyFindMany) likesRelation() {}

func (r likesToReplyFindMany) With(params ...RepliesRelationWith) likesToReplyFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesToReplyFindMany) Select(params ...likesPrismaFields) likesToReplyFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToReplyFindMany) Omit(params ...likesPrismaFields) likesToReplyFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesToReplyFindMany) OrderBy(params ...RepliesOrderByParam) likesToReplyFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likesToReplyFindMany) Skip(count int) likesToReplyFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likesToReplyFindMany) Take(count int) likesToReplyFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likesToReplyFindMany) Cursor(cursor LikesCursorParam) likesToReplyFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likesToReplyFindMany) Exec(ctx context.Context) (
	[]LikesModel,
	error,
) {
	var v []LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likesToReplyFindMany) ExecInner(ctx context.Context) (
	[]InnerLikes,
	error,
) {
	var v []InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likesToReplyFindMany) Update(params ...LikesSetParam) likesToReplyUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Likes"

	r.query.Outputs = countOutput

	var v likesToReplyUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likesToReplyUpdateMany struct {
	query builder.Query
}

func (r likesToReplyUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likesToReplyUpdateMany) likesModel() {}

func (r likesToReplyUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToReplyUpdateMany) Tx() LikesManyTxResult {
	v := newLikesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likesToReplyFindMany) Delete() likesToReplyDeleteMany {
	var v likesToReplyDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Likes"

	v.query.Outputs = countOutput

	return v
}

type likesToReplyDeleteMany struct {
	query builder.Query
}

func (r likesToReplyDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p likesToReplyDeleteMany) likesModel() {}

func (r likesToReplyDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesToReplyDeleteMany) Tx() LikesManyTxResult {
	v := newLikesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likesFindUnique struct {
	query builder.Query
}

func (r likesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r likesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likesFindUnique) with()          {}
func (r likesFindUnique) likesModel()    {}
func (r likesFindUnique) likesRelation() {}

func (r likesActions) FindUnique(
	params LikesEqualsUniqueWhereParam,
) likesFindUnique {
	var v likesFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "Likes"
	v.query.Outputs = likesOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r likesFindUnique) With(params ...LikesRelationWith) likesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesFindUnique) Select(params ...likesPrismaFields) likesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesFindUnique) Omit(params ...likesPrismaFields) likesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesFindUnique) Exec(ctx context.Context) (
	*LikesModel,
	error,
) {
	var v *LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesFindUnique) ExecInner(ctx context.Context) (
	*InnerLikes,
	error,
) {
	var v *InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesFindUnique) Update(params ...LikesSetParam) likesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "Likes"

	var v likesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likesUpdateUnique struct {
	query builder.Query
}

func (r likesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r likesUpdateUnique) likesModel() {}

func (r likesUpdateUnique) Exec(ctx context.Context) (*LikesModel, error) {
	var v LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesUpdateUnique) Tx() LikesUniqueTxResult {
	v := newLikesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likesFindUnique) Delete() likesDeleteUnique {
	var v likesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "Likes"

	return v
}

type likesDeleteUnique struct {
	query builder.Query
}

func (r likesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p likesDeleteUnique) likesModel() {}

func (r likesDeleteUnique) Exec(ctx context.Context) (*LikesModel, error) {
	var v LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesDeleteUnique) Tx() LikesUniqueTxResult {
	v := newLikesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likesFindFirst struct {
	query builder.Query
}

func (r likesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r likesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r likesFindFirst) with()          {}
func (r likesFindFirst) likesModel()    {}
func (r likesFindFirst) likesRelation() {}

func (r likesActions) FindFirst(
	params ...LikesWhereParam,
) likesFindFirst {
	var v likesFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "Likes"
	v.query.Outputs = likesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r likesFindFirst) With(params ...LikesRelationWith) likesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesFindFirst) Select(params ...likesPrismaFields) likesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesFindFirst) Omit(params ...likesPrismaFields) likesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesFindFirst) OrderBy(params ...LikesOrderByParam) likesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likesFindFirst) Skip(count int) likesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likesFindFirst) Take(count int) likesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likesFindFirst) Cursor(cursor LikesCursorParam) likesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likesFindFirst) Exec(ctx context.Context) (
	*LikesModel,
	error,
) {
	var v *LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r likesFindFirst) ExecInner(ctx context.Context) (
	*InnerLikes,
	error,
) {
	var v *InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type likesFindMany struct {
	query builder.Query
}

func (r likesFindMany) getQuery() builder.Query {
	return r.query
}

func (r likesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likesFindMany) with()          {}
func (r likesFindMany) likesModel()    {}
func (r likesFindMany) likesRelation() {}

func (r likesActions) FindMany(
	params ...LikesWhereParam,
) likesFindMany {
	var v likesFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "Likes"
	v.query.Outputs = likesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r likesFindMany) With(params ...LikesRelationWith) likesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r likesFindMany) Select(params ...likesPrismaFields) likesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r likesFindMany) Omit(params ...likesPrismaFields) likesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range likesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r likesFindMany) OrderBy(params ...LikesOrderByParam) likesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r likesFindMany) Skip(count int) likesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r likesFindMany) Take(count int) likesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r likesFindMany) Cursor(cursor LikesCursorParam) likesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r likesFindMany) Exec(ctx context.Context) (
	[]LikesModel,
	error,
) {
	var v []LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likesFindMany) ExecInner(ctx context.Context) (
	[]InnerLikes,
	error,
) {
	var v []InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r likesFindMany) Update(params ...LikesSetParam) likesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "Likes"

	r.query.Outputs = countOutput

	var v likesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type likesUpdateMany struct {
	query builder.Query
}

func (r likesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r likesUpdateMany) likesModel() {}

func (r likesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesUpdateMany) Tx() LikesManyTxResult {
	v := newLikesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r likesFindMany) Delete() likesDeleteMany {
	var v likesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "Likes"

	v.query.Outputs = countOutput

	return v
}

type likesDeleteMany struct {
	query builder.Query
}

func (r likesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p likesDeleteMany) likesModel() {}

func (r likesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesDeleteMany) Tx() LikesManyTxResult {
	v := newLikesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type historyToVideoFindUnique struct {
	query builder.Query
}

func (r historyToVideoFindUnique) getQuery() builder.Query {
	return r.query
}

func (r historyToVideoFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r historyToVideoFindUnique) with()            {}
func (r historyToVideoFindUnique) historyModel()    {}
func (r historyToVideoFindUnique) historyRelation() {}

func (r historyToVideoFindUnique) With(params ...VideosRelationWith) historyToVideoFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r historyToVideoFindUnique) Select(params ...historyPrismaFields) historyToVideoFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r historyToVideoFindUnique) Omit(params ...historyPrismaFields) historyToVideoFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range historyOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r historyToVideoFindUnique) Exec(ctx context.Context) (
	*HistoryModel,
	error,
) {
	var v *HistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r historyToVideoFindUnique) ExecInner(ctx context.Context) (
	*InnerHistory,
	error,
) {
	var v *InnerHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r historyToVideoFindUnique) Update(params ...HistorySetParam) historyToVideoUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "history"

	var v historyToVideoUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type historyToVideoUpdateUnique struct {
	query builder.Query
}

func (r historyToVideoUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r historyToVideoUpdateUnique) historyModel() {}

func (r historyToVideoUpdateUnique) Exec(ctx context.Context) (*HistoryModel, error) {
	var v HistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r historyToVideoUpdateUnique) Tx() HistoryUniqueTxResult {
	v := newHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r historyToVideoFindUnique) Delete() historyToVideoDeleteUnique {
	var v historyToVideoDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "history"

	return v
}

type historyToVideoDeleteUnique struct {
	query builder.Query
}

func (r historyToVideoDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p historyToVideoDeleteUnique) historyModel() {}

func (r historyToVideoDeleteUnique) Exec(ctx context.Context) (*HistoryModel, error) {
	var v HistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r historyToVideoDeleteUnique) Tx() HistoryUniqueTxResult {
	v := newHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type historyToVideoFindFirst struct {
	query builder.Query
}

func (r historyToVideoFindFirst) getQuery() builder.Query {
	return r.query
}

func (r historyToVideoFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r historyToVideoFindFirst) with()            {}
func (r historyToVideoFindFirst) historyModel()    {}
func (r historyToVideoFindFirst) historyRelation() {}

func (r historyToVideoFindFirst) With(params ...VideosRelationWith) historyToVideoFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r historyToVideoFindFirst) Select(params ...historyPrismaFields) historyToVideoFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r historyToVideoFindFirst) Omit(params ...historyPrismaFields) historyToVideoFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range historyOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r historyToVideoFindFirst) OrderBy(params ...VideosOrderByParam) historyToVideoFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r historyToVideoFindFirst) Skip(count int) historyToVideoFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r historyToVideoFindFirst) Take(count int) historyToVideoFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r historyToVideoFindFirst) Cursor(cursor HistoryCursorParam) historyToVideoFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r historyToVideoFindFirst) Exec(ctx context.Context) (
	*HistoryModel,
	error,
) {
	var v *HistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r historyToVideoFindFirst) ExecInner(ctx context.Context) (
	*InnerHistory,
	error,
) {
	var v *InnerHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type historyToVideoFindMany struct {
	query builder.Query
}

func (r historyToVideoFindMany) getQuery() builder.Query {
	return r.query
}

func (r historyToVideoFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r historyToVideoFindMany) with()            {}
func (r historyToVideoFindMany) historyModel()    {}
func (r historyToVideoFindMany) historyRelation() {}

func (r historyToVideoFindMany) With(params ...VideosRelationWith) historyToVideoFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r historyToVideoFindMany) Select(params ...historyPrismaFields) historyToVideoFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r historyToVideoFindMany) Omit(params ...historyPrismaFields) historyToVideoFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range historyOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r historyToVideoFindMany) OrderBy(params ...VideosOrderByParam) historyToVideoFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r historyToVideoFindMany) Skip(count int) historyToVideoFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r historyToVideoFindMany) Take(count int) historyToVideoFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r historyToVideoFindMany) Cursor(cursor HistoryCursorParam) historyToVideoFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r historyToVideoFindMany) Exec(ctx context.Context) (
	[]HistoryModel,
	error,
) {
	var v []HistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r historyToVideoFindMany) ExecInner(ctx context.Context) (
	[]InnerHistory,
	error,
) {
	var v []InnerHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r historyToVideoFindMany) Update(params ...HistorySetParam) historyToVideoUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "history"

	r.query.Outputs = countOutput

	var v historyToVideoUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type historyToVideoUpdateMany struct {
	query builder.Query
}

func (r historyToVideoUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r historyToVideoUpdateMany) historyModel() {}

func (r historyToVideoUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r historyToVideoUpdateMany) Tx() HistoryManyTxResult {
	v := newHistoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r historyToVideoFindMany) Delete() historyToVideoDeleteMany {
	var v historyToVideoDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "history"

	v.query.Outputs = countOutput

	return v
}

type historyToVideoDeleteMany struct {
	query builder.Query
}

func (r historyToVideoDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p historyToVideoDeleteMany) historyModel() {}

func (r historyToVideoDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r historyToVideoDeleteMany) Tx() HistoryManyTxResult {
	v := newHistoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type historyFindUnique struct {
	query builder.Query
}

func (r historyFindUnique) getQuery() builder.Query {
	return r.query
}

func (r historyFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r historyFindUnique) with()            {}
func (r historyFindUnique) historyModel()    {}
func (r historyFindUnique) historyRelation() {}

func (r historyActions) FindUnique(
	params HistoryEqualsUniqueWhereParam,
) historyFindUnique {
	var v historyFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "history"
	v.query.Outputs = historyOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r historyFindUnique) With(params ...HistoryRelationWith) historyFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r historyFindUnique) Select(params ...historyPrismaFields) historyFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r historyFindUnique) Omit(params ...historyPrismaFields) historyFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range historyOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r historyFindUnique) Exec(ctx context.Context) (
	*HistoryModel,
	error,
) {
	var v *HistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r historyFindUnique) ExecInner(ctx context.Context) (
	*InnerHistory,
	error,
) {
	var v *InnerHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r historyFindUnique) Update(params ...HistorySetParam) historyUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "history"

	var v historyUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type historyUpdateUnique struct {
	query builder.Query
}

func (r historyUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r historyUpdateUnique) historyModel() {}

func (r historyUpdateUnique) Exec(ctx context.Context) (*HistoryModel, error) {
	var v HistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r historyUpdateUnique) Tx() HistoryUniqueTxResult {
	v := newHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r historyFindUnique) Delete() historyDeleteUnique {
	var v historyDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "history"

	return v
}

type historyDeleteUnique struct {
	query builder.Query
}

func (r historyDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p historyDeleteUnique) historyModel() {}

func (r historyDeleteUnique) Exec(ctx context.Context) (*HistoryModel, error) {
	var v HistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r historyDeleteUnique) Tx() HistoryUniqueTxResult {
	v := newHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type historyFindFirst struct {
	query builder.Query
}

func (r historyFindFirst) getQuery() builder.Query {
	return r.query
}

func (r historyFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r historyFindFirst) with()            {}
func (r historyFindFirst) historyModel()    {}
func (r historyFindFirst) historyRelation() {}

func (r historyActions) FindFirst(
	params ...HistoryWhereParam,
) historyFindFirst {
	var v historyFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "history"
	v.query.Outputs = historyOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r historyFindFirst) With(params ...HistoryRelationWith) historyFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r historyFindFirst) Select(params ...historyPrismaFields) historyFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r historyFindFirst) Omit(params ...historyPrismaFields) historyFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range historyOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r historyFindFirst) OrderBy(params ...HistoryOrderByParam) historyFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r historyFindFirst) Skip(count int) historyFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r historyFindFirst) Take(count int) historyFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r historyFindFirst) Cursor(cursor HistoryCursorParam) historyFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r historyFindFirst) Exec(ctx context.Context) (
	*HistoryModel,
	error,
) {
	var v *HistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r historyFindFirst) ExecInner(ctx context.Context) (
	*InnerHistory,
	error,
) {
	var v *InnerHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type historyFindMany struct {
	query builder.Query
}

func (r historyFindMany) getQuery() builder.Query {
	return r.query
}

func (r historyFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r historyFindMany) with()            {}
func (r historyFindMany) historyModel()    {}
func (r historyFindMany) historyRelation() {}

func (r historyActions) FindMany(
	params ...HistoryWhereParam,
) historyFindMany {
	var v historyFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "history"
	v.query.Outputs = historyOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r historyFindMany) With(params ...HistoryRelationWith) historyFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r historyFindMany) Select(params ...historyPrismaFields) historyFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r historyFindMany) Omit(params ...historyPrismaFields) historyFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range historyOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r historyFindMany) OrderBy(params ...HistoryOrderByParam) historyFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r historyFindMany) Skip(count int) historyFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r historyFindMany) Take(count int) historyFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r historyFindMany) Cursor(cursor HistoryCursorParam) historyFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r historyFindMany) Exec(ctx context.Context) (
	[]HistoryModel,
	error,
) {
	var v []HistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r historyFindMany) ExecInner(ctx context.Context) (
	[]InnerHistory,
	error,
) {
	var v []InnerHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r historyFindMany) Update(params ...HistorySetParam) historyUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "history"

	r.query.Outputs = countOutput

	var v historyUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type historyUpdateMany struct {
	query builder.Query
}

func (r historyUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r historyUpdateMany) historyModel() {}

func (r historyUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r historyUpdateMany) Tx() HistoryManyTxResult {
	v := newHistoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r historyFindMany) Delete() historyDeleteMany {
	var v historyDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "history"

	v.query.Outputs = countOutput

	return v
}

type historyDeleteMany struct {
	query builder.Query
}

func (r historyDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p historyDeleteMany) historyModel() {}

func (r historyDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r historyDeleteMany) Tx() HistoryManyTxResult {
	v := newHistoryManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type watchLaterToVideoFindUnique struct {
	query builder.Query
}

func (r watchLaterToVideoFindUnique) getQuery() builder.Query {
	return r.query
}

func (r watchLaterToVideoFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r watchLaterToVideoFindUnique) with()               {}
func (r watchLaterToVideoFindUnique) watchLaterModel()    {}
func (r watchLaterToVideoFindUnique) watchLaterRelation() {}

func (r watchLaterToVideoFindUnique) With(params ...VideosRelationWith) watchLaterToVideoFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r watchLaterToVideoFindUnique) Select(params ...watchLaterPrismaFields) watchLaterToVideoFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r watchLaterToVideoFindUnique) Omit(params ...watchLaterPrismaFields) watchLaterToVideoFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range watchLaterOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r watchLaterToVideoFindUnique) Exec(ctx context.Context) (
	*WatchLaterModel,
	error,
) {
	var v *WatchLaterModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r watchLaterToVideoFindUnique) ExecInner(ctx context.Context) (
	*InnerWatchLater,
	error,
) {
	var v *InnerWatchLater
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r watchLaterToVideoFindUnique) Update(params ...WatchLaterSetParam) watchLaterToVideoUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "WatchLater"

	var v watchLaterToVideoUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type watchLaterToVideoUpdateUnique struct {
	query builder.Query
}

func (r watchLaterToVideoUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r watchLaterToVideoUpdateUnique) watchLaterModel() {}

func (r watchLaterToVideoUpdateUnique) Exec(ctx context.Context) (*WatchLaterModel, error) {
	var v WatchLaterModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r watchLaterToVideoUpdateUnique) Tx() WatchLaterUniqueTxResult {
	v := newWatchLaterUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r watchLaterToVideoFindUnique) Delete() watchLaterToVideoDeleteUnique {
	var v watchLaterToVideoDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "WatchLater"

	return v
}

type watchLaterToVideoDeleteUnique struct {
	query builder.Query
}

func (r watchLaterToVideoDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p watchLaterToVideoDeleteUnique) watchLaterModel() {}

func (r watchLaterToVideoDeleteUnique) Exec(ctx context.Context) (*WatchLaterModel, error) {
	var v WatchLaterModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r watchLaterToVideoDeleteUnique) Tx() WatchLaterUniqueTxResult {
	v := newWatchLaterUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type watchLaterToVideoFindFirst struct {
	query builder.Query
}

func (r watchLaterToVideoFindFirst) getQuery() builder.Query {
	return r.query
}

func (r watchLaterToVideoFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r watchLaterToVideoFindFirst) with()               {}
func (r watchLaterToVideoFindFirst) watchLaterModel()    {}
func (r watchLaterToVideoFindFirst) watchLaterRelation() {}

func (r watchLaterToVideoFindFirst) With(params ...VideosRelationWith) watchLaterToVideoFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r watchLaterToVideoFindFirst) Select(params ...watchLaterPrismaFields) watchLaterToVideoFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r watchLaterToVideoFindFirst) Omit(params ...watchLaterPrismaFields) watchLaterToVideoFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range watchLaterOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r watchLaterToVideoFindFirst) OrderBy(params ...VideosOrderByParam) watchLaterToVideoFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r watchLaterToVideoFindFirst) Skip(count int) watchLaterToVideoFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r watchLaterToVideoFindFirst) Take(count int) watchLaterToVideoFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r watchLaterToVideoFindFirst) Cursor(cursor WatchLaterCursorParam) watchLaterToVideoFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r watchLaterToVideoFindFirst) Exec(ctx context.Context) (
	*WatchLaterModel,
	error,
) {
	var v *WatchLaterModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r watchLaterToVideoFindFirst) ExecInner(ctx context.Context) (
	*InnerWatchLater,
	error,
) {
	var v *InnerWatchLater
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type watchLaterToVideoFindMany struct {
	query builder.Query
}

func (r watchLaterToVideoFindMany) getQuery() builder.Query {
	return r.query
}

func (r watchLaterToVideoFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r watchLaterToVideoFindMany) with()               {}
func (r watchLaterToVideoFindMany) watchLaterModel()    {}
func (r watchLaterToVideoFindMany) watchLaterRelation() {}

func (r watchLaterToVideoFindMany) With(params ...VideosRelationWith) watchLaterToVideoFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r watchLaterToVideoFindMany) Select(params ...watchLaterPrismaFields) watchLaterToVideoFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r watchLaterToVideoFindMany) Omit(params ...watchLaterPrismaFields) watchLaterToVideoFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range watchLaterOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r watchLaterToVideoFindMany) OrderBy(params ...VideosOrderByParam) watchLaterToVideoFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r watchLaterToVideoFindMany) Skip(count int) watchLaterToVideoFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r watchLaterToVideoFindMany) Take(count int) watchLaterToVideoFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r watchLaterToVideoFindMany) Cursor(cursor WatchLaterCursorParam) watchLaterToVideoFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r watchLaterToVideoFindMany) Exec(ctx context.Context) (
	[]WatchLaterModel,
	error,
) {
	var v []WatchLaterModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r watchLaterToVideoFindMany) ExecInner(ctx context.Context) (
	[]InnerWatchLater,
	error,
) {
	var v []InnerWatchLater
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r watchLaterToVideoFindMany) Update(params ...WatchLaterSetParam) watchLaterToVideoUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "WatchLater"

	r.query.Outputs = countOutput

	var v watchLaterToVideoUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type watchLaterToVideoUpdateMany struct {
	query builder.Query
}

func (r watchLaterToVideoUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r watchLaterToVideoUpdateMany) watchLaterModel() {}

func (r watchLaterToVideoUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r watchLaterToVideoUpdateMany) Tx() WatchLaterManyTxResult {
	v := newWatchLaterManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r watchLaterToVideoFindMany) Delete() watchLaterToVideoDeleteMany {
	var v watchLaterToVideoDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "WatchLater"

	v.query.Outputs = countOutput

	return v
}

type watchLaterToVideoDeleteMany struct {
	query builder.Query
}

func (r watchLaterToVideoDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p watchLaterToVideoDeleteMany) watchLaterModel() {}

func (r watchLaterToVideoDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r watchLaterToVideoDeleteMany) Tx() WatchLaterManyTxResult {
	v := newWatchLaterManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type watchLaterFindUnique struct {
	query builder.Query
}

func (r watchLaterFindUnique) getQuery() builder.Query {
	return r.query
}

func (r watchLaterFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r watchLaterFindUnique) with()               {}
func (r watchLaterFindUnique) watchLaterModel()    {}
func (r watchLaterFindUnique) watchLaterRelation() {}

func (r watchLaterActions) FindUnique(
	params WatchLaterEqualsUniqueWhereParam,
) watchLaterFindUnique {
	var v watchLaterFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "WatchLater"
	v.query.Outputs = watchLaterOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r watchLaterFindUnique) With(params ...WatchLaterRelationWith) watchLaterFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r watchLaterFindUnique) Select(params ...watchLaterPrismaFields) watchLaterFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r watchLaterFindUnique) Omit(params ...watchLaterPrismaFields) watchLaterFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range watchLaterOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r watchLaterFindUnique) Exec(ctx context.Context) (
	*WatchLaterModel,
	error,
) {
	var v *WatchLaterModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r watchLaterFindUnique) ExecInner(ctx context.Context) (
	*InnerWatchLater,
	error,
) {
	var v *InnerWatchLater
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r watchLaterFindUnique) Update(params ...WatchLaterSetParam) watchLaterUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "WatchLater"

	var v watchLaterUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type watchLaterUpdateUnique struct {
	query builder.Query
}

func (r watchLaterUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r watchLaterUpdateUnique) watchLaterModel() {}

func (r watchLaterUpdateUnique) Exec(ctx context.Context) (*WatchLaterModel, error) {
	var v WatchLaterModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r watchLaterUpdateUnique) Tx() WatchLaterUniqueTxResult {
	v := newWatchLaterUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r watchLaterFindUnique) Delete() watchLaterDeleteUnique {
	var v watchLaterDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "WatchLater"

	return v
}

type watchLaterDeleteUnique struct {
	query builder.Query
}

func (r watchLaterDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p watchLaterDeleteUnique) watchLaterModel() {}

func (r watchLaterDeleteUnique) Exec(ctx context.Context) (*WatchLaterModel, error) {
	var v WatchLaterModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r watchLaterDeleteUnique) Tx() WatchLaterUniqueTxResult {
	v := newWatchLaterUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type watchLaterFindFirst struct {
	query builder.Query
}

func (r watchLaterFindFirst) getQuery() builder.Query {
	return r.query
}

func (r watchLaterFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r watchLaterFindFirst) with()               {}
func (r watchLaterFindFirst) watchLaterModel()    {}
func (r watchLaterFindFirst) watchLaterRelation() {}

func (r watchLaterActions) FindFirst(
	params ...WatchLaterWhereParam,
) watchLaterFindFirst {
	var v watchLaterFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "WatchLater"
	v.query.Outputs = watchLaterOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r watchLaterFindFirst) With(params ...WatchLaterRelationWith) watchLaterFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r watchLaterFindFirst) Select(params ...watchLaterPrismaFields) watchLaterFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r watchLaterFindFirst) Omit(params ...watchLaterPrismaFields) watchLaterFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range watchLaterOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r watchLaterFindFirst) OrderBy(params ...WatchLaterOrderByParam) watchLaterFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r watchLaterFindFirst) Skip(count int) watchLaterFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r watchLaterFindFirst) Take(count int) watchLaterFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r watchLaterFindFirst) Cursor(cursor WatchLaterCursorParam) watchLaterFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r watchLaterFindFirst) Exec(ctx context.Context) (
	*WatchLaterModel,
	error,
) {
	var v *WatchLaterModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r watchLaterFindFirst) ExecInner(ctx context.Context) (
	*InnerWatchLater,
	error,
) {
	var v *InnerWatchLater
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type watchLaterFindMany struct {
	query builder.Query
}

func (r watchLaterFindMany) getQuery() builder.Query {
	return r.query
}

func (r watchLaterFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r watchLaterFindMany) with()               {}
func (r watchLaterFindMany) watchLaterModel()    {}
func (r watchLaterFindMany) watchLaterRelation() {}

func (r watchLaterActions) FindMany(
	params ...WatchLaterWhereParam,
) watchLaterFindMany {
	var v watchLaterFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "WatchLater"
	v.query.Outputs = watchLaterOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r watchLaterFindMany) With(params ...WatchLaterRelationWith) watchLaterFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r watchLaterFindMany) Select(params ...watchLaterPrismaFields) watchLaterFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r watchLaterFindMany) Omit(params ...watchLaterPrismaFields) watchLaterFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range watchLaterOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r watchLaterFindMany) OrderBy(params ...WatchLaterOrderByParam) watchLaterFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r watchLaterFindMany) Skip(count int) watchLaterFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r watchLaterFindMany) Take(count int) watchLaterFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r watchLaterFindMany) Cursor(cursor WatchLaterCursorParam) watchLaterFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r watchLaterFindMany) Exec(ctx context.Context) (
	[]WatchLaterModel,
	error,
) {
	var v []WatchLaterModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r watchLaterFindMany) ExecInner(ctx context.Context) (
	[]InnerWatchLater,
	error,
) {
	var v []InnerWatchLater
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r watchLaterFindMany) Update(params ...WatchLaterSetParam) watchLaterUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "WatchLater"

	r.query.Outputs = countOutput

	var v watchLaterUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type watchLaterUpdateMany struct {
	query builder.Query
}

func (r watchLaterUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r watchLaterUpdateMany) watchLaterModel() {}

func (r watchLaterUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r watchLaterUpdateMany) Tx() WatchLaterManyTxResult {
	v := newWatchLaterManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r watchLaterFindMany) Delete() watchLaterDeleteMany {
	var v watchLaterDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "WatchLater"

	v.query.Outputs = countOutput

	return v
}

type watchLaterDeleteMany struct {
	query builder.Query
}

func (r watchLaterDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p watchLaterDeleteMany) watchLaterModel() {}

func (r watchLaterDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r watchLaterDeleteMany) Tx() WatchLaterManyTxResult {
	v := newWatchLaterManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func newUserUniqueTxResult() UserUniqueTxResult {
	return UserUniqueTxResult{
		result: &transaction.Result{},
	}
}

type UserUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserUniqueTxResult) IsTx() {}

func (r UserUniqueTxResult) Result() (v *UserModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUserManyTxResult() UserManyTxResult {
	return UserManyTxResult{
		result: &transaction.Result{},
	}
}

type UserManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UserManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UserManyTxResult) IsTx() {}

func (r UserManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newGuildUniqueTxResult() GuildUniqueTxResult {
	return GuildUniqueTxResult{
		result: &transaction.Result{},
	}
}

type GuildUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p GuildUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p GuildUniqueTxResult) IsTx() {}

func (r GuildUniqueTxResult) Result() (v *GuildModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newGuildManyTxResult() GuildManyTxResult {
	return GuildManyTxResult{
		result: &transaction.Result{},
	}
}

type GuildManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p GuildManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p GuildManyTxResult) IsTx() {}

func (r GuildManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newGuildMemberUniqueTxResult() GuildMemberUniqueTxResult {
	return GuildMemberUniqueTxResult{
		result: &transaction.Result{},
	}
}

type GuildMemberUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p GuildMemberUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p GuildMemberUniqueTxResult) IsTx() {}

func (r GuildMemberUniqueTxResult) Result() (v *GuildMemberModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newGuildMemberManyTxResult() GuildMemberManyTxResult {
	return GuildMemberManyTxResult{
		result: &transaction.Result{},
	}
}

type GuildMemberManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p GuildMemberManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p GuildMemberManyTxResult) IsTx() {}

func (r GuildMemberManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newVideosUniqueTxResult() VideosUniqueTxResult {
	return VideosUniqueTxResult{
		result: &transaction.Result{},
	}
}

type VideosUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p VideosUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p VideosUniqueTxResult) IsTx() {}

func (r VideosUniqueTxResult) Result() (v *VideosModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newVideosManyTxResult() VideosManyTxResult {
	return VideosManyTxResult{
		result: &transaction.Result{},
	}
}

type VideosManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p VideosManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p VideosManyTxResult) IsTx() {}

func (r VideosManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newTagsUniqueTxResult() TagsUniqueTxResult {
	return TagsUniqueTxResult{
		result: &transaction.Result{},
	}
}

type TagsUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TagsUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TagsUniqueTxResult) IsTx() {}

func (r TagsUniqueTxResult) Result() (v *TagsModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newTagsManyTxResult() TagsManyTxResult {
	return TagsManyTxResult{
		result: &transaction.Result{},
	}
}

type TagsManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TagsManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TagsManyTxResult) IsTx() {}

func (r TagsManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newTagsOnVideosUniqueTxResult() TagsOnVideosUniqueTxResult {
	return TagsOnVideosUniqueTxResult{
		result: &transaction.Result{},
	}
}

type TagsOnVideosUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TagsOnVideosUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TagsOnVideosUniqueTxResult) IsTx() {}

func (r TagsOnVideosUniqueTxResult) Result() (v *TagsOnVideosModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newTagsOnVideosManyTxResult() TagsOnVideosManyTxResult {
	return TagsOnVideosManyTxResult{
		result: &transaction.Result{},
	}
}

type TagsOnVideosManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p TagsOnVideosManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p TagsOnVideosManyTxResult) IsTx() {}

func (r TagsOnVideosManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newCommentsUniqueTxResult() CommentsUniqueTxResult {
	return CommentsUniqueTxResult{
		result: &transaction.Result{},
	}
}

type CommentsUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p CommentsUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p CommentsUniqueTxResult) IsTx() {}

func (r CommentsUniqueTxResult) Result() (v *CommentsModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newCommentsManyTxResult() CommentsManyTxResult {
	return CommentsManyTxResult{
		result: &transaction.Result{},
	}
}

type CommentsManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p CommentsManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p CommentsManyTxResult) IsTx() {}

func (r CommentsManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newRepliesUniqueTxResult() RepliesUniqueTxResult {
	return RepliesUniqueTxResult{
		result: &transaction.Result{},
	}
}

type RepliesUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p RepliesUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p RepliesUniqueTxResult) IsTx() {}

func (r RepliesUniqueTxResult) Result() (v *RepliesModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newRepliesManyTxResult() RepliesManyTxResult {
	return RepliesManyTxResult{
		result: &transaction.Result{},
	}
}

type RepliesManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p RepliesManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p RepliesManyTxResult) IsTx() {}

func (r RepliesManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newLikesUniqueTxResult() LikesUniqueTxResult {
	return LikesUniqueTxResult{
		result: &transaction.Result{},
	}
}

type LikesUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p LikesUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p LikesUniqueTxResult) IsTx() {}

func (r LikesUniqueTxResult) Result() (v *LikesModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newLikesManyTxResult() LikesManyTxResult {
	return LikesManyTxResult{
		result: &transaction.Result{},
	}
}

type LikesManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p LikesManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p LikesManyTxResult) IsTx() {}

func (r LikesManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newHistoryUniqueTxResult() HistoryUniqueTxResult {
	return HistoryUniqueTxResult{
		result: &transaction.Result{},
	}
}

type HistoryUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p HistoryUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p HistoryUniqueTxResult) IsTx() {}

func (r HistoryUniqueTxResult) Result() (v *HistoryModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newHistoryManyTxResult() HistoryManyTxResult {
	return HistoryManyTxResult{
		result: &transaction.Result{},
	}
}

type HistoryManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p HistoryManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p HistoryManyTxResult) IsTx() {}

func (r HistoryManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newWatchLaterUniqueTxResult() WatchLaterUniqueTxResult {
	return WatchLaterUniqueTxResult{
		result: &transaction.Result{},
	}
}

type WatchLaterUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p WatchLaterUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p WatchLaterUniqueTxResult) IsTx() {}

func (r WatchLaterUniqueTxResult) Result() (v *WatchLaterModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newWatchLaterManyTxResult() WatchLaterManyTxResult {
	return WatchLaterManyTxResult{
		result: &transaction.Result{},
	}
}

type WatchLaterManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p WatchLaterManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p WatchLaterManyTxResult) IsTx() {}

func (r WatchLaterManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template upsert.gotpl ---

type userUpsertOne struct {
	query builder.Query
}

func (r userUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r userUpsertOne) with()         {}
func (r userUpsertOne) userModel()    {}
func (r userUpsertOne) userRelation() {}

func (r userActions) UpsertOne(
	params UserEqualsUniqueWhereParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "User"
	v.query.Outputs = userOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r userUpsertOne) Create(

	_fullname UserWithPrismaFullnameSetParam,
	_email UserWithPrismaEmailSetParam,
	_password UserWithPrismaPasswordSetParam,
	_avatar UserWithPrismaAvatarSetParam,

	optional ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _fullname.field())
	fields = append(fields, _email.field())
	fields = append(fields, _password.field())
	fields = append(fields, _avatar.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Update(
	params ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) CreateOrUpdate(

	_fullname UserWithPrismaFullnameSetParam,
	_email UserWithPrismaEmailSetParam,
	_password UserWithPrismaPasswordSetParam,
	_avatar UserWithPrismaAvatarSetParam,

	optional ...UserSetParam,
) userUpsertOne {
	var v userUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _fullname.field())
	fields = append(fields, _email.field())
	fields = append(fields, _password.field())
	fields = append(fields, _avatar.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r userUpsertOne) Exec(ctx context.Context) (*UserModel, error) {
	var v UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r userUpsertOne) Tx() UserUniqueTxResult {
	v := newUserUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildUpsertOne struct {
	query builder.Query
}

func (r guildUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r guildUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r guildUpsertOne) with()          {}
func (r guildUpsertOne) guildModel()    {}
func (r guildUpsertOne) guildRelation() {}

func (r guildActions) UpsertOne(
	params GuildEqualsUniqueWhereParam,
) guildUpsertOne {
	var v guildUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Guild"
	v.query.Outputs = guildOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r guildUpsertOne) Create(

	_name GuildWithPrismaNameSetParam,
	_owner GuildWithPrismaOwnerSetParam,

	optional ...GuildSetParam,
) guildUpsertOne {
	var v guildUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _owner.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r guildUpsertOne) Update(
	params ...GuildSetParam,
) guildUpsertOne {
	var v guildUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r guildUpsertOne) CreateOrUpdate(

	_name GuildWithPrismaNameSetParam,
	_owner GuildWithPrismaOwnerSetParam,

	optional ...GuildSetParam,
) guildUpsertOne {
	var v guildUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _owner.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r guildUpsertOne) Exec(ctx context.Context) (*GuildModel, error) {
	var v GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildUpsertOne) Tx() GuildUniqueTxResult {
	v := newGuildUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type guildMemberUpsertOne struct {
	query builder.Query
}

func (r guildMemberUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r guildMemberUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberUpsertOne) with()                {}
func (r guildMemberUpsertOne) guildMemberModel()    {}
func (r guildMemberUpsertOne) guildMemberRelation() {}

func (r guildMemberActions) UpsertOne(
	params GuildMemberEqualsUniqueWhereParam,
) guildMemberUpsertOne {
	var v guildMemberUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "GuildMember"
	v.query.Outputs = guildMemberOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r guildMemberUpsertOne) Create(

	_user GuildMemberWithPrismaUserSetParam,
	_guild GuildMemberWithPrismaGuildSetParam,

	optional ...GuildMemberSetParam,
) guildMemberUpsertOne {
	var v guildMemberUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _user.field())
	fields = append(fields, _guild.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r guildMemberUpsertOne) Update(
	params ...GuildMemberSetParam,
) guildMemberUpsertOne {
	var v guildMemberUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r guildMemberUpsertOne) CreateOrUpdate(

	_user GuildMemberWithPrismaUserSetParam,
	_guild GuildMemberWithPrismaGuildSetParam,

	optional ...GuildMemberSetParam,
) guildMemberUpsertOne {
	var v guildMemberUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _user.field())
	fields = append(fields, _guild.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r guildMemberUpsertOne) Exec(ctx context.Context) (*GuildMemberModel, error) {
	var v GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r guildMemberUpsertOne) Tx() GuildMemberUniqueTxResult {
	v := newGuildMemberUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type videosUpsertOne struct {
	query builder.Query
}

func (r videosUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r videosUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r videosUpsertOne) with()           {}
func (r videosUpsertOne) videosModel()    {}
func (r videosUpsertOne) videosRelation() {}

func (r videosActions) UpsertOne(
	params VideosEqualsUniqueWhereParam,
) videosUpsertOne {
	var v videosUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Videos"
	v.query.Outputs = videosOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r videosUpsertOne) Create(

	_title VideosWithPrismaTitleSetParam,
	_description VideosWithPrismaDescriptionSetParam,
	_thumbnail VideosWithPrismaThumbnailSetParam,
	_videoURL VideosWithPrismaVideoURLSetParam,
	_duration VideosWithPrismaDurationSetParam,
	_owner VideosWithPrismaOwnerSetParam,
	_guild VideosWithPrismaGuildSetParam,

	optional ...VideosSetParam,
) videosUpsertOne {
	var v videosUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _title.field())
	fields = append(fields, _description.field())
	fields = append(fields, _thumbnail.field())
	fields = append(fields, _videoURL.field())
	fields = append(fields, _duration.field())
	fields = append(fields, _owner.field())
	fields = append(fields, _guild.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r videosUpsertOne) Update(
	params ...VideosSetParam,
) videosUpsertOne {
	var v videosUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r videosUpsertOne) CreateOrUpdate(

	_title VideosWithPrismaTitleSetParam,
	_description VideosWithPrismaDescriptionSetParam,
	_thumbnail VideosWithPrismaThumbnailSetParam,
	_videoURL VideosWithPrismaVideoURLSetParam,
	_duration VideosWithPrismaDurationSetParam,
	_owner VideosWithPrismaOwnerSetParam,
	_guild VideosWithPrismaGuildSetParam,

	optional ...VideosSetParam,
) videosUpsertOne {
	var v videosUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _title.field())
	fields = append(fields, _description.field())
	fields = append(fields, _thumbnail.field())
	fields = append(fields, _videoURL.field())
	fields = append(fields, _duration.field())
	fields = append(fields, _owner.field())
	fields = append(fields, _guild.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r videosUpsertOne) Exec(ctx context.Context) (*VideosModel, error) {
	var v VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r videosUpsertOne) Tx() VideosUniqueTxResult {
	v := newVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsUpsertOne struct {
	query builder.Query
}

func (r tagsUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r tagsUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsUpsertOne) with()         {}
func (r tagsUpsertOne) tagsModel()    {}
func (r tagsUpsertOne) tagsRelation() {}

func (r tagsActions) UpsertOne(
	params TagsEqualsUniqueWhereParam,
) tagsUpsertOne {
	var v tagsUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Tags"
	v.query.Outputs = tagsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r tagsUpsertOne) Create(

	_name TagsWithPrismaNameSetParam,
	_guild TagsWithPrismaGuildSetParam,

	optional ...TagsSetParam,
) tagsUpsertOne {
	var v tagsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _guild.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r tagsUpsertOne) Update(
	params ...TagsSetParam,
) tagsUpsertOne {
	var v tagsUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r tagsUpsertOne) CreateOrUpdate(

	_name TagsWithPrismaNameSetParam,
	_guild TagsWithPrismaGuildSetParam,

	optional ...TagsSetParam,
) tagsUpsertOne {
	var v tagsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _guild.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r tagsUpsertOne) Exec(ctx context.Context) (*TagsModel, error) {
	var v TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsUpsertOne) Tx() TagsUniqueTxResult {
	v := newTagsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type tagsOnVideosUpsertOne struct {
	query builder.Query
}

func (r tagsOnVideosUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosUpsertOne) with()                 {}
func (r tagsOnVideosUpsertOne) tagsOnVideosModel()    {}
func (r tagsOnVideosUpsertOne) tagsOnVideosRelation() {}

func (r tagsOnVideosActions) UpsertOne(
	params TagsOnVideosEqualsUniqueWhereParam,
) tagsOnVideosUpsertOne {
	var v tagsOnVideosUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "TagsOnVideos"
	v.query.Outputs = tagsOnVideosOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r tagsOnVideosUpsertOne) Create(

	_video TagsOnVideosWithPrismaVideoSetParam,
	_tag TagsOnVideosWithPrismaTagSetParam,

	optional ...TagsOnVideosSetParam,
) tagsOnVideosUpsertOne {
	var v tagsOnVideosUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _video.field())
	fields = append(fields, _tag.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r tagsOnVideosUpsertOne) Update(
	params ...TagsOnVideosSetParam,
) tagsOnVideosUpsertOne {
	var v tagsOnVideosUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r tagsOnVideosUpsertOne) CreateOrUpdate(

	_video TagsOnVideosWithPrismaVideoSetParam,
	_tag TagsOnVideosWithPrismaTagSetParam,

	optional ...TagsOnVideosSetParam,
) tagsOnVideosUpsertOne {
	var v tagsOnVideosUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _video.field())
	fields = append(fields, _tag.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r tagsOnVideosUpsertOne) Exec(ctx context.Context) (*TagsOnVideosModel, error) {
	var v TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r tagsOnVideosUpsertOne) Tx() TagsOnVideosUniqueTxResult {
	v := newTagsOnVideosUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type commentsUpsertOne struct {
	query builder.Query
}

func (r commentsUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r commentsUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsUpsertOne) with()             {}
func (r commentsUpsertOne) commentsModel()    {}
func (r commentsUpsertOne) commentsRelation() {}

func (r commentsActions) UpsertOne(
	params CommentsEqualsUniqueWhereParam,
) commentsUpsertOne {
	var v commentsUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Comments"
	v.query.Outputs = commentsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r commentsUpsertOne) Create(

	_role CommentsWithPrismaRoleSetParam,
	_videoID CommentsWithPrismaVideoIDSetParam,
	_content CommentsWithPrismaContentSetParam,
	_owner CommentsWithPrismaOwnerSetParam,

	optional ...CommentsSetParam,
) commentsUpsertOne {
	var v commentsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _role.field())
	fields = append(fields, _videoID.field())
	fields = append(fields, _content.field())
	fields = append(fields, _owner.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r commentsUpsertOne) Update(
	params ...CommentsSetParam,
) commentsUpsertOne {
	var v commentsUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r commentsUpsertOne) CreateOrUpdate(

	_role CommentsWithPrismaRoleSetParam,
	_videoID CommentsWithPrismaVideoIDSetParam,
	_content CommentsWithPrismaContentSetParam,
	_owner CommentsWithPrismaOwnerSetParam,

	optional ...CommentsSetParam,
) commentsUpsertOne {
	var v commentsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _role.field())
	fields = append(fields, _videoID.field())
	fields = append(fields, _content.field())
	fields = append(fields, _owner.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r commentsUpsertOne) Exec(ctx context.Context) (*CommentsModel, error) {
	var v CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r commentsUpsertOne) Tx() CommentsUniqueTxResult {
	v := newCommentsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type repliesUpsertOne struct {
	query builder.Query
}

func (r repliesUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r repliesUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesUpsertOne) with()            {}
func (r repliesUpsertOne) repliesModel()    {}
func (r repliesUpsertOne) repliesRelation() {}

func (r repliesActions) UpsertOne(
	params RepliesEqualsUniqueWhereParam,
) repliesUpsertOne {
	var v repliesUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Replies"
	v.query.Outputs = repliesOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r repliesUpsertOne) Create(

	_role RepliesWithPrismaRoleSetParam,
	_content RepliesWithPrismaContentSetParam,
	_videoID RepliesWithPrismaVideoIDSetParam,
	_owner RepliesWithPrismaOwnerSetParam,

	optional ...RepliesSetParam,
) repliesUpsertOne {
	var v repliesUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _role.field())
	fields = append(fields, _content.field())
	fields = append(fields, _videoID.field())
	fields = append(fields, _owner.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r repliesUpsertOne) Update(
	params ...RepliesSetParam,
) repliesUpsertOne {
	var v repliesUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r repliesUpsertOne) CreateOrUpdate(

	_role RepliesWithPrismaRoleSetParam,
	_content RepliesWithPrismaContentSetParam,
	_videoID RepliesWithPrismaVideoIDSetParam,
	_owner RepliesWithPrismaOwnerSetParam,

	optional ...RepliesSetParam,
) repliesUpsertOne {
	var v repliesUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _role.field())
	fields = append(fields, _content.field())
	fields = append(fields, _videoID.field())
	fields = append(fields, _owner.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r repliesUpsertOne) Exec(ctx context.Context) (*RepliesModel, error) {
	var v RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r repliesUpsertOne) Tx() RepliesUniqueTxResult {
	v := newRepliesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type likesUpsertOne struct {
	query builder.Query
}

func (r likesUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r likesUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r likesUpsertOne) with()          {}
func (r likesUpsertOne) likesModel()    {}
func (r likesUpsertOne) likesRelation() {}

func (r likesActions) UpsertOne(
	params LikesEqualsUniqueWhereParam,
) likesUpsertOne {
	var v likesUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "Likes"
	v.query.Outputs = likesOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r likesUpsertOne) Create(

	_entityType LikesWithPrismaEntityTypeSetParam,
	_owner LikesWithPrismaOwnerSetParam,

	optional ...LikesSetParam,
) likesUpsertOne {
	var v likesUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _entityType.field())
	fields = append(fields, _owner.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r likesUpsertOne) Update(
	params ...LikesSetParam,
) likesUpsertOne {
	var v likesUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r likesUpsertOne) CreateOrUpdate(

	_entityType LikesWithPrismaEntityTypeSetParam,
	_owner LikesWithPrismaOwnerSetParam,

	optional ...LikesSetParam,
) likesUpsertOne {
	var v likesUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _entityType.field())
	fields = append(fields, _owner.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r likesUpsertOne) Exec(ctx context.Context) (*LikesModel, error) {
	var v LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r likesUpsertOne) Tx() LikesUniqueTxResult {
	v := newLikesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type historyUpsertOne struct {
	query builder.Query
}

func (r historyUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r historyUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r historyUpsertOne) with()            {}
func (r historyUpsertOne) historyModel()    {}
func (r historyUpsertOne) historyRelation() {}

func (r historyActions) UpsertOne(
	params HistoryEqualsUniqueWhereParam,
) historyUpsertOne {
	var v historyUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "history"
	v.query.Outputs = historyOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r historyUpsertOne) Create(

	_userID HistoryWithPrismaUserIDSetParam,
	_video HistoryWithPrismaVideoSetParam,

	optional ...HistorySetParam,
) historyUpsertOne {
	var v historyUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _userID.field())
	fields = append(fields, _video.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r historyUpsertOne) Update(
	params ...HistorySetParam,
) historyUpsertOne {
	var v historyUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r historyUpsertOne) CreateOrUpdate(

	_userID HistoryWithPrismaUserIDSetParam,
	_video HistoryWithPrismaVideoSetParam,

	optional ...HistorySetParam,
) historyUpsertOne {
	var v historyUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _userID.field())
	fields = append(fields, _video.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r historyUpsertOne) Exec(ctx context.Context) (*HistoryModel, error) {
	var v HistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r historyUpsertOne) Tx() HistoryUniqueTxResult {
	v := newHistoryUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type watchLaterUpsertOne struct {
	query builder.Query
}

func (r watchLaterUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r watchLaterUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r watchLaterUpsertOne) with()               {}
func (r watchLaterUpsertOne) watchLaterModel()    {}
func (r watchLaterUpsertOne) watchLaterRelation() {}

func (r watchLaterActions) UpsertOne(
	params WatchLaterEqualsUniqueWhereParam,
) watchLaterUpsertOne {
	var v watchLaterUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "WatchLater"
	v.query.Outputs = watchLaterOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r watchLaterUpsertOne) Create(

	_userID WatchLaterWithPrismaUserIDSetParam,
	_video WatchLaterWithPrismaVideoSetParam,

	optional ...WatchLaterSetParam,
) watchLaterUpsertOne {
	var v watchLaterUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _userID.field())
	fields = append(fields, _video.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r watchLaterUpsertOne) Update(
	params ...WatchLaterSetParam,
) watchLaterUpsertOne {
	var v watchLaterUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r watchLaterUpsertOne) CreateOrUpdate(

	_userID WatchLaterWithPrismaUserIDSetParam,
	_video WatchLaterWithPrismaVideoSetParam,

	optional ...WatchLaterSetParam,
) watchLaterUpsertOne {
	var v watchLaterUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _userID.field())
	fields = append(fields, _video.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r watchLaterUpsertOne) Exec(ctx context.Context) (*WatchLaterModel, error) {
	var v WatchLaterModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r watchLaterUpsertOne) Tx() WatchLaterUniqueTxResult {
	v := newWatchLaterUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template raw.gotpl ---

type userAggregateRaw struct {
	query builder.Query
}

func (r userAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r userAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r userAggregateRaw) with()         {}
func (r userAggregateRaw) userModel()    {}
func (r userAggregateRaw) userRelation() {}

func (r userActions) FindRaw(filter interface{}, options ...interface{}) userAggregateRaw {
	var v userAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "User"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r userActions) AggregateRaw(pipeline []interface{}, options ...interface{}) userAggregateRaw {
	var v userAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "User"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r userAggregateRaw) Exec(ctx context.Context) ([]UserModel, error) {
	var v []UserModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r userAggregateRaw) ExecInner(ctx context.Context) ([]InnerUser, error) {
	var v []InnerUser
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type guildAggregateRaw struct {
	query builder.Query
}

func (r guildAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r guildAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r guildAggregateRaw) with()          {}
func (r guildAggregateRaw) guildModel()    {}
func (r guildAggregateRaw) guildRelation() {}

func (r guildActions) FindRaw(filter interface{}, options ...interface{}) guildAggregateRaw {
	var v guildAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Guild"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r guildActions) AggregateRaw(pipeline []interface{}, options ...interface{}) guildAggregateRaw {
	var v guildAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Guild"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r guildAggregateRaw) Exec(ctx context.Context) ([]GuildModel, error) {
	var v []GuildModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r guildAggregateRaw) ExecInner(ctx context.Context) ([]InnerGuild, error) {
	var v []InnerGuild
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type guildMemberAggregateRaw struct {
	query builder.Query
}

func (r guildMemberAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r guildMemberAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r guildMemberAggregateRaw) with()                {}
func (r guildMemberAggregateRaw) guildMemberModel()    {}
func (r guildMemberAggregateRaw) guildMemberRelation() {}

func (r guildMemberActions) FindRaw(filter interface{}, options ...interface{}) guildMemberAggregateRaw {
	var v guildMemberAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "GuildMember"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r guildMemberActions) AggregateRaw(pipeline []interface{}, options ...interface{}) guildMemberAggregateRaw {
	var v guildMemberAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "GuildMember"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r guildMemberAggregateRaw) Exec(ctx context.Context) ([]GuildMemberModel, error) {
	var v []GuildMemberModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r guildMemberAggregateRaw) ExecInner(ctx context.Context) ([]InnerGuildMember, error) {
	var v []InnerGuildMember
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type videosAggregateRaw struct {
	query builder.Query
}

func (r videosAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r videosAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r videosAggregateRaw) with()           {}
func (r videosAggregateRaw) videosModel()    {}
func (r videosAggregateRaw) videosRelation() {}

func (r videosActions) FindRaw(filter interface{}, options ...interface{}) videosAggregateRaw {
	var v videosAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Videos"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r videosActions) AggregateRaw(pipeline []interface{}, options ...interface{}) videosAggregateRaw {
	var v videosAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Videos"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r videosAggregateRaw) Exec(ctx context.Context) ([]VideosModel, error) {
	var v []VideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r videosAggregateRaw) ExecInner(ctx context.Context) ([]InnerVideos, error) {
	var v []InnerVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type tagsAggregateRaw struct {
	query builder.Query
}

func (r tagsAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r tagsAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsAggregateRaw) with()         {}
func (r tagsAggregateRaw) tagsModel()    {}
func (r tagsAggregateRaw) tagsRelation() {}

func (r tagsActions) FindRaw(filter interface{}, options ...interface{}) tagsAggregateRaw {
	var v tagsAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Tags"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r tagsActions) AggregateRaw(pipeline []interface{}, options ...interface{}) tagsAggregateRaw {
	var v tagsAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Tags"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r tagsAggregateRaw) Exec(ctx context.Context) ([]TagsModel, error) {
	var v []TagsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r tagsAggregateRaw) ExecInner(ctx context.Context) ([]InnerTags, error) {
	var v []InnerTags
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type tagsOnVideosAggregateRaw struct {
	query builder.Query
}

func (r tagsOnVideosAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r tagsOnVideosAggregateRaw) with()                 {}
func (r tagsOnVideosAggregateRaw) tagsOnVideosModel()    {}
func (r tagsOnVideosAggregateRaw) tagsOnVideosRelation() {}

func (r tagsOnVideosActions) FindRaw(filter interface{}, options ...interface{}) tagsOnVideosAggregateRaw {
	var v tagsOnVideosAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "TagsOnVideos"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r tagsOnVideosActions) AggregateRaw(pipeline []interface{}, options ...interface{}) tagsOnVideosAggregateRaw {
	var v tagsOnVideosAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "TagsOnVideos"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r tagsOnVideosAggregateRaw) Exec(ctx context.Context) ([]TagsOnVideosModel, error) {
	var v []TagsOnVideosModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r tagsOnVideosAggregateRaw) ExecInner(ctx context.Context) ([]InnerTagsOnVideos, error) {
	var v []InnerTagsOnVideos
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type commentsAggregateRaw struct {
	query builder.Query
}

func (r commentsAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r commentsAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r commentsAggregateRaw) with()             {}
func (r commentsAggregateRaw) commentsModel()    {}
func (r commentsAggregateRaw) commentsRelation() {}

func (r commentsActions) FindRaw(filter interface{}, options ...interface{}) commentsAggregateRaw {
	var v commentsAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Comments"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r commentsActions) AggregateRaw(pipeline []interface{}, options ...interface{}) commentsAggregateRaw {
	var v commentsAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Comments"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r commentsAggregateRaw) Exec(ctx context.Context) ([]CommentsModel, error) {
	var v []CommentsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r commentsAggregateRaw) ExecInner(ctx context.Context) ([]InnerComments, error) {
	var v []InnerComments
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type repliesAggregateRaw struct {
	query builder.Query
}

func (r repliesAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r repliesAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r repliesAggregateRaw) with()            {}
func (r repliesAggregateRaw) repliesModel()    {}
func (r repliesAggregateRaw) repliesRelation() {}

func (r repliesActions) FindRaw(filter interface{}, options ...interface{}) repliesAggregateRaw {
	var v repliesAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Replies"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r repliesActions) AggregateRaw(pipeline []interface{}, options ...interface{}) repliesAggregateRaw {
	var v repliesAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Replies"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r repliesAggregateRaw) Exec(ctx context.Context) ([]RepliesModel, error) {
	var v []RepliesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r repliesAggregateRaw) ExecInner(ctx context.Context) ([]InnerReplies, error) {
	var v []InnerReplies
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type likesAggregateRaw struct {
	query builder.Query
}

func (r likesAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r likesAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r likesAggregateRaw) with()          {}
func (r likesAggregateRaw) likesModel()    {}
func (r likesAggregateRaw) likesRelation() {}

func (r likesActions) FindRaw(filter interface{}, options ...interface{}) likesAggregateRaw {
	var v likesAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "Likes"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r likesActions) AggregateRaw(pipeline []interface{}, options ...interface{}) likesAggregateRaw {
	var v likesAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "Likes"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r likesAggregateRaw) Exec(ctx context.Context) ([]LikesModel, error) {
	var v []LikesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r likesAggregateRaw) ExecInner(ctx context.Context) ([]InnerLikes, error) {
	var v []InnerLikes
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type historyAggregateRaw struct {
	query builder.Query
}

func (r historyAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r historyAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r historyAggregateRaw) with()            {}
func (r historyAggregateRaw) historyModel()    {}
func (r historyAggregateRaw) historyRelation() {}

func (r historyActions) FindRaw(filter interface{}, options ...interface{}) historyAggregateRaw {
	var v historyAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "history"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r historyActions) AggregateRaw(pipeline []interface{}, options ...interface{}) historyAggregateRaw {
	var v historyAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "history"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r historyAggregateRaw) Exec(ctx context.Context) ([]HistoryModel, error) {
	var v []HistoryModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r historyAggregateRaw) ExecInner(ctx context.Context) ([]InnerHistory, error) {
	var v []InnerHistory
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type watchLaterAggregateRaw struct {
	query builder.Query
}

func (r watchLaterAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r watchLaterAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r watchLaterAggregateRaw) with()               {}
func (r watchLaterAggregateRaw) watchLaterModel()    {}
func (r watchLaterAggregateRaw) watchLaterRelation() {}

func (r watchLaterActions) FindRaw(filter interface{}, options ...interface{}) watchLaterAggregateRaw {
	var v watchLaterAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "WatchLater"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r watchLaterActions) AggregateRaw(pipeline []interface{}, options ...interface{}) watchLaterAggregateRaw {
	var v watchLaterAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "WatchLater"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r watchLaterAggregateRaw) Exec(ctx context.Context) ([]WatchLaterModel, error) {
	var v []WatchLaterModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r watchLaterAggregateRaw) ExecInner(ctx context.Context) ([]InnerWatchLater, error) {
	var v []InnerWatchLater
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}
